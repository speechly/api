// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: speechly/analytics/v1/analytics_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "speechly/analytics/v1/analytics.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
namespace speechly {
namespace analytics {
namespace v1 {
class ModerationStatisticsRequest;
struct ModerationStatisticsRequestDefaultTypeInternal;
extern ModerationStatisticsRequestDefaultTypeInternal _ModerationStatisticsRequest_default_instance_;
class ModerationStatisticsResponse;
struct ModerationStatisticsResponseDefaultTypeInternal;
extern ModerationStatisticsResponseDefaultTypeInternal _ModerationStatisticsResponse_default_instance_;
class RegisterUtteranceRequest;
struct RegisterUtteranceRequestDefaultTypeInternal;
extern RegisterUtteranceRequestDefaultTypeInternal _RegisterUtteranceRequest_default_instance_;
class RegisterUtteranceResponse;
struct RegisterUtteranceResponseDefaultTypeInternal;
extern RegisterUtteranceResponseDefaultTypeInternal _RegisterUtteranceResponse_default_instance_;
class RegisterUtterancesRequest;
struct RegisterUtterancesRequestDefaultTypeInternal;
extern RegisterUtterancesRequestDefaultTypeInternal _RegisterUtterancesRequest_default_instance_;
class RegisterUtterancesResponse;
struct RegisterUtterancesResponseDefaultTypeInternal;
extern RegisterUtterancesResponseDefaultTypeInternal _RegisterUtterancesResponse_default_instance_;
class UserStatisticsRequest;
struct UserStatisticsRequestDefaultTypeInternal;
extern UserStatisticsRequestDefaultTypeInternal _UserStatisticsRequest_default_instance_;
class UserStatisticsResponse;
struct UserStatisticsResponseDefaultTypeInternal;
extern UserStatisticsResponseDefaultTypeInternal _UserStatisticsResponse_default_instance_;
class UtteranceStatisticsRequest;
struct UtteranceStatisticsRequestDefaultTypeInternal;
extern UtteranceStatisticsRequestDefaultTypeInternal _UtteranceStatisticsRequest_default_instance_;
class UtteranceStatisticsResponse;
struct UtteranceStatisticsResponseDefaultTypeInternal;
extern UtteranceStatisticsResponseDefaultTypeInternal _UtteranceStatisticsResponse_default_instance_;
class UtterancesRequest;
struct UtterancesRequestDefaultTypeInternal;
extern UtterancesRequestDefaultTypeInternal _UtterancesRequest_default_instance_;
class UtterancesResponse;
struct UtterancesResponseDefaultTypeInternal;
extern UtterancesResponseDefaultTypeInternal _UtterancesResponse_default_instance_;
}  // namespace v1
}  // namespace analytics
}  // namespace speechly
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace speechly {
namespace analytics {
namespace v1 {
enum UtteranceStatisticsRequest_Scope : int {
  UtteranceStatisticsRequest_Scope_SCOPE_INVALID = 0,
  UtteranceStatisticsRequest_Scope_SCOPE_UTTERANCES = 1,
  UtteranceStatisticsRequest_Scope_SCOPE_ANNOTATIONS = 2,
  UtteranceStatisticsRequest_Scope_SCOPE_ALL = 3,
  UtteranceStatisticsRequest_Scope_UtteranceStatisticsRequest_Scope_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UtteranceStatisticsRequest_Scope_UtteranceStatisticsRequest_Scope_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UtteranceStatisticsRequest_Scope_IsValid(int value);
constexpr UtteranceStatisticsRequest_Scope UtteranceStatisticsRequest_Scope_Scope_MIN = static_cast<UtteranceStatisticsRequest_Scope>(0);
constexpr UtteranceStatisticsRequest_Scope UtteranceStatisticsRequest_Scope_Scope_MAX = static_cast<UtteranceStatisticsRequest_Scope>(3);
constexpr int UtteranceStatisticsRequest_Scope_Scope_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UtteranceStatisticsRequest_Scope_descriptor();
template <typename T>
const std::string& UtteranceStatisticsRequest_Scope_Name(T value) {
  static_assert(std::is_same<T, UtteranceStatisticsRequest_Scope>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Scope_Name().");
  return UtteranceStatisticsRequest_Scope_Name(static_cast<UtteranceStatisticsRequest_Scope>(value));
}
template <>
inline const std::string& UtteranceStatisticsRequest_Scope_Name(UtteranceStatisticsRequest_Scope value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UtteranceStatisticsRequest_Scope_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UtteranceStatisticsRequest_Scope_Parse(absl::string_view name, UtteranceStatisticsRequest_Scope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UtteranceStatisticsRequest_Scope>(
      UtteranceStatisticsRequest_Scope_descriptor(), name, value);
}
enum RegisterUtteranceRequest_Status : int {
  RegisterUtteranceRequest_Status_STATUS_INVALID = 0,
  RegisterUtteranceRequest_Status_STATUS_SUCCESS = 1,
  RegisterUtteranceRequest_Status_STATUS_ERROR = 2,
  RegisterUtteranceRequest_Status_RegisterUtteranceRequest_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RegisterUtteranceRequest_Status_RegisterUtteranceRequest_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RegisterUtteranceRequest_Status_IsValid(int value);
constexpr RegisterUtteranceRequest_Status RegisterUtteranceRequest_Status_Status_MIN = static_cast<RegisterUtteranceRequest_Status>(0);
constexpr RegisterUtteranceRequest_Status RegisterUtteranceRequest_Status_Status_MAX = static_cast<RegisterUtteranceRequest_Status>(2);
constexpr int RegisterUtteranceRequest_Status_Status_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RegisterUtteranceRequest_Status_descriptor();
template <typename T>
const std::string& RegisterUtteranceRequest_Status_Name(T value) {
  static_assert(std::is_same<T, RegisterUtteranceRequest_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return RegisterUtteranceRequest_Status_Name(static_cast<RegisterUtteranceRequest_Status>(value));
}
template <>
inline const std::string& RegisterUtteranceRequest_Status_Name(RegisterUtteranceRequest_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RegisterUtteranceRequest_Status_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RegisterUtteranceRequest_Status_Parse(absl::string_view name, RegisterUtteranceRequest_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterUtteranceRequest_Status>(
      RegisterUtteranceRequest_Status_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UtteranceStatisticsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.UtteranceStatisticsRequest) */ {
 public:
  inline UtteranceStatisticsRequest() : UtteranceStatisticsRequest(nullptr) {}
  ~UtteranceStatisticsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UtteranceStatisticsRequest(::google::protobuf::internal::ConstantInitialized);

  UtteranceStatisticsRequest(const UtteranceStatisticsRequest& from);
  UtteranceStatisticsRequest(UtteranceStatisticsRequest&& from) noexcept
    : UtteranceStatisticsRequest() {
    *this = ::std::move(from);
  }

  inline UtteranceStatisticsRequest& operator=(const UtteranceStatisticsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UtteranceStatisticsRequest& operator=(UtteranceStatisticsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UtteranceStatisticsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UtteranceStatisticsRequest* internal_default_instance() {
    return reinterpret_cast<const UtteranceStatisticsRequest*>(
               &_UtteranceStatisticsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UtteranceStatisticsRequest& a, UtteranceStatisticsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UtteranceStatisticsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UtteranceStatisticsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UtteranceStatisticsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UtteranceStatisticsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UtteranceStatisticsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UtteranceStatisticsRequest& from) {
    UtteranceStatisticsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UtteranceStatisticsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.UtteranceStatisticsRequest";
  }
  protected:
  explicit UtteranceStatisticsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Scope = UtteranceStatisticsRequest_Scope;
  static constexpr Scope SCOPE_INVALID = UtteranceStatisticsRequest_Scope_SCOPE_INVALID;
  static constexpr Scope SCOPE_UTTERANCES = UtteranceStatisticsRequest_Scope_SCOPE_UTTERANCES;
  static constexpr Scope SCOPE_ANNOTATIONS = UtteranceStatisticsRequest_Scope_SCOPE_ANNOTATIONS;
  static constexpr Scope SCOPE_ALL = UtteranceStatisticsRequest_Scope_SCOPE_ALL;
  static inline bool Scope_IsValid(int value) {
    return UtteranceStatisticsRequest_Scope_IsValid(value);
  }
  static constexpr Scope Scope_MIN = UtteranceStatisticsRequest_Scope_Scope_MIN;
  static constexpr Scope Scope_MAX = UtteranceStatisticsRequest_Scope_Scope_MAX;
  static constexpr int Scope_ARRAYSIZE = UtteranceStatisticsRequest_Scope_Scope_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Scope_descriptor() {
    return UtteranceStatisticsRequest_Scope_descriptor();
  }
  template <typename T>
  static inline const std::string& Scope_Name(T value) {
    return UtteranceStatisticsRequest_Scope_Name(value);
  }
  static inline bool Scope_Parse(absl::string_view name, Scope* value) {
    return UtteranceStatisticsRequest_Scope_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kStartDateFieldNumber = 5,
    kEndDateFieldNumber = 6,
    kProjectIdFieldNumber = 7,
    kDaysFieldNumber = 2,
    kScopeFieldNumber = 3,
    kAggregationFieldNumber = 4,
  };
  // string app_id = 1;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string start_date = 5;
  void clear_start_date() ;
  const std::string& start_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_date(Arg_&& arg, Args_... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* ptr);

  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(
      const std::string& value);
  std::string* _internal_mutable_start_date();

  public:
  // string end_date = 6;
  void clear_end_date() ;
  const std::string& end_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_end_date(Arg_&& arg, Args_... args);
  std::string* mutable_end_date();
  PROTOBUF_NODISCARD std::string* release_end_date();
  void set_allocated_end_date(std::string* ptr);

  private:
  const std::string& _internal_end_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_date(
      const std::string& value);
  std::string* _internal_mutable_end_date();

  public:
  // string project_id = 7;
  void clear_project_id() ;
  const std::string& project_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project_id(Arg_&& arg, Args_... args);
  std::string* mutable_project_id();
  PROTOBUF_NODISCARD std::string* release_project_id();
  void set_allocated_project_id(std::string* ptr);

  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(
      const std::string& value);
  std::string* _internal_mutable_project_id();

  public:
  // int32 days = 2;
  void clear_days() ;
  ::int32_t days() const;
  void set_days(::int32_t value);

  private:
  ::int32_t _internal_days() const;
  void _internal_set_days(::int32_t value);

  public:
  // .speechly.analytics.v1.UtteranceStatisticsRequest.Scope scope = 3;
  void clear_scope() ;
  ::speechly::analytics::v1::UtteranceStatisticsRequest_Scope scope() const;
  void set_scope(::speechly::analytics::v1::UtteranceStatisticsRequest_Scope value);

  private:
  ::speechly::analytics::v1::UtteranceStatisticsRequest_Scope _internal_scope() const;
  void _internal_set_scope(::speechly::analytics::v1::UtteranceStatisticsRequest_Scope value);

  public:
  // .speechly.analytics.v1.Aggregation aggregation = 4;
  void clear_aggregation() ;
  ::speechly::analytics::v1::Aggregation aggregation() const;
  void set_aggregation(::speechly::analytics::v1::Aggregation value);

  private:
  ::speechly::analytics::v1::Aggregation _internal_aggregation() const;
  void _internal_set_aggregation(::speechly::analytics::v1::Aggregation value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.UtteranceStatisticsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 0, 91, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr start_date_;
    ::google::protobuf::internal::ArenaStringPtr end_date_;
    ::google::protobuf::internal::ArenaStringPtr project_id_;
    ::int32_t days_;
    int scope_;
    int aggregation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class UtteranceStatisticsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.UtteranceStatisticsResponse) */ {
 public:
  inline UtteranceStatisticsResponse() : UtteranceStatisticsResponse(nullptr) {}
  ~UtteranceStatisticsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UtteranceStatisticsResponse(::google::protobuf::internal::ConstantInitialized);

  UtteranceStatisticsResponse(const UtteranceStatisticsResponse& from);
  UtteranceStatisticsResponse(UtteranceStatisticsResponse&& from) noexcept
    : UtteranceStatisticsResponse() {
    *this = ::std::move(from);
  }

  inline UtteranceStatisticsResponse& operator=(const UtteranceStatisticsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UtteranceStatisticsResponse& operator=(UtteranceStatisticsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UtteranceStatisticsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UtteranceStatisticsResponse* internal_default_instance() {
    return reinterpret_cast<const UtteranceStatisticsResponse*>(
               &_UtteranceStatisticsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UtteranceStatisticsResponse& a, UtteranceStatisticsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UtteranceStatisticsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UtteranceStatisticsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UtteranceStatisticsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UtteranceStatisticsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UtteranceStatisticsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UtteranceStatisticsResponse& from) {
    UtteranceStatisticsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UtteranceStatisticsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.UtteranceStatisticsResponse";
  }
  protected:
  explicit UtteranceStatisticsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 4,
    kStartDateFieldNumber = 1,
    kEndDateFieldNumber = 2,
    kAggregationFieldNumber = 3,
    kTotalUtterancesFieldNumber = 5,
    kTotalDurationSecondsFieldNumber = 6,
    kTotalAnnotatedSecondsFieldNumber = 7,
  };
  // repeated .speechly.analytics.v1.UtteranceStatisticsPeriod items = 4;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::speechly::analytics::v1::UtteranceStatisticsPeriod* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::UtteranceStatisticsPeriod >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::UtteranceStatisticsPeriod>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::UtteranceStatisticsPeriod>* _internal_mutable_items();
  public:
  const ::speechly::analytics::v1::UtteranceStatisticsPeriod& items(int index) const;
  ::speechly::analytics::v1::UtteranceStatisticsPeriod* add_items();
  const ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::UtteranceStatisticsPeriod >&
      items() const;
  // string start_date = 1;
  void clear_start_date() ;
  const std::string& start_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_date(Arg_&& arg, Args_... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* ptr);

  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(
      const std::string& value);
  std::string* _internal_mutable_start_date();

  public:
  // string end_date = 2;
  void clear_end_date() ;
  const std::string& end_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_end_date(Arg_&& arg, Args_... args);
  std::string* mutable_end_date();
  PROTOBUF_NODISCARD std::string* release_end_date();
  void set_allocated_end_date(std::string* ptr);

  private:
  const std::string& _internal_end_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_date(
      const std::string& value);
  std::string* _internal_mutable_end_date();

  public:
  // .speechly.analytics.v1.Aggregation aggregation = 3;
  void clear_aggregation() ;
  ::speechly::analytics::v1::Aggregation aggregation() const;
  void set_aggregation(::speechly::analytics::v1::Aggregation value);

  private:
  ::speechly::analytics::v1::Aggregation _internal_aggregation() const;
  void _internal_set_aggregation(::speechly::analytics::v1::Aggregation value);

  public:
  // int32 total_utterances = 5;
  void clear_total_utterances() ;
  ::int32_t total_utterances() const;
  void set_total_utterances(::int32_t value);

  private:
  ::int32_t _internal_total_utterances() const;
  void _internal_set_total_utterances(::int32_t value);

  public:
  // int32 total_duration_seconds = 6;
  void clear_total_duration_seconds() ;
  ::int32_t total_duration_seconds() const;
  void set_total_duration_seconds(::int32_t value);

  private:
  ::int32_t _internal_total_duration_seconds() const;
  void _internal_set_total_duration_seconds(::int32_t value);

  public:
  // int32 total_annotated_seconds = 7;
  void clear_total_annotated_seconds() ;
  ::int32_t total_annotated_seconds() const;
  void set_total_annotated_seconds(::int32_t value);

  private:
  ::int32_t _internal_total_annotated_seconds() const;
  void _internal_set_total_annotated_seconds(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.UtteranceStatisticsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 1, 76, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::UtteranceStatisticsPeriod > items_;
    ::google::protobuf::internal::ArenaStringPtr start_date_;
    ::google::protobuf::internal::ArenaStringPtr end_date_;
    int aggregation_;
    ::int32_t total_utterances_;
    ::int32_t total_duration_seconds_;
    ::int32_t total_annotated_seconds_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class UtterancesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.UtterancesRequest) */ {
 public:
  inline UtterancesRequest() : UtterancesRequest(nullptr) {}
  ~UtterancesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UtterancesRequest(::google::protobuf::internal::ConstantInitialized);

  UtterancesRequest(const UtterancesRequest& from);
  UtterancesRequest(UtterancesRequest&& from) noexcept
    : UtterancesRequest() {
    *this = ::std::move(from);
  }

  inline UtterancesRequest& operator=(const UtterancesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UtterancesRequest& operator=(UtterancesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UtterancesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UtterancesRequest* internal_default_instance() {
    return reinterpret_cast<const UtterancesRequest*>(
               &_UtterancesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UtterancesRequest& a, UtterancesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UtterancesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UtterancesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UtterancesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UtterancesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UtterancesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UtterancesRequest& from) {
    UtterancesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UtterancesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.UtterancesRequest";
  }
  protected:
  explicit UtterancesRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
  };
  // string app_id = 1;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.UtterancesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 54, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class UtterancesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.UtterancesResponse) */ {
 public:
  inline UtterancesResponse() : UtterancesResponse(nullptr) {}
  ~UtterancesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UtterancesResponse(::google::protobuf::internal::ConstantInitialized);

  UtterancesResponse(const UtterancesResponse& from);
  UtterancesResponse(UtterancesResponse&& from) noexcept
    : UtterancesResponse() {
    *this = ::std::move(from);
  }

  inline UtterancesResponse& operator=(const UtterancesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UtterancesResponse& operator=(UtterancesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UtterancesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UtterancesResponse* internal_default_instance() {
    return reinterpret_cast<const UtterancesResponse*>(
               &_UtterancesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UtterancesResponse& a, UtterancesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UtterancesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UtterancesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UtterancesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UtterancesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UtterancesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UtterancesResponse& from) {
    UtterancesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UtterancesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.UtterancesResponse";
  }
  protected:
  explicit UtterancesResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtterancesFieldNumber = 1,
  };
  // repeated .speechly.analytics.v1.Utterance utterances = 1;
  int utterances_size() const;
  private:
  int _internal_utterances_size() const;

  public:
  void clear_utterances() ;
  ::speechly::analytics::v1::Utterance* mutable_utterances(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::Utterance >*
      mutable_utterances();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::Utterance>& _internal_utterances() const;
  ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::Utterance>* _internal_mutable_utterances();
  public:
  const ::speechly::analytics::v1::Utterance& utterances(int index) const;
  ::speechly::analytics::v1::Utterance* add_utterances();
  const ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::Utterance >&
      utterances() const;
  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.UtterancesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::Utterance > utterances_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class RegisterUtteranceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.RegisterUtteranceRequest) */ {
 public:
  inline RegisterUtteranceRequest() : RegisterUtteranceRequest(nullptr) {}
  ~RegisterUtteranceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterUtteranceRequest(::google::protobuf::internal::ConstantInitialized);

  RegisterUtteranceRequest(const RegisterUtteranceRequest& from);
  RegisterUtteranceRequest(RegisterUtteranceRequest&& from) noexcept
    : RegisterUtteranceRequest() {
    *this = ::std::move(from);
  }

  inline RegisterUtteranceRequest& operator=(const RegisterUtteranceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterUtteranceRequest& operator=(RegisterUtteranceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterUtteranceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterUtteranceRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterUtteranceRequest*>(
               &_RegisterUtteranceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegisterUtteranceRequest& a, RegisterUtteranceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterUtteranceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterUtteranceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterUtteranceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterUtteranceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterUtteranceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RegisterUtteranceRequest& from) {
    RegisterUtteranceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterUtteranceRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.RegisterUtteranceRequest";
  }
  protected:
  explicit RegisterUtteranceRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Status = RegisterUtteranceRequest_Status;
  static constexpr Status STATUS_INVALID = RegisterUtteranceRequest_Status_STATUS_INVALID;
  static constexpr Status STATUS_SUCCESS = RegisterUtteranceRequest_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_ERROR = RegisterUtteranceRequest_Status_STATUS_ERROR;
  static inline bool Status_IsValid(int value) {
    return RegisterUtteranceRequest_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = RegisterUtteranceRequest_Status_Status_MIN;
  static constexpr Status Status_MAX = RegisterUtteranceRequest_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = RegisterUtteranceRequest_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return RegisterUtteranceRequest_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return RegisterUtteranceRequest_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return RegisterUtteranceRequest_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
    kOperationIdFieldNumber = 9,
    kBatchIdFieldNumber = 10,
    kProjectIdFieldNumber = 11,
    kLanguageFieldNumber = 12,
    kDecoderInfoFieldNumber = 5,
    kCreatedTimeFieldNumber = 6,
    kFinishedTimeFieldNumber = 7,
    kProcessingInfoFieldNumber = 13,
    kUtteranceLengthSecondsFieldNumber = 3,
    kUtteranceLengthCharsFieldNumber = 4,
    kStatusFieldNumber = 8,
  };
  // string app_id = 1;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string device_id = 2;
  void clear_device_id() ;
  const std::string& device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* ptr);

  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(
      const std::string& value);
  std::string* _internal_mutable_device_id();

  public:
  // string operation_id = 9;
  void clear_operation_id() ;
  const std::string& operation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_id(Arg_&& arg, Args_... args);
  std::string* mutable_operation_id();
  PROTOBUF_NODISCARD std::string* release_operation_id();
  void set_allocated_operation_id(std::string* ptr);

  private:
  const std::string& _internal_operation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_id(
      const std::string& value);
  std::string* _internal_mutable_operation_id();

  public:
  // string batch_id = 10;
  void clear_batch_id() ;
  const std::string& batch_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_batch_id(Arg_&& arg, Args_... args);
  std::string* mutable_batch_id();
  PROTOBUF_NODISCARD std::string* release_batch_id();
  void set_allocated_batch_id(std::string* ptr);

  private:
  const std::string& _internal_batch_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_id(
      const std::string& value);
  std::string* _internal_mutable_batch_id();

  public:
  // string project_id = 11;
  void clear_project_id() ;
  const std::string& project_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project_id(Arg_&& arg, Args_... args);
  std::string* mutable_project_id();
  PROTOBUF_NODISCARD std::string* release_project_id();
  void set_allocated_project_id(std::string* ptr);

  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(
      const std::string& value);
  std::string* _internal_mutable_project_id();

  public:
  // string language = 12;
  void clear_language() ;
  const std::string& language() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language(Arg_&& arg, Args_... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* ptr);

  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(
      const std::string& value);
  std::string* _internal_mutable_language();

  public:
  // .speechly.analytics.v1.DecoderInfo decoder_info = 5;
  bool has_decoder_info() const;
  void clear_decoder_info() ;
  const ::speechly::analytics::v1::DecoderInfo& decoder_info() const;
  PROTOBUF_NODISCARD ::speechly::analytics::v1::DecoderInfo* release_decoder_info();
  ::speechly::analytics::v1::DecoderInfo* mutable_decoder_info();
  void set_allocated_decoder_info(::speechly::analytics::v1::DecoderInfo* value);
  void unsafe_arena_set_allocated_decoder_info(::speechly::analytics::v1::DecoderInfo* value);
  ::speechly::analytics::v1::DecoderInfo* unsafe_arena_release_decoder_info();

  private:
  const ::speechly::analytics::v1::DecoderInfo& _internal_decoder_info() const;
  ::speechly::analytics::v1::DecoderInfo* _internal_mutable_decoder_info();

  public:
  // .google.protobuf.Timestamp created_time = 6;
  bool has_created_time() const;
  void clear_created_time() ;
  const ::google::protobuf::Timestamp& created_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_time();
  ::google::protobuf::Timestamp* mutable_created_time();
  void set_allocated_created_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_time();

  private:
  const ::google::protobuf::Timestamp& _internal_created_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_time();

  public:
  // .google.protobuf.Timestamp finished_time = 7;
  bool has_finished_time() const;
  void clear_finished_time() ;
  const ::google::protobuf::Timestamp& finished_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_finished_time();
  ::google::protobuf::Timestamp* mutable_finished_time();
  void set_allocated_finished_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_finished_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_finished_time();

  private:
  const ::google::protobuf::Timestamp& _internal_finished_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_finished_time();

  public:
  // .speechly.analytics.v1.ProcessingInfo processing_info = 13;
  bool has_processing_info() const;
  void clear_processing_info() ;
  const ::speechly::analytics::v1::ProcessingInfo& processing_info() const;
  PROTOBUF_NODISCARD ::speechly::analytics::v1::ProcessingInfo* release_processing_info();
  ::speechly::analytics::v1::ProcessingInfo* mutable_processing_info();
  void set_allocated_processing_info(::speechly::analytics::v1::ProcessingInfo* value);
  void unsafe_arena_set_allocated_processing_info(::speechly::analytics::v1::ProcessingInfo* value);
  ::speechly::analytics::v1::ProcessingInfo* unsafe_arena_release_processing_info();

  private:
  const ::speechly::analytics::v1::ProcessingInfo& _internal_processing_info() const;
  ::speechly::analytics::v1::ProcessingInfo* _internal_mutable_processing_info();

  public:
  // int32 utterance_length_seconds = 3;
  void clear_utterance_length_seconds() ;
  ::int32_t utterance_length_seconds() const;
  void set_utterance_length_seconds(::int32_t value);

  private:
  ::int32_t _internal_utterance_length_seconds() const;
  void _internal_set_utterance_length_seconds(::int32_t value);

  public:
  // int32 utterance_length_chars = 4;
  void clear_utterance_length_chars() ;
  ::int32_t utterance_length_chars() const;
  void set_utterance_length_chars(::int32_t value);

  private:
  ::int32_t _internal_utterance_length_chars() const;
  void _internal_set_utterance_length_chars(::int32_t value);

  public:
  // .speechly.analytics.v1.RegisterUtteranceRequest.Status status = 8;
  void clear_status() ;
  ::speechly::analytics::v1::RegisterUtteranceRequest_Status status() const;
  void set_status(::speechly::analytics::v1::RegisterUtteranceRequest_Status value);

  private:
  ::speechly::analytics::v1::RegisterUtteranceRequest_Status _internal_status() const;
  void _internal_set_status(::speechly::analytics::v1::RegisterUtteranceRequest_Status value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.RegisterUtteranceRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 13, 4, 116, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr device_id_;
    ::google::protobuf::internal::ArenaStringPtr operation_id_;
    ::google::protobuf::internal::ArenaStringPtr batch_id_;
    ::google::protobuf::internal::ArenaStringPtr project_id_;
    ::google::protobuf::internal::ArenaStringPtr language_;
    ::speechly::analytics::v1::DecoderInfo* decoder_info_;
    ::google::protobuf::Timestamp* created_time_;
    ::google::protobuf::Timestamp* finished_time_;
    ::speechly::analytics::v1::ProcessingInfo* processing_info_;
    ::int32_t utterance_length_seconds_;
    ::int32_t utterance_length_chars_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class RegisterUtteranceResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.RegisterUtteranceResponse) */ {
 public:
  inline RegisterUtteranceResponse() : RegisterUtteranceResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterUtteranceResponse(::google::protobuf::internal::ConstantInitialized);

  RegisterUtteranceResponse(const RegisterUtteranceResponse& from);
  RegisterUtteranceResponse(RegisterUtteranceResponse&& from) noexcept
    : RegisterUtteranceResponse() {
    *this = ::std::move(from);
  }

  inline RegisterUtteranceResponse& operator=(const RegisterUtteranceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterUtteranceResponse& operator=(RegisterUtteranceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterUtteranceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterUtteranceResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterUtteranceResponse*>(
               &_RegisterUtteranceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RegisterUtteranceResponse& a, RegisterUtteranceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterUtteranceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterUtteranceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterUtteranceResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterUtteranceResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RegisterUtteranceResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RegisterUtteranceResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.RegisterUtteranceResponse";
  }
  protected:
  explicit RegisterUtteranceResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.RegisterUtteranceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class RegisterUtterancesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.RegisterUtterancesRequest) */ {
 public:
  inline RegisterUtterancesRequest() : RegisterUtterancesRequest(nullptr) {}
  ~RegisterUtterancesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterUtterancesRequest(::google::protobuf::internal::ConstantInitialized);

  RegisterUtterancesRequest(const RegisterUtterancesRequest& from);
  RegisterUtterancesRequest(RegisterUtterancesRequest&& from) noexcept
    : RegisterUtterancesRequest() {
    *this = ::std::move(from);
  }

  inline RegisterUtterancesRequest& operator=(const RegisterUtterancesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterUtterancesRequest& operator=(RegisterUtterancesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterUtterancesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterUtterancesRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterUtterancesRequest*>(
               &_RegisterUtterancesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegisterUtterancesRequest& a, RegisterUtterancesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterUtterancesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterUtterancesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterUtterancesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterUtterancesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterUtterancesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RegisterUtterancesRequest& from) {
    RegisterUtterancesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterUtterancesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.RegisterUtterancesRequest";
  }
  protected:
  explicit RegisterUtterancesRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .speechly.analytics.v1.RegisterUtteranceRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;

  public:
  void clear_requests() ;
  ::speechly::analytics::v1::RegisterUtteranceRequest* mutable_requests(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::RegisterUtteranceRequest >*
      mutable_requests();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::RegisterUtteranceRequest>& _internal_requests() const;
  ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::RegisterUtteranceRequest>* _internal_mutable_requests();
  public:
  const ::speechly::analytics::v1::RegisterUtteranceRequest& requests(int index) const;
  ::speechly::analytics::v1::RegisterUtteranceRequest* add_requests();
  const ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::RegisterUtteranceRequest >&
      requests() const;
  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.RegisterUtterancesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::RegisterUtteranceRequest > requests_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class RegisterUtterancesResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.RegisterUtterancesResponse) */ {
 public:
  inline RegisterUtterancesResponse() : RegisterUtterancesResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterUtterancesResponse(::google::protobuf::internal::ConstantInitialized);

  RegisterUtterancesResponse(const RegisterUtterancesResponse& from);
  RegisterUtterancesResponse(RegisterUtterancesResponse&& from) noexcept
    : RegisterUtterancesResponse() {
    *this = ::std::move(from);
  }

  inline RegisterUtterancesResponse& operator=(const RegisterUtterancesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterUtterancesResponse& operator=(RegisterUtterancesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterUtterancesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterUtterancesResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterUtterancesResponse*>(
               &_RegisterUtterancesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegisterUtterancesResponse& a, RegisterUtterancesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterUtterancesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterUtterancesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterUtterancesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterUtterancesResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RegisterUtterancesResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RegisterUtterancesResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.RegisterUtterancesResponse";
  }
  protected:
  explicit RegisterUtterancesResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.RegisterUtterancesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class ModerationStatisticsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.ModerationStatisticsRequest) */ {
 public:
  inline ModerationStatisticsRequest() : ModerationStatisticsRequest(nullptr) {}
  ~ModerationStatisticsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModerationStatisticsRequest(::google::protobuf::internal::ConstantInitialized);

  ModerationStatisticsRequest(const ModerationStatisticsRequest& from);
  ModerationStatisticsRequest(ModerationStatisticsRequest&& from) noexcept
    : ModerationStatisticsRequest() {
    *this = ::std::move(from);
  }

  inline ModerationStatisticsRequest& operator=(const ModerationStatisticsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModerationStatisticsRequest& operator=(ModerationStatisticsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModerationStatisticsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModerationStatisticsRequest* internal_default_instance() {
    return reinterpret_cast<const ModerationStatisticsRequest*>(
               &_ModerationStatisticsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ModerationStatisticsRequest& a, ModerationStatisticsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModerationStatisticsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModerationStatisticsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModerationStatisticsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModerationStatisticsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModerationStatisticsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ModerationStatisticsRequest& from) {
    ModerationStatisticsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModerationStatisticsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.ModerationStatisticsRequest";
  }
  protected:
  explicit ModerationStatisticsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kStartDateFieldNumber = 3,
    kEndDateFieldNumber = 4,
    kAggregationFieldNumber = 5,
  };
  // string project_id = 1;
  void clear_project_id() ;
  const std::string& project_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project_id(Arg_&& arg, Args_... args);
  std::string* mutable_project_id();
  PROTOBUF_NODISCARD std::string* release_project_id();
  void set_allocated_project_id(std::string* ptr);

  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(
      const std::string& value);
  std::string* _internal_mutable_project_id();

  public:
  // string app_id = 2;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string start_date = 3;
  void clear_start_date() ;
  const std::string& start_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_date(Arg_&& arg, Args_... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* ptr);

  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(
      const std::string& value);
  std::string* _internal_mutable_start_date();

  public:
  // string end_date = 4;
  void clear_end_date() ;
  const std::string& end_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_end_date(Arg_&& arg, Args_... args);
  std::string* mutable_end_date();
  PROTOBUF_NODISCARD std::string* release_end_date();
  void set_allocated_end_date(std::string* ptr);

  private:
  const std::string& _internal_end_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_date(
      const std::string& value);
  std::string* _internal_mutable_end_date();

  public:
  // .speechly.analytics.v1.Aggregation aggregation = 5;
  void clear_aggregation() ;
  ::speechly::analytics::v1::Aggregation aggregation() const;
  void set_aggregation(::speechly::analytics::v1::Aggregation value);

  private:
  ::speechly::analytics::v1::Aggregation _internal_aggregation() const;
  void _internal_set_aggregation(::speechly::analytics::v1::Aggregation value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.ModerationStatisticsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 92, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr project_id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr start_date_;
    ::google::protobuf::internal::ArenaStringPtr end_date_;
    int aggregation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class ModerationStatisticsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.ModerationStatisticsResponse) */ {
 public:
  inline ModerationStatisticsResponse() : ModerationStatisticsResponse(nullptr) {}
  ~ModerationStatisticsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModerationStatisticsResponse(::google::protobuf::internal::ConstantInitialized);

  ModerationStatisticsResponse(const ModerationStatisticsResponse& from);
  ModerationStatisticsResponse(ModerationStatisticsResponse&& from) noexcept
    : ModerationStatisticsResponse() {
    *this = ::std::move(from);
  }

  inline ModerationStatisticsResponse& operator=(const ModerationStatisticsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModerationStatisticsResponse& operator=(ModerationStatisticsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModerationStatisticsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModerationStatisticsResponse* internal_default_instance() {
    return reinterpret_cast<const ModerationStatisticsResponse*>(
               &_ModerationStatisticsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModerationStatisticsResponse& a, ModerationStatisticsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModerationStatisticsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModerationStatisticsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModerationStatisticsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModerationStatisticsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModerationStatisticsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ModerationStatisticsResponse& from) {
    ModerationStatisticsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModerationStatisticsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.ModerationStatisticsResponse";
  }
  protected:
  explicit ModerationStatisticsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 6,
    kProjectIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kStartDateFieldNumber = 3,
    kEndDateFieldNumber = 4,
    kAggregationFieldNumber = 5,
    kTotalEventsFieldNumber = 7,
    kTotalFlaggedFieldNumber = 8,
    kTotalNotFlaggedFieldNumber = 9,
  };
  // repeated .speechly.analytics.v1.ModerationStatisticsPeriod items = 6;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::speechly::analytics::v1::ModerationStatisticsPeriod* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::ModerationStatisticsPeriod >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::ModerationStatisticsPeriod>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::ModerationStatisticsPeriod>* _internal_mutable_items();
  public:
  const ::speechly::analytics::v1::ModerationStatisticsPeriod& items(int index) const;
  ::speechly::analytics::v1::ModerationStatisticsPeriod* add_items();
  const ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::ModerationStatisticsPeriod >&
      items() const;
  // string project_id = 1;
  void clear_project_id() ;
  const std::string& project_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project_id(Arg_&& arg, Args_... args);
  std::string* mutable_project_id();
  PROTOBUF_NODISCARD std::string* release_project_id();
  void set_allocated_project_id(std::string* ptr);

  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(
      const std::string& value);
  std::string* _internal_mutable_project_id();

  public:
  // string app_id = 2;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string start_date = 3;
  void clear_start_date() ;
  const std::string& start_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_date(Arg_&& arg, Args_... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* ptr);

  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(
      const std::string& value);
  std::string* _internal_mutable_start_date();

  public:
  // string end_date = 4;
  void clear_end_date() ;
  const std::string& end_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_end_date(Arg_&& arg, Args_... args);
  std::string* mutable_end_date();
  PROTOBUF_NODISCARD std::string* release_end_date();
  void set_allocated_end_date(std::string* ptr);

  private:
  const std::string& _internal_end_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_date(
      const std::string& value);
  std::string* _internal_mutable_end_date();

  public:
  // .speechly.analytics.v1.Aggregation aggregation = 5;
  void clear_aggregation() ;
  ::speechly::analytics::v1::Aggregation aggregation() const;
  void set_aggregation(::speechly::analytics::v1::Aggregation value);

  private:
  ::speechly::analytics::v1::Aggregation _internal_aggregation() const;
  void _internal_set_aggregation(::speechly::analytics::v1::Aggregation value);

  public:
  // int32 total_events = 7;
  void clear_total_events() ;
  ::int32_t total_events() const;
  void set_total_events(::int32_t value);

  private:
  ::int32_t _internal_total_events() const;
  void _internal_set_total_events(::int32_t value);

  public:
  // int32 total_flagged = 8;
  void clear_total_flagged() ;
  ::int32_t total_flagged() const;
  void set_total_flagged(::int32_t value);

  private:
  ::int32_t _internal_total_flagged() const;
  void _internal_set_total_flagged(::int32_t value);

  public:
  // int32 total_not_flagged = 9;
  void clear_total_not_flagged() ;
  ::int32_t total_not_flagged() const;
  void set_total_not_flagged(::int32_t value);

  private:
  ::int32_t _internal_total_not_flagged() const;
  void _internal_set_total_not_flagged(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.ModerationStatisticsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9, 1, 101, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::ModerationStatisticsPeriod > items_;
    ::google::protobuf::internal::ArenaStringPtr project_id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr start_date_;
    ::google::protobuf::internal::ArenaStringPtr end_date_;
    int aggregation_;
    ::int32_t total_events_;
    ::int32_t total_flagged_;
    ::int32_t total_not_flagged_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class UserStatisticsRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.UserStatisticsRequest) */ {
 public:
  inline UserStatisticsRequest() : UserStatisticsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserStatisticsRequest(::google::protobuf::internal::ConstantInitialized);

  UserStatisticsRequest(const UserStatisticsRequest& from);
  UserStatisticsRequest(UserStatisticsRequest&& from) noexcept
    : UserStatisticsRequest() {
    *this = ::std::move(from);
  }

  inline UserStatisticsRequest& operator=(const UserStatisticsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStatisticsRequest& operator=(UserStatisticsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserStatisticsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserStatisticsRequest* internal_default_instance() {
    return reinterpret_cast<const UserStatisticsRequest*>(
               &_UserStatisticsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserStatisticsRequest& a, UserStatisticsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStatisticsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStatisticsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStatisticsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserStatisticsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UserStatisticsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UserStatisticsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.UserStatisticsRequest";
  }
  protected:
  explicit UserStatisticsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.UserStatisticsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};// -------------------------------------------------------------------

class UserStatisticsResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.analytics.v1.UserStatisticsResponse) */ {
 public:
  inline UserStatisticsResponse() : UserStatisticsResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserStatisticsResponse(::google::protobuf::internal::ConstantInitialized);

  UserStatisticsResponse(const UserStatisticsResponse& from);
  UserStatisticsResponse(UserStatisticsResponse&& from) noexcept
    : UserStatisticsResponse() {
    *this = ::std::move(from);
  }

  inline UserStatisticsResponse& operator=(const UserStatisticsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStatisticsResponse& operator=(UserStatisticsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserStatisticsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserStatisticsResponse* internal_default_instance() {
    return reinterpret_cast<const UserStatisticsResponse*>(
               &_UserStatisticsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserStatisticsResponse& a, UserStatisticsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStatisticsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStatisticsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStatisticsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserStatisticsResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UserStatisticsResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UserStatisticsResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.analytics.v1.UserStatisticsResponse";
  }
  protected:
  explicit UserStatisticsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.analytics.v1.UserStatisticsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UtteranceStatisticsRequest

// string app_id = 1;
inline void UtteranceStatisticsRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& UtteranceStatisticsRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UtteranceStatisticsRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsRequest.app_id)
}
inline std::string* UtteranceStatisticsRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.UtteranceStatisticsRequest.app_id)
  return _s;
}
inline const std::string& UtteranceStatisticsRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void UtteranceStatisticsRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.UtteranceStatisticsRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void UtteranceStatisticsRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.UtteranceStatisticsRequest.app_id)
}

// int32 days = 2;
inline void UtteranceStatisticsRequest::clear_days() {
  _impl_.days_ = 0;
}
inline ::int32_t UtteranceStatisticsRequest::days() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsRequest.days)
  return _internal_days();
}
inline void UtteranceStatisticsRequest::set_days(::int32_t value) {
  _internal_set_days(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsRequest.days)
}
inline ::int32_t UtteranceStatisticsRequest::_internal_days() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.days_;
}
inline void UtteranceStatisticsRequest::_internal_set_days(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.days_ = value;
}

// .speechly.analytics.v1.UtteranceStatisticsRequest.Scope scope = 3;
inline void UtteranceStatisticsRequest::clear_scope() {
  _impl_.scope_ = 0;
}
inline ::speechly::analytics::v1::UtteranceStatisticsRequest_Scope UtteranceStatisticsRequest::scope() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsRequest.scope)
  return _internal_scope();
}
inline void UtteranceStatisticsRequest::set_scope(::speechly::analytics::v1::UtteranceStatisticsRequest_Scope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsRequest.scope)
}
inline ::speechly::analytics::v1::UtteranceStatisticsRequest_Scope UtteranceStatisticsRequest::_internal_scope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::analytics::v1::UtteranceStatisticsRequest_Scope>(_impl_.scope_);
}
inline void UtteranceStatisticsRequest::_internal_set_scope(::speechly::analytics::v1::UtteranceStatisticsRequest_Scope value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.scope_ = value;
}

// .speechly.analytics.v1.Aggregation aggregation = 4;
inline void UtteranceStatisticsRequest::clear_aggregation() {
  _impl_.aggregation_ = 0;
}
inline ::speechly::analytics::v1::Aggregation UtteranceStatisticsRequest::aggregation() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsRequest.aggregation)
  return _internal_aggregation();
}
inline void UtteranceStatisticsRequest::set_aggregation(::speechly::analytics::v1::Aggregation value) {
  _internal_set_aggregation(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsRequest.aggregation)
}
inline ::speechly::analytics::v1::Aggregation UtteranceStatisticsRequest::_internal_aggregation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::analytics::v1::Aggregation>(_impl_.aggregation_);
}
inline void UtteranceStatisticsRequest::_internal_set_aggregation(::speechly::analytics::v1::Aggregation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aggregation_ = value;
}

// string start_date = 5;
inline void UtteranceStatisticsRequest::clear_start_date() {
  _impl_.start_date_.ClearToEmpty();
}
inline const std::string& UtteranceStatisticsRequest::start_date() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsRequest.start_date)
  return _internal_start_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UtteranceStatisticsRequest::set_start_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsRequest.start_date)
}
inline std::string* UtteranceStatisticsRequest::mutable_start_date() {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.UtteranceStatisticsRequest.start_date)
  return _s;
}
inline const std::string& UtteranceStatisticsRequest::_internal_start_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_date_.Get();
}
inline void UtteranceStatisticsRequest::_internal_set_start_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_date_.Set(value, GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsRequest::_internal_mutable_start_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.start_date_.Mutable( GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsRequest::release_start_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.UtteranceStatisticsRequest.start_date)
  return _impl_.start_date_.Release();
}
inline void UtteranceStatisticsRequest::set_allocated_start_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_date_.IsDefault()) {
          _impl_.start_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.UtteranceStatisticsRequest.start_date)
}

// string end_date = 6;
inline void UtteranceStatisticsRequest::clear_end_date() {
  _impl_.end_date_.ClearToEmpty();
}
inline const std::string& UtteranceStatisticsRequest::end_date() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsRequest.end_date)
  return _internal_end_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UtteranceStatisticsRequest::set_end_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsRequest.end_date)
}
inline std::string* UtteranceStatisticsRequest::mutable_end_date() {
  std::string* _s = _internal_mutable_end_date();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.UtteranceStatisticsRequest.end_date)
  return _s;
}
inline const std::string& UtteranceStatisticsRequest::_internal_end_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_date_.Get();
}
inline void UtteranceStatisticsRequest::_internal_set_end_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_date_.Set(value, GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsRequest::_internal_mutable_end_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.end_date_.Mutable( GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsRequest::release_end_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.UtteranceStatisticsRequest.end_date)
  return _impl_.end_date_.Release();
}
inline void UtteranceStatisticsRequest::set_allocated_end_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.end_date_.IsDefault()) {
          _impl_.end_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.UtteranceStatisticsRequest.end_date)
}

// string project_id = 7;
inline void UtteranceStatisticsRequest::clear_project_id() {
  _impl_.project_id_.ClearToEmpty();
}
inline const std::string& UtteranceStatisticsRequest::project_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsRequest.project_id)
  return _internal_project_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UtteranceStatisticsRequest::set_project_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsRequest.project_id)
}
inline std::string* UtteranceStatisticsRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.UtteranceStatisticsRequest.project_id)
  return _s;
}
inline const std::string& UtteranceStatisticsRequest::_internal_project_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_id_.Get();
}
inline void UtteranceStatisticsRequest::_internal_set_project_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsRequest::_internal_mutable_project_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_id_.Mutable( GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsRequest::release_project_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.UtteranceStatisticsRequest.project_id)
  return _impl_.project_id_.Release();
}
inline void UtteranceStatisticsRequest::set_allocated_project_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_id_.IsDefault()) {
          _impl_.project_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.UtteranceStatisticsRequest.project_id)
}

// -------------------------------------------------------------------

// UtteranceStatisticsResponse

// string start_date = 1;
inline void UtteranceStatisticsResponse::clear_start_date() {
  _impl_.start_date_.ClearToEmpty();
}
inline const std::string& UtteranceStatisticsResponse::start_date() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsResponse.start_date)
  return _internal_start_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UtteranceStatisticsResponse::set_start_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsResponse.start_date)
}
inline std::string* UtteranceStatisticsResponse::mutable_start_date() {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.UtteranceStatisticsResponse.start_date)
  return _s;
}
inline const std::string& UtteranceStatisticsResponse::_internal_start_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_date_.Get();
}
inline void UtteranceStatisticsResponse::_internal_set_start_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_date_.Set(value, GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsResponse::_internal_mutable_start_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.start_date_.Mutable( GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsResponse::release_start_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.UtteranceStatisticsResponse.start_date)
  return _impl_.start_date_.Release();
}
inline void UtteranceStatisticsResponse::set_allocated_start_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_date_.IsDefault()) {
          _impl_.start_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.UtteranceStatisticsResponse.start_date)
}

// string end_date = 2;
inline void UtteranceStatisticsResponse::clear_end_date() {
  _impl_.end_date_.ClearToEmpty();
}
inline const std::string& UtteranceStatisticsResponse::end_date() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsResponse.end_date)
  return _internal_end_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UtteranceStatisticsResponse::set_end_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsResponse.end_date)
}
inline std::string* UtteranceStatisticsResponse::mutable_end_date() {
  std::string* _s = _internal_mutable_end_date();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.UtteranceStatisticsResponse.end_date)
  return _s;
}
inline const std::string& UtteranceStatisticsResponse::_internal_end_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_date_.Get();
}
inline void UtteranceStatisticsResponse::_internal_set_end_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_date_.Set(value, GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsResponse::_internal_mutable_end_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.end_date_.Mutable( GetArenaForAllocation());
}
inline std::string* UtteranceStatisticsResponse::release_end_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.UtteranceStatisticsResponse.end_date)
  return _impl_.end_date_.Release();
}
inline void UtteranceStatisticsResponse::set_allocated_end_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.end_date_.IsDefault()) {
          _impl_.end_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.UtteranceStatisticsResponse.end_date)
}

// .speechly.analytics.v1.Aggregation aggregation = 3;
inline void UtteranceStatisticsResponse::clear_aggregation() {
  _impl_.aggregation_ = 0;
}
inline ::speechly::analytics::v1::Aggregation UtteranceStatisticsResponse::aggregation() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsResponse.aggregation)
  return _internal_aggregation();
}
inline void UtteranceStatisticsResponse::set_aggregation(::speechly::analytics::v1::Aggregation value) {
  _internal_set_aggregation(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsResponse.aggregation)
}
inline ::speechly::analytics::v1::Aggregation UtteranceStatisticsResponse::_internal_aggregation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::analytics::v1::Aggregation>(_impl_.aggregation_);
}
inline void UtteranceStatisticsResponse::_internal_set_aggregation(::speechly::analytics::v1::Aggregation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aggregation_ = value;
}

// repeated .speechly.analytics.v1.UtteranceStatisticsPeriod items = 4;
inline int UtteranceStatisticsResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int UtteranceStatisticsResponse::items_size() const {
  return _internal_items_size();
}
inline ::speechly::analytics::v1::UtteranceStatisticsPeriod* UtteranceStatisticsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.UtteranceStatisticsResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::UtteranceStatisticsPeriod >*
UtteranceStatisticsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:speechly.analytics.v1.UtteranceStatisticsResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::speechly::analytics::v1::UtteranceStatisticsPeriod& UtteranceStatisticsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsResponse.items)
    return _internal_items().Get(index);
}
inline ::speechly::analytics::v1::UtteranceStatisticsPeriod* UtteranceStatisticsResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::analytics::v1::UtteranceStatisticsPeriod* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:speechly.analytics.v1.UtteranceStatisticsResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::UtteranceStatisticsPeriod >&
UtteranceStatisticsResponse::items() const {
  // @@protoc_insertion_point(field_list:speechly.analytics.v1.UtteranceStatisticsResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::UtteranceStatisticsPeriod>&
UtteranceStatisticsResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::UtteranceStatisticsPeriod>*
UtteranceStatisticsResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// int32 total_utterances = 5;
inline void UtteranceStatisticsResponse::clear_total_utterances() {
  _impl_.total_utterances_ = 0;
}
inline ::int32_t UtteranceStatisticsResponse::total_utterances() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsResponse.total_utterances)
  return _internal_total_utterances();
}
inline void UtteranceStatisticsResponse::set_total_utterances(::int32_t value) {
  _internal_set_total_utterances(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsResponse.total_utterances)
}
inline ::int32_t UtteranceStatisticsResponse::_internal_total_utterances() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_utterances_;
}
inline void UtteranceStatisticsResponse::_internal_set_total_utterances(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_utterances_ = value;
}

// int32 total_duration_seconds = 6;
inline void UtteranceStatisticsResponse::clear_total_duration_seconds() {
  _impl_.total_duration_seconds_ = 0;
}
inline ::int32_t UtteranceStatisticsResponse::total_duration_seconds() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsResponse.total_duration_seconds)
  return _internal_total_duration_seconds();
}
inline void UtteranceStatisticsResponse::set_total_duration_seconds(::int32_t value) {
  _internal_set_total_duration_seconds(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsResponse.total_duration_seconds)
}
inline ::int32_t UtteranceStatisticsResponse::_internal_total_duration_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_duration_seconds_;
}
inline void UtteranceStatisticsResponse::_internal_set_total_duration_seconds(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_duration_seconds_ = value;
}

// int32 total_annotated_seconds = 7;
inline void UtteranceStatisticsResponse::clear_total_annotated_seconds() {
  _impl_.total_annotated_seconds_ = 0;
}
inline ::int32_t UtteranceStatisticsResponse::total_annotated_seconds() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtteranceStatisticsResponse.total_annotated_seconds)
  return _internal_total_annotated_seconds();
}
inline void UtteranceStatisticsResponse::set_total_annotated_seconds(::int32_t value) {
  _internal_set_total_annotated_seconds(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtteranceStatisticsResponse.total_annotated_seconds)
}
inline ::int32_t UtteranceStatisticsResponse::_internal_total_annotated_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_annotated_seconds_;
}
inline void UtteranceStatisticsResponse::_internal_set_total_annotated_seconds(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_annotated_seconds_ = value;
}

// -------------------------------------------------------------------

// UtterancesRequest

// string app_id = 1;
inline void UtterancesRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& UtterancesRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtterancesRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UtterancesRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.UtterancesRequest.app_id)
}
inline std::string* UtterancesRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.UtterancesRequest.app_id)
  return _s;
}
inline const std::string& UtterancesRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void UtterancesRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UtterancesRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* UtterancesRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.UtterancesRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void UtterancesRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.UtterancesRequest.app_id)
}

// -------------------------------------------------------------------

// UtterancesResponse

// repeated .speechly.analytics.v1.Utterance utterances = 1;
inline int UtterancesResponse::_internal_utterances_size() const {
  return _internal_utterances().size();
}
inline int UtterancesResponse::utterances_size() const {
  return _internal_utterances_size();
}
inline ::speechly::analytics::v1::Utterance* UtterancesResponse::mutable_utterances(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.UtterancesResponse.utterances)
  return _internal_mutable_utterances()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::Utterance >*
UtterancesResponse::mutable_utterances() {
  // @@protoc_insertion_point(field_mutable_list:speechly.analytics.v1.UtterancesResponse.utterances)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_utterances();
}
inline const ::speechly::analytics::v1::Utterance& UtterancesResponse::utterances(int index) const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.UtterancesResponse.utterances)
    return _internal_utterances().Get(index);
}
inline ::speechly::analytics::v1::Utterance* UtterancesResponse::add_utterances() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::analytics::v1::Utterance* _add = _internal_mutable_utterances()->Add();
  // @@protoc_insertion_point(field_add:speechly.analytics.v1.UtterancesResponse.utterances)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::Utterance >&
UtterancesResponse::utterances() const {
  // @@protoc_insertion_point(field_list:speechly.analytics.v1.UtterancesResponse.utterances)
  return _internal_utterances();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::Utterance>&
UtterancesResponse::_internal_utterances() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.utterances_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::Utterance>*
UtterancesResponse::_internal_mutable_utterances() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.utterances_;
}

// -------------------------------------------------------------------

// RegisterUtteranceRequest

// string app_id = 1;
inline void RegisterUtteranceRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& RegisterUtteranceRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterUtteranceRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.RegisterUtteranceRequest.app_id)
}
inline std::string* RegisterUtteranceRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.app_id)
  return _s;
}
inline const std::string& RegisterUtteranceRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void RegisterUtteranceRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void RegisterUtteranceRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.app_id)
}

// string device_id = 2;
inline void RegisterUtteranceRequest::clear_device_id() {
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& RegisterUtteranceRequest::device_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.device_id)
  return _internal_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterUtteranceRequest::set_device_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.RegisterUtteranceRequest.device_id)
}
inline std::string* RegisterUtteranceRequest::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.device_id)
  return _s;
}
inline const std::string& RegisterUtteranceRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_.Get();
}
inline void RegisterUtteranceRequest::_internal_set_device_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::_internal_mutable_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::release_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.device_id)
  return _impl_.device_id_.Release();
}
inline void RegisterUtteranceRequest::set_allocated_device_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_id_.IsDefault()) {
          _impl_.device_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.device_id)
}

// int32 utterance_length_seconds = 3;
inline void RegisterUtteranceRequest::clear_utterance_length_seconds() {
  _impl_.utterance_length_seconds_ = 0;
}
inline ::int32_t RegisterUtteranceRequest::utterance_length_seconds() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.utterance_length_seconds)
  return _internal_utterance_length_seconds();
}
inline void RegisterUtteranceRequest::set_utterance_length_seconds(::int32_t value) {
  _internal_set_utterance_length_seconds(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.RegisterUtteranceRequest.utterance_length_seconds)
}
inline ::int32_t RegisterUtteranceRequest::_internal_utterance_length_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.utterance_length_seconds_;
}
inline void RegisterUtteranceRequest::_internal_set_utterance_length_seconds(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.utterance_length_seconds_ = value;
}

// int32 utterance_length_chars = 4;
inline void RegisterUtteranceRequest::clear_utterance_length_chars() {
  _impl_.utterance_length_chars_ = 0;
}
inline ::int32_t RegisterUtteranceRequest::utterance_length_chars() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.utterance_length_chars)
  return _internal_utterance_length_chars();
}
inline void RegisterUtteranceRequest::set_utterance_length_chars(::int32_t value) {
  _internal_set_utterance_length_chars(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.RegisterUtteranceRequest.utterance_length_chars)
}
inline ::int32_t RegisterUtteranceRequest::_internal_utterance_length_chars() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.utterance_length_chars_;
}
inline void RegisterUtteranceRequest::_internal_set_utterance_length_chars(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.utterance_length_chars_ = value;
}

// .speechly.analytics.v1.DecoderInfo decoder_info = 5;
inline bool RegisterUtteranceRequest::has_decoder_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.decoder_info_ != nullptr);
  return value;
}
inline const ::speechly::analytics::v1::DecoderInfo& RegisterUtteranceRequest::_internal_decoder_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::speechly::analytics::v1::DecoderInfo* p = _impl_.decoder_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::analytics::v1::DecoderInfo&>(::speechly::analytics::v1::_DecoderInfo_default_instance_);
}
inline const ::speechly::analytics::v1::DecoderInfo& RegisterUtteranceRequest::decoder_info() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.decoder_info)
  return _internal_decoder_info();
}
inline void RegisterUtteranceRequest::unsafe_arena_set_allocated_decoder_info(::speechly::analytics::v1::DecoderInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.decoder_info_);
  }
  _impl_.decoder_info_ = reinterpret_cast<::speechly::analytics::v1::DecoderInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.decoder_info)
}
inline ::speechly::analytics::v1::DecoderInfo* RegisterUtteranceRequest::release_decoder_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::analytics::v1::DecoderInfo* released = _impl_.decoder_info_;
  _impl_.decoder_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::speechly::analytics::v1::DecoderInfo* RegisterUtteranceRequest::unsafe_arena_release_decoder_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.decoder_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::analytics::v1::DecoderInfo* temp = _impl_.decoder_info_;
  _impl_.decoder_info_ = nullptr;
  return temp;
}
inline ::speechly::analytics::v1::DecoderInfo* RegisterUtteranceRequest::_internal_mutable_decoder_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.decoder_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::analytics::v1::DecoderInfo>(GetArenaForAllocation());
    _impl_.decoder_info_ = reinterpret_cast<::speechly::analytics::v1::DecoderInfo*>(p);
  }
  return _impl_.decoder_info_;
}
inline ::speechly::analytics::v1::DecoderInfo* RegisterUtteranceRequest::mutable_decoder_info() {
  ::speechly::analytics::v1::DecoderInfo* _msg = _internal_mutable_decoder_info();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.decoder_info)
  return _msg;
}
inline void RegisterUtteranceRequest::set_allocated_decoder_info(::speechly::analytics::v1::DecoderInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.decoder_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.decoder_info_ = reinterpret_cast<::speechly::analytics::v1::DecoderInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.decoder_info)
}

// .google.protobuf.Timestamp created_time = 6;
inline bool RegisterUtteranceRequest::has_created_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& RegisterUtteranceRequest::_internal_created_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& RegisterUtteranceRequest::created_time() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.created_time)
  return _internal_created_time();
}
inline void RegisterUtteranceRequest::unsafe_arena_set_allocated_created_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_time_);
  }
  _impl_.created_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.created_time)
}
inline ::google::protobuf::Timestamp* RegisterUtteranceRequest::release_created_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.created_time_;
  _impl_.created_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* RegisterUtteranceRequest::unsafe_arena_release_created_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.created_time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.created_time_;
  _impl_.created_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RegisterUtteranceRequest::_internal_mutable_created_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.created_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.created_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_time_;
}
inline ::google::protobuf::Timestamp* RegisterUtteranceRequest::mutable_created_time() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_time();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.created_time)
  return _msg;
}
inline void RegisterUtteranceRequest::set_allocated_created_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.created_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.created_time)
}

// .google.protobuf.Timestamp finished_time = 7;
inline bool RegisterUtteranceRequest::has_finished_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.finished_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& RegisterUtteranceRequest::_internal_finished_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.finished_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& RegisterUtteranceRequest::finished_time() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.finished_time)
  return _internal_finished_time();
}
inline void RegisterUtteranceRequest::unsafe_arena_set_allocated_finished_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.finished_time_);
  }
  _impl_.finished_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.finished_time)
}
inline ::google::protobuf::Timestamp* RegisterUtteranceRequest::release_finished_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.finished_time_;
  _impl_.finished_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* RegisterUtteranceRequest::unsafe_arena_release_finished_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.finished_time)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.finished_time_;
  _impl_.finished_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RegisterUtteranceRequest::_internal_mutable_finished_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.finished_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.finished_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.finished_time_;
}
inline ::google::protobuf::Timestamp* RegisterUtteranceRequest::mutable_finished_time() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_finished_time();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.finished_time)
  return _msg;
}
inline void RegisterUtteranceRequest::set_allocated_finished_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.finished_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.finished_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.finished_time)
}

// .speechly.analytics.v1.RegisterUtteranceRequest.Status status = 8;
inline void RegisterUtteranceRequest::clear_status() {
  _impl_.status_ = 0;
}
inline ::speechly::analytics::v1::RegisterUtteranceRequest_Status RegisterUtteranceRequest::status() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.status)
  return _internal_status();
}
inline void RegisterUtteranceRequest::set_status(::speechly::analytics::v1::RegisterUtteranceRequest_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.RegisterUtteranceRequest.status)
}
inline ::speechly::analytics::v1::RegisterUtteranceRequest_Status RegisterUtteranceRequest::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::analytics::v1::RegisterUtteranceRequest_Status>(_impl_.status_);
}
inline void RegisterUtteranceRequest::_internal_set_status(::speechly::analytics::v1::RegisterUtteranceRequest_Status value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// string operation_id = 9;
inline void RegisterUtteranceRequest::clear_operation_id() {
  _impl_.operation_id_.ClearToEmpty();
}
inline const std::string& RegisterUtteranceRequest::operation_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.operation_id)
  return _internal_operation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterUtteranceRequest::set_operation_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.RegisterUtteranceRequest.operation_id)
}
inline std::string* RegisterUtteranceRequest::mutable_operation_id() {
  std::string* _s = _internal_mutable_operation_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.operation_id)
  return _s;
}
inline const std::string& RegisterUtteranceRequest::_internal_operation_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.operation_id_.Get();
}
inline void RegisterUtteranceRequest::_internal_set_operation_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::_internal_mutable_operation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.operation_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::release_operation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.operation_id)
  return _impl_.operation_id_.Release();
}
inline void RegisterUtteranceRequest::set_allocated_operation_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operation_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_id_.IsDefault()) {
          _impl_.operation_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.operation_id)
}

// string batch_id = 10;
inline void RegisterUtteranceRequest::clear_batch_id() {
  _impl_.batch_id_.ClearToEmpty();
}
inline const std::string& RegisterUtteranceRequest::batch_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.batch_id)
  return _internal_batch_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterUtteranceRequest::set_batch_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.batch_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.RegisterUtteranceRequest.batch_id)
}
inline std::string* RegisterUtteranceRequest::mutable_batch_id() {
  std::string* _s = _internal_mutable_batch_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.batch_id)
  return _s;
}
inline const std::string& RegisterUtteranceRequest::_internal_batch_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.batch_id_.Get();
}
inline void RegisterUtteranceRequest::_internal_set_batch_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.batch_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::_internal_mutable_batch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.batch_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::release_batch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.batch_id)
  return _impl_.batch_id_.Release();
}
inline void RegisterUtteranceRequest::set_allocated_batch_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.batch_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.batch_id_.IsDefault()) {
          _impl_.batch_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.batch_id)
}

// string project_id = 11;
inline void RegisterUtteranceRequest::clear_project_id() {
  _impl_.project_id_.ClearToEmpty();
}
inline const std::string& RegisterUtteranceRequest::project_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.project_id)
  return _internal_project_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterUtteranceRequest::set_project_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.RegisterUtteranceRequest.project_id)
}
inline std::string* RegisterUtteranceRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.project_id)
  return _s;
}
inline const std::string& RegisterUtteranceRequest::_internal_project_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_id_.Get();
}
inline void RegisterUtteranceRequest::_internal_set_project_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::_internal_mutable_project_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::release_project_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.project_id)
  return _impl_.project_id_.Release();
}
inline void RegisterUtteranceRequest::set_allocated_project_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_id_.IsDefault()) {
          _impl_.project_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.project_id)
}

// string language = 12;
inline void RegisterUtteranceRequest::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& RegisterUtteranceRequest::language() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.language)
  return _internal_language();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterUtteranceRequest::set_language(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.RegisterUtteranceRequest.language)
}
inline std::string* RegisterUtteranceRequest::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.language)
  return _s;
}
inline const std::string& RegisterUtteranceRequest::_internal_language() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_.Get();
}
inline void RegisterUtteranceRequest::_internal_set_language(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::_internal_mutable_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.language_.Mutable( GetArenaForAllocation());
}
inline std::string* RegisterUtteranceRequest::release_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.language)
  return _impl_.language_.Release();
}
inline void RegisterUtteranceRequest::set_allocated_language(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_.IsDefault()) {
          _impl_.language_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.language)
}

// .speechly.analytics.v1.ProcessingInfo processing_info = 13;
inline bool RegisterUtteranceRequest::has_processing_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.processing_info_ != nullptr);
  return value;
}
inline const ::speechly::analytics::v1::ProcessingInfo& RegisterUtteranceRequest::_internal_processing_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::speechly::analytics::v1::ProcessingInfo* p = _impl_.processing_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::analytics::v1::ProcessingInfo&>(::speechly::analytics::v1::_ProcessingInfo_default_instance_);
}
inline const ::speechly::analytics::v1::ProcessingInfo& RegisterUtteranceRequest::processing_info() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtteranceRequest.processing_info)
  return _internal_processing_info();
}
inline void RegisterUtteranceRequest::unsafe_arena_set_allocated_processing_info(::speechly::analytics::v1::ProcessingInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.processing_info_);
  }
  _impl_.processing_info_ = reinterpret_cast<::speechly::analytics::v1::ProcessingInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.processing_info)
}
inline ::speechly::analytics::v1::ProcessingInfo* RegisterUtteranceRequest::release_processing_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::speechly::analytics::v1::ProcessingInfo* released = _impl_.processing_info_;
  _impl_.processing_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::speechly::analytics::v1::ProcessingInfo* RegisterUtteranceRequest::unsafe_arena_release_processing_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.RegisterUtteranceRequest.processing_info)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::speechly::analytics::v1::ProcessingInfo* temp = _impl_.processing_info_;
  _impl_.processing_info_ = nullptr;
  return temp;
}
inline ::speechly::analytics::v1::ProcessingInfo* RegisterUtteranceRequest::_internal_mutable_processing_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.processing_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::analytics::v1::ProcessingInfo>(GetArenaForAllocation());
    _impl_.processing_info_ = reinterpret_cast<::speechly::analytics::v1::ProcessingInfo*>(p);
  }
  return _impl_.processing_info_;
}
inline ::speechly::analytics::v1::ProcessingInfo* RegisterUtteranceRequest::mutable_processing_info() {
  ::speechly::analytics::v1::ProcessingInfo* _msg = _internal_mutable_processing_info();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtteranceRequest.processing_info)
  return _msg;
}
inline void RegisterUtteranceRequest::set_allocated_processing_info(::speechly::analytics::v1::ProcessingInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.processing_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.processing_info_ = reinterpret_cast<::speechly::analytics::v1::ProcessingInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.RegisterUtteranceRequest.processing_info)
}

// -------------------------------------------------------------------

// RegisterUtteranceResponse

// -------------------------------------------------------------------

// RegisterUtterancesRequest

// repeated .speechly.analytics.v1.RegisterUtteranceRequest requests = 1;
inline int RegisterUtterancesRequest::_internal_requests_size() const {
  return _internal_requests().size();
}
inline int RegisterUtterancesRequest::requests_size() const {
  return _internal_requests_size();
}
inline void RegisterUtterancesRequest::clear_requests() {
  _internal_mutable_requests()->Clear();
}
inline ::speechly::analytics::v1::RegisterUtteranceRequest* RegisterUtterancesRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.RegisterUtterancesRequest.requests)
  return _internal_mutable_requests()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::RegisterUtteranceRequest >*
RegisterUtterancesRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:speechly.analytics.v1.RegisterUtterancesRequest.requests)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_requests();
}
inline const ::speechly::analytics::v1::RegisterUtteranceRequest& RegisterUtterancesRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.RegisterUtterancesRequest.requests)
    return _internal_requests().Get(index);
}
inline ::speechly::analytics::v1::RegisterUtteranceRequest* RegisterUtterancesRequest::add_requests() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::analytics::v1::RegisterUtteranceRequest* _add = _internal_mutable_requests()->Add();
  // @@protoc_insertion_point(field_add:speechly.analytics.v1.RegisterUtterancesRequest.requests)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::RegisterUtteranceRequest >&
RegisterUtterancesRequest::requests() const {
  // @@protoc_insertion_point(field_list:speechly.analytics.v1.RegisterUtterancesRequest.requests)
  return _internal_requests();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::RegisterUtteranceRequest>&
RegisterUtterancesRequest::_internal_requests() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requests_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::RegisterUtteranceRequest>*
RegisterUtterancesRequest::_internal_mutable_requests() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.requests_;
}

// -------------------------------------------------------------------

// RegisterUtterancesResponse

// -------------------------------------------------------------------

// ModerationStatisticsRequest

// string project_id = 1;
inline void ModerationStatisticsRequest::clear_project_id() {
  _impl_.project_id_.ClearToEmpty();
}
inline const std::string& ModerationStatisticsRequest::project_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsRequest.project_id)
  return _internal_project_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModerationStatisticsRequest::set_project_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsRequest.project_id)
}
inline std::string* ModerationStatisticsRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.ModerationStatisticsRequest.project_id)
  return _s;
}
inline const std::string& ModerationStatisticsRequest::_internal_project_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_id_.Get();
}
inline void ModerationStatisticsRequest::_internal_set_project_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModerationStatisticsRequest::_internal_mutable_project_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ModerationStatisticsRequest::release_project_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.ModerationStatisticsRequest.project_id)
  return _impl_.project_id_.Release();
}
inline void ModerationStatisticsRequest::set_allocated_project_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_id_.IsDefault()) {
          _impl_.project_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.ModerationStatisticsRequest.project_id)
}

// string app_id = 2;
inline void ModerationStatisticsRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ModerationStatisticsRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModerationStatisticsRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsRequest.app_id)
}
inline std::string* ModerationStatisticsRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.ModerationStatisticsRequest.app_id)
  return _s;
}
inline const std::string& ModerationStatisticsRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void ModerationStatisticsRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModerationStatisticsRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ModerationStatisticsRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.ModerationStatisticsRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void ModerationStatisticsRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.ModerationStatisticsRequest.app_id)
}

// string start_date = 3;
inline void ModerationStatisticsRequest::clear_start_date() {
  _impl_.start_date_.ClearToEmpty();
}
inline const std::string& ModerationStatisticsRequest::start_date() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsRequest.start_date)
  return _internal_start_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModerationStatisticsRequest::set_start_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsRequest.start_date)
}
inline std::string* ModerationStatisticsRequest::mutable_start_date() {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.ModerationStatisticsRequest.start_date)
  return _s;
}
inline const std::string& ModerationStatisticsRequest::_internal_start_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_date_.Get();
}
inline void ModerationStatisticsRequest::_internal_set_start_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_date_.Set(value, GetArenaForAllocation());
}
inline std::string* ModerationStatisticsRequest::_internal_mutable_start_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.start_date_.Mutable( GetArenaForAllocation());
}
inline std::string* ModerationStatisticsRequest::release_start_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.ModerationStatisticsRequest.start_date)
  return _impl_.start_date_.Release();
}
inline void ModerationStatisticsRequest::set_allocated_start_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_date_.IsDefault()) {
          _impl_.start_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.ModerationStatisticsRequest.start_date)
}

// string end_date = 4;
inline void ModerationStatisticsRequest::clear_end_date() {
  _impl_.end_date_.ClearToEmpty();
}
inline const std::string& ModerationStatisticsRequest::end_date() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsRequest.end_date)
  return _internal_end_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModerationStatisticsRequest::set_end_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsRequest.end_date)
}
inline std::string* ModerationStatisticsRequest::mutable_end_date() {
  std::string* _s = _internal_mutable_end_date();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.ModerationStatisticsRequest.end_date)
  return _s;
}
inline const std::string& ModerationStatisticsRequest::_internal_end_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_date_.Get();
}
inline void ModerationStatisticsRequest::_internal_set_end_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_date_.Set(value, GetArenaForAllocation());
}
inline std::string* ModerationStatisticsRequest::_internal_mutable_end_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.end_date_.Mutable( GetArenaForAllocation());
}
inline std::string* ModerationStatisticsRequest::release_end_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.ModerationStatisticsRequest.end_date)
  return _impl_.end_date_.Release();
}
inline void ModerationStatisticsRequest::set_allocated_end_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.end_date_.IsDefault()) {
          _impl_.end_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.ModerationStatisticsRequest.end_date)
}

// .speechly.analytics.v1.Aggregation aggregation = 5;
inline void ModerationStatisticsRequest::clear_aggregation() {
  _impl_.aggregation_ = 0;
}
inline ::speechly::analytics::v1::Aggregation ModerationStatisticsRequest::aggregation() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsRequest.aggregation)
  return _internal_aggregation();
}
inline void ModerationStatisticsRequest::set_aggregation(::speechly::analytics::v1::Aggregation value) {
  _internal_set_aggregation(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsRequest.aggregation)
}
inline ::speechly::analytics::v1::Aggregation ModerationStatisticsRequest::_internal_aggregation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::analytics::v1::Aggregation>(_impl_.aggregation_);
}
inline void ModerationStatisticsRequest::_internal_set_aggregation(::speechly::analytics::v1::Aggregation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aggregation_ = value;
}

// -------------------------------------------------------------------

// ModerationStatisticsResponse

// string project_id = 1;
inline void ModerationStatisticsResponse::clear_project_id() {
  _impl_.project_id_.ClearToEmpty();
}
inline const std::string& ModerationStatisticsResponse::project_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsResponse.project_id)
  return _internal_project_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModerationStatisticsResponse::set_project_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsResponse.project_id)
}
inline std::string* ModerationStatisticsResponse::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.ModerationStatisticsResponse.project_id)
  return _s;
}
inline const std::string& ModerationStatisticsResponse::_internal_project_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_id_.Get();
}
inline void ModerationStatisticsResponse::_internal_set_project_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModerationStatisticsResponse::_internal_mutable_project_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ModerationStatisticsResponse::release_project_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.ModerationStatisticsResponse.project_id)
  return _impl_.project_id_.Release();
}
inline void ModerationStatisticsResponse::set_allocated_project_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_id_.IsDefault()) {
          _impl_.project_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.ModerationStatisticsResponse.project_id)
}

// string app_id = 2;
inline void ModerationStatisticsResponse::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ModerationStatisticsResponse::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsResponse.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModerationStatisticsResponse::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsResponse.app_id)
}
inline std::string* ModerationStatisticsResponse::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.ModerationStatisticsResponse.app_id)
  return _s;
}
inline const std::string& ModerationStatisticsResponse::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void ModerationStatisticsResponse::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModerationStatisticsResponse::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ModerationStatisticsResponse::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.ModerationStatisticsResponse.app_id)
  return _impl_.app_id_.Release();
}
inline void ModerationStatisticsResponse::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.ModerationStatisticsResponse.app_id)
}

// string start_date = 3;
inline void ModerationStatisticsResponse::clear_start_date() {
  _impl_.start_date_.ClearToEmpty();
}
inline const std::string& ModerationStatisticsResponse::start_date() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsResponse.start_date)
  return _internal_start_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModerationStatisticsResponse::set_start_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsResponse.start_date)
}
inline std::string* ModerationStatisticsResponse::mutable_start_date() {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.ModerationStatisticsResponse.start_date)
  return _s;
}
inline const std::string& ModerationStatisticsResponse::_internal_start_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_date_.Get();
}
inline void ModerationStatisticsResponse::_internal_set_start_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_date_.Set(value, GetArenaForAllocation());
}
inline std::string* ModerationStatisticsResponse::_internal_mutable_start_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.start_date_.Mutable( GetArenaForAllocation());
}
inline std::string* ModerationStatisticsResponse::release_start_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.ModerationStatisticsResponse.start_date)
  return _impl_.start_date_.Release();
}
inline void ModerationStatisticsResponse::set_allocated_start_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_date_.IsDefault()) {
          _impl_.start_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.ModerationStatisticsResponse.start_date)
}

// string end_date = 4;
inline void ModerationStatisticsResponse::clear_end_date() {
  _impl_.end_date_.ClearToEmpty();
}
inline const std::string& ModerationStatisticsResponse::end_date() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsResponse.end_date)
  return _internal_end_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModerationStatisticsResponse::set_end_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsResponse.end_date)
}
inline std::string* ModerationStatisticsResponse::mutable_end_date() {
  std::string* _s = _internal_mutable_end_date();
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.ModerationStatisticsResponse.end_date)
  return _s;
}
inline const std::string& ModerationStatisticsResponse::_internal_end_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_date_.Get();
}
inline void ModerationStatisticsResponse::_internal_set_end_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_date_.Set(value, GetArenaForAllocation());
}
inline std::string* ModerationStatisticsResponse::_internal_mutable_end_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.end_date_.Mutable( GetArenaForAllocation());
}
inline std::string* ModerationStatisticsResponse::release_end_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.analytics.v1.ModerationStatisticsResponse.end_date)
  return _impl_.end_date_.Release();
}
inline void ModerationStatisticsResponse::set_allocated_end_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.end_date_.IsDefault()) {
          _impl_.end_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.analytics.v1.ModerationStatisticsResponse.end_date)
}

// .speechly.analytics.v1.Aggregation aggregation = 5;
inline void ModerationStatisticsResponse::clear_aggregation() {
  _impl_.aggregation_ = 0;
}
inline ::speechly::analytics::v1::Aggregation ModerationStatisticsResponse::aggregation() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsResponse.aggregation)
  return _internal_aggregation();
}
inline void ModerationStatisticsResponse::set_aggregation(::speechly::analytics::v1::Aggregation value) {
  _internal_set_aggregation(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsResponse.aggregation)
}
inline ::speechly::analytics::v1::Aggregation ModerationStatisticsResponse::_internal_aggregation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::analytics::v1::Aggregation>(_impl_.aggregation_);
}
inline void ModerationStatisticsResponse::_internal_set_aggregation(::speechly::analytics::v1::Aggregation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aggregation_ = value;
}

// repeated .speechly.analytics.v1.ModerationStatisticsPeriod items = 6;
inline int ModerationStatisticsResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int ModerationStatisticsResponse::items_size() const {
  return _internal_items_size();
}
inline ::speechly::analytics::v1::ModerationStatisticsPeriod* ModerationStatisticsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.analytics.v1.ModerationStatisticsResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::ModerationStatisticsPeriod >*
ModerationStatisticsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:speechly.analytics.v1.ModerationStatisticsResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::speechly::analytics::v1::ModerationStatisticsPeriod& ModerationStatisticsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsResponse.items)
    return _internal_items().Get(index);
}
inline ::speechly::analytics::v1::ModerationStatisticsPeriod* ModerationStatisticsResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::analytics::v1::ModerationStatisticsPeriod* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:speechly.analytics.v1.ModerationStatisticsResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::analytics::v1::ModerationStatisticsPeriod >&
ModerationStatisticsResponse::items() const {
  // @@protoc_insertion_point(field_list:speechly.analytics.v1.ModerationStatisticsResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::ModerationStatisticsPeriod>&
ModerationStatisticsResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::analytics::v1::ModerationStatisticsPeriod>*
ModerationStatisticsResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// int32 total_events = 7;
inline void ModerationStatisticsResponse::clear_total_events() {
  _impl_.total_events_ = 0;
}
inline ::int32_t ModerationStatisticsResponse::total_events() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsResponse.total_events)
  return _internal_total_events();
}
inline void ModerationStatisticsResponse::set_total_events(::int32_t value) {
  _internal_set_total_events(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsResponse.total_events)
}
inline ::int32_t ModerationStatisticsResponse::_internal_total_events() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_events_;
}
inline void ModerationStatisticsResponse::_internal_set_total_events(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_events_ = value;
}

// int32 total_flagged = 8;
inline void ModerationStatisticsResponse::clear_total_flagged() {
  _impl_.total_flagged_ = 0;
}
inline ::int32_t ModerationStatisticsResponse::total_flagged() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsResponse.total_flagged)
  return _internal_total_flagged();
}
inline void ModerationStatisticsResponse::set_total_flagged(::int32_t value) {
  _internal_set_total_flagged(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsResponse.total_flagged)
}
inline ::int32_t ModerationStatisticsResponse::_internal_total_flagged() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_flagged_;
}
inline void ModerationStatisticsResponse::_internal_set_total_flagged(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_flagged_ = value;
}

// int32 total_not_flagged = 9;
inline void ModerationStatisticsResponse::clear_total_not_flagged() {
  _impl_.total_not_flagged_ = 0;
}
inline ::int32_t ModerationStatisticsResponse::total_not_flagged() const {
  // @@protoc_insertion_point(field_get:speechly.analytics.v1.ModerationStatisticsResponse.total_not_flagged)
  return _internal_total_not_flagged();
}
inline void ModerationStatisticsResponse::set_total_not_flagged(::int32_t value) {
  _internal_set_total_not_flagged(value);
  // @@protoc_insertion_point(field_set:speechly.analytics.v1.ModerationStatisticsResponse.total_not_flagged)
}
inline ::int32_t ModerationStatisticsResponse::_internal_total_not_flagged() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_not_flagged_;
}
inline void ModerationStatisticsResponse::_internal_set_total_not_flagged(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_not_flagged_ = value;
}

// -------------------------------------------------------------------

// UserStatisticsRequest

// -------------------------------------------------------------------

// UserStatisticsResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace analytics
}  // namespace speechly


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::speechly::analytics::v1::UtteranceStatisticsRequest_Scope> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::speechly::analytics::v1::UtteranceStatisticsRequest_Scope>() {
  return ::speechly::analytics::v1::UtteranceStatisticsRequest_Scope_descriptor();
}
template <>
struct is_proto_enum<::speechly::analytics::v1::RegisterUtteranceRequest_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::speechly::analytics::v1::RegisterUtteranceRequest_Status>() {
  return ::speechly::analytics::v1::RegisterUtteranceRequest_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_speechly_2fanalytics_2fv1_2fanalytics_5fapi_2eproto_2epb_2eh
