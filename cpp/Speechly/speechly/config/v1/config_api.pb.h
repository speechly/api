// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: speechly/config/v1/config_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[28]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
namespace speechly {
namespace config {
namespace v1 {
class App;
struct AppDefaultTypeInternal;
extern AppDefaultTypeInternal _App_default_instance_;
class CreateAppRequest;
struct CreateAppRequestDefaultTypeInternal;
extern CreateAppRequestDefaultTypeInternal _CreateAppRequest_default_instance_;
class CreateAppResponse;
struct CreateAppResponseDefaultTypeInternal;
extern CreateAppResponseDefaultTypeInternal _CreateAppResponse_default_instance_;
class CreateProjectRequest;
struct CreateProjectRequestDefaultTypeInternal;
extern CreateProjectRequestDefaultTypeInternal _CreateProjectRequest_default_instance_;
class CreateProjectResponse;
struct CreateProjectResponseDefaultTypeInternal;
extern CreateProjectResponseDefaultTypeInternal _CreateProjectResponse_default_instance_;
class DeleteAppRequest;
struct DeleteAppRequestDefaultTypeInternal;
extern DeleteAppRequestDefaultTypeInternal _DeleteAppRequest_default_instance_;
class DeleteAppResponse;
struct DeleteAppResponseDefaultTypeInternal;
extern DeleteAppResponseDefaultTypeInternal _DeleteAppResponse_default_instance_;
class DownloadCurrentTrainingDataRequest;
struct DownloadCurrentTrainingDataRequestDefaultTypeInternal;
extern DownloadCurrentTrainingDataRequestDefaultTypeInternal _DownloadCurrentTrainingDataRequest_default_instance_;
class DownloadCurrentTrainingDataResponse;
struct DownloadCurrentTrainingDataResponseDefaultTypeInternal;
extern DownloadCurrentTrainingDataResponseDefaultTypeInternal _DownloadCurrentTrainingDataResponse_default_instance_;
class GetAppRequest;
struct GetAppRequestDefaultTypeInternal;
extern GetAppRequestDefaultTypeInternal _GetAppRequest_default_instance_;
class GetAppResponse;
struct GetAppResponseDefaultTypeInternal;
extern GetAppResponseDefaultTypeInternal _GetAppResponse_default_instance_;
class GetProjectParticipantsRequest;
struct GetProjectParticipantsRequestDefaultTypeInternal;
extern GetProjectParticipantsRequestDefaultTypeInternal _GetProjectParticipantsRequest_default_instance_;
class GetProjectParticipantsResponse;
struct GetProjectParticipantsResponseDefaultTypeInternal;
extern GetProjectParticipantsResponseDefaultTypeInternal _GetProjectParticipantsResponse_default_instance_;
class GetProjectParticipantsResponse_Participant;
struct GetProjectParticipantsResponse_ParticipantDefaultTypeInternal;
extern GetProjectParticipantsResponse_ParticipantDefaultTypeInternal _GetProjectParticipantsResponse_Participant_default_instance_;
class GetProjectRequest;
struct GetProjectRequestDefaultTypeInternal;
extern GetProjectRequestDefaultTypeInternal _GetProjectRequest_default_instance_;
class GetProjectResponse;
struct GetProjectResponseDefaultTypeInternal;
extern GetProjectResponseDefaultTypeInternal _GetProjectResponse_default_instance_;
class InviteRequest;
struct InviteRequestDefaultTypeInternal;
extern InviteRequestDefaultTypeInternal _InviteRequest_default_instance_;
class InviteResponse;
struct InviteResponseDefaultTypeInternal;
extern InviteResponseDefaultTypeInternal _InviteResponse_default_instance_;
class JoinProjectRequest;
struct JoinProjectRequestDefaultTypeInternal;
extern JoinProjectRequestDefaultTypeInternal _JoinProjectRequest_default_instance_;
class JoinProjectResponse;
struct JoinProjectResponseDefaultTypeInternal;
extern JoinProjectResponseDefaultTypeInternal _JoinProjectResponse_default_instance_;
class ListAppsRequest;
struct ListAppsRequestDefaultTypeInternal;
extern ListAppsRequestDefaultTypeInternal _ListAppsRequest_default_instance_;
class ListAppsResponse;
struct ListAppsResponseDefaultTypeInternal;
extern ListAppsResponseDefaultTypeInternal _ListAppsResponse_default_instance_;
class UpdateAppRequest;
struct UpdateAppRequestDefaultTypeInternal;
extern UpdateAppRequestDefaultTypeInternal _UpdateAppRequest_default_instance_;
class UpdateAppResponse;
struct UpdateAppResponseDefaultTypeInternal;
extern UpdateAppResponseDefaultTypeInternal _UpdateAppResponse_default_instance_;
class UpdateProjectRequest;
struct UpdateProjectRequestDefaultTypeInternal;
extern UpdateProjectRequestDefaultTypeInternal _UpdateProjectRequest_default_instance_;
class UpdateProjectResponse;
struct UpdateProjectResponseDefaultTypeInternal;
extern UpdateProjectResponseDefaultTypeInternal _UpdateProjectResponse_default_instance_;
class UploadTrainingDataRequest;
struct UploadTrainingDataRequestDefaultTypeInternal;
extern UploadTrainingDataRequestDefaultTypeInternal _UploadTrainingDataRequest_default_instance_;
class UploadTrainingDataResponse;
struct UploadTrainingDataResponseDefaultTypeInternal;
extern UploadTrainingDataResponseDefaultTypeInternal _UploadTrainingDataResponse_default_instance_;
}  // namespace v1
}  // namespace config
}  // namespace speechly
PROTOBUF_NAMESPACE_OPEN
template<> ::speechly::config::v1::App* Arena::CreateMaybeMessage<::speechly::config::v1::App>(Arena*);
template<> ::speechly::config::v1::CreateAppRequest* Arena::CreateMaybeMessage<::speechly::config::v1::CreateAppRequest>(Arena*);
template<> ::speechly::config::v1::CreateAppResponse* Arena::CreateMaybeMessage<::speechly::config::v1::CreateAppResponse>(Arena*);
template<> ::speechly::config::v1::CreateProjectRequest* Arena::CreateMaybeMessage<::speechly::config::v1::CreateProjectRequest>(Arena*);
template<> ::speechly::config::v1::CreateProjectResponse* Arena::CreateMaybeMessage<::speechly::config::v1::CreateProjectResponse>(Arena*);
template<> ::speechly::config::v1::DeleteAppRequest* Arena::CreateMaybeMessage<::speechly::config::v1::DeleteAppRequest>(Arena*);
template<> ::speechly::config::v1::DeleteAppResponse* Arena::CreateMaybeMessage<::speechly::config::v1::DeleteAppResponse>(Arena*);
template<> ::speechly::config::v1::DownloadCurrentTrainingDataRequest* Arena::CreateMaybeMessage<::speechly::config::v1::DownloadCurrentTrainingDataRequest>(Arena*);
template<> ::speechly::config::v1::DownloadCurrentTrainingDataResponse* Arena::CreateMaybeMessage<::speechly::config::v1::DownloadCurrentTrainingDataResponse>(Arena*);
template<> ::speechly::config::v1::GetAppRequest* Arena::CreateMaybeMessage<::speechly::config::v1::GetAppRequest>(Arena*);
template<> ::speechly::config::v1::GetAppResponse* Arena::CreateMaybeMessage<::speechly::config::v1::GetAppResponse>(Arena*);
template<> ::speechly::config::v1::GetProjectParticipantsRequest* Arena::CreateMaybeMessage<::speechly::config::v1::GetProjectParticipantsRequest>(Arena*);
template<> ::speechly::config::v1::GetProjectParticipantsResponse* Arena::CreateMaybeMessage<::speechly::config::v1::GetProjectParticipantsResponse>(Arena*);
template<> ::speechly::config::v1::GetProjectParticipantsResponse_Participant* Arena::CreateMaybeMessage<::speechly::config::v1::GetProjectParticipantsResponse_Participant>(Arena*);
template<> ::speechly::config::v1::GetProjectRequest* Arena::CreateMaybeMessage<::speechly::config::v1::GetProjectRequest>(Arena*);
template<> ::speechly::config::v1::GetProjectResponse* Arena::CreateMaybeMessage<::speechly::config::v1::GetProjectResponse>(Arena*);
template<> ::speechly::config::v1::InviteRequest* Arena::CreateMaybeMessage<::speechly::config::v1::InviteRequest>(Arena*);
template<> ::speechly::config::v1::InviteResponse* Arena::CreateMaybeMessage<::speechly::config::v1::InviteResponse>(Arena*);
template<> ::speechly::config::v1::JoinProjectRequest* Arena::CreateMaybeMessage<::speechly::config::v1::JoinProjectRequest>(Arena*);
template<> ::speechly::config::v1::JoinProjectResponse* Arena::CreateMaybeMessage<::speechly::config::v1::JoinProjectResponse>(Arena*);
template<> ::speechly::config::v1::ListAppsRequest* Arena::CreateMaybeMessage<::speechly::config::v1::ListAppsRequest>(Arena*);
template<> ::speechly::config::v1::ListAppsResponse* Arena::CreateMaybeMessage<::speechly::config::v1::ListAppsResponse>(Arena*);
template<> ::speechly::config::v1::UpdateAppRequest* Arena::CreateMaybeMessage<::speechly::config::v1::UpdateAppRequest>(Arena*);
template<> ::speechly::config::v1::UpdateAppResponse* Arena::CreateMaybeMessage<::speechly::config::v1::UpdateAppResponse>(Arena*);
template<> ::speechly::config::v1::UpdateProjectRequest* Arena::CreateMaybeMessage<::speechly::config::v1::UpdateProjectRequest>(Arena*);
template<> ::speechly::config::v1::UpdateProjectResponse* Arena::CreateMaybeMessage<::speechly::config::v1::UpdateProjectResponse>(Arena*);
template<> ::speechly::config::v1::UploadTrainingDataRequest* Arena::CreateMaybeMessage<::speechly::config::v1::UploadTrainingDataRequest>(Arena*);
template<> ::speechly::config::v1::UploadTrainingDataResponse* Arena::CreateMaybeMessage<::speechly::config::v1::UploadTrainingDataResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace speechly {
namespace config {
namespace v1 {

enum UploadTrainingDataRequest_ContentType : int {
  UploadTrainingDataRequest_ContentType_CONTENT_TYPE_UNSPECIFIED = 0,
  UploadTrainingDataRequest_ContentType_CONTENT_TYPE_YAML = 1,
  UploadTrainingDataRequest_ContentType_CONTENT_TYPE_TAR = 2,
  UploadTrainingDataRequest_ContentType_UploadTrainingDataRequest_ContentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UploadTrainingDataRequest_ContentType_UploadTrainingDataRequest_ContentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UploadTrainingDataRequest_ContentType_IsValid(int value);
constexpr UploadTrainingDataRequest_ContentType UploadTrainingDataRequest_ContentType_ContentType_MIN = UploadTrainingDataRequest_ContentType_CONTENT_TYPE_UNSPECIFIED;
constexpr UploadTrainingDataRequest_ContentType UploadTrainingDataRequest_ContentType_ContentType_MAX = UploadTrainingDataRequest_ContentType_CONTENT_TYPE_TAR;
constexpr int UploadTrainingDataRequest_ContentType_ContentType_ARRAYSIZE = UploadTrainingDataRequest_ContentType_ContentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UploadTrainingDataRequest_ContentType_descriptor();
template<typename T>
inline const std::string& UploadTrainingDataRequest_ContentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UploadTrainingDataRequest_ContentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UploadTrainingDataRequest_ContentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UploadTrainingDataRequest_ContentType_descriptor(), enum_t_value);
}
inline bool UploadTrainingDataRequest_ContentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UploadTrainingDataRequest_ContentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UploadTrainingDataRequest_ContentType>(
    UploadTrainingDataRequest_ContentType_descriptor(), name, value);
}
enum DownloadCurrentTrainingDataResponse_ContentType : int {
  DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_UNSPECIFIED = 0,
  DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_YAML = 1,
  DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_TAR = 2,
  DownloadCurrentTrainingDataResponse_ContentType_DownloadCurrentTrainingDataResponse_ContentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DownloadCurrentTrainingDataResponse_ContentType_DownloadCurrentTrainingDataResponse_ContentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DownloadCurrentTrainingDataResponse_ContentType_IsValid(int value);
constexpr DownloadCurrentTrainingDataResponse_ContentType DownloadCurrentTrainingDataResponse_ContentType_ContentType_MIN = DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_UNSPECIFIED;
constexpr DownloadCurrentTrainingDataResponse_ContentType DownloadCurrentTrainingDataResponse_ContentType_ContentType_MAX = DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_TAR;
constexpr int DownloadCurrentTrainingDataResponse_ContentType_ContentType_ARRAYSIZE = DownloadCurrentTrainingDataResponse_ContentType_ContentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownloadCurrentTrainingDataResponse_ContentType_descriptor();
template<typename T>
inline const std::string& DownloadCurrentTrainingDataResponse_ContentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DownloadCurrentTrainingDataResponse_ContentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DownloadCurrentTrainingDataResponse_ContentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DownloadCurrentTrainingDataResponse_ContentType_descriptor(), enum_t_value);
}
inline bool DownloadCurrentTrainingDataResponse_ContentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadCurrentTrainingDataResponse_ContentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DownloadCurrentTrainingDataResponse_ContentType>(
    DownloadCurrentTrainingDataResponse_ContentType_descriptor(), name, value);
}
enum App_Status : int {
  App_Status_STATUS_UNSPECIFIED = 0,
  App_Status_STATUS_NEW = 1,
  App_Status_STATUS_TRAINING = 2,
  App_Status_STATUS_TRAINED = 3,
  App_Status_STATUS_FAILED = 4,
  App_Status_App_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  App_Status_App_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool App_Status_IsValid(int value);
constexpr App_Status App_Status_Status_MIN = App_Status_STATUS_UNSPECIFIED;
constexpr App_Status App_Status_Status_MAX = App_Status_STATUS_FAILED;
constexpr int App_Status_Status_ARRAYSIZE = App_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* App_Status_descriptor();
template<typename T>
inline const std::string& App_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, App_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function App_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    App_Status_descriptor(), enum_t_value);
}
inline bool App_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, App_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<App_Status>(
    App_Status_descriptor(), name, value);
}
// ===================================================================

class GetProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectRequest) */ {
 public:
  inline GetProjectRequest() : GetProjectRequest(nullptr) {}
  ~GetProjectRequest() override;
  explicit constexpr GetProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProjectRequest(const GetProjectRequest& from);
  GetProjectRequest(GetProjectRequest&& from) noexcept
    : GetProjectRequest() {
    *this = ::std::move(from);
  }

  inline GetProjectRequest& operator=(const GetProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectRequest& operator=(GetProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectRequest* internal_default_instance() {
    return reinterpret_cast<const GetProjectRequest*>(
               &_GetProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetProjectRequest& a, GetProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProjectRequest* New() const final {
    return new GetProjectRequest();
  }

  GetProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.GetProjectRequest";
  }
  protected:
  explicit GetProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectResponse) */ {
 public:
  inline GetProjectResponse() : GetProjectResponse(nullptr) {}
  ~GetProjectResponse() override;
  explicit constexpr GetProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProjectResponse(const GetProjectResponse& from);
  GetProjectResponse(GetProjectResponse&& from) noexcept
    : GetProjectResponse() {
    *this = ::std::move(from);
  }

  inline GetProjectResponse& operator=(const GetProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectResponse& operator=(GetProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectResponse* internal_default_instance() {
    return reinterpret_cast<const GetProjectResponse*>(
               &_GetProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetProjectResponse& a, GetProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProjectResponse* New() const final {
    return new GetProjectResponse();
  }

  GetProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.GetProjectResponse";
  }
  protected:
  explicit GetProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kProjectNamesFieldNumber = 2,
  };
  // repeated string project = 1;
  int project_size() const;
  private:
  int _internal_project_size() const;
  public:
  void clear_project();
  const std::string& project(int index) const;
  std::string* mutable_project(int index);
  void set_project(int index, const std::string& value);
  void set_project(int index, std::string&& value);
  void set_project(int index, const char* value);
  void set_project(int index, const char* value, size_t size);
  std::string* add_project();
  void add_project(const std::string& value);
  void add_project(std::string&& value);
  void add_project(const char* value);
  void add_project(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& project() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_project();
  private:
  const std::string& _internal_project(int index) const;
  std::string* _internal_add_project();
  public:

  // repeated string project_names = 2;
  int project_names_size() const;
  private:
  int _internal_project_names_size() const;
  public:
  void clear_project_names();
  const std::string& project_names(int index) const;
  std::string* mutable_project_names(int index);
  void set_project_names(int index, const std::string& value);
  void set_project_names(int index, std::string&& value);
  void set_project_names(int index, const char* value);
  void set_project_names(int index, const char* value, size_t size);
  std::string* add_project_names();
  void add_project_names(const std::string& value);
  void add_project_names(std::string&& value);
  void add_project_names(const char* value);
  void add_project_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& project_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_project_names();
  private:
  const std::string& _internal_project_names(int index) const;
  std::string* _internal_add_project_names();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> project_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> project_names_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.CreateProjectRequest) */ {
 public:
  inline CreateProjectRequest() : CreateProjectRequest(nullptr) {}
  ~CreateProjectRequest() override;
  explicit constexpr CreateProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateProjectRequest(const CreateProjectRequest& from);
  CreateProjectRequest(CreateProjectRequest&& from) noexcept
    : CreateProjectRequest() {
    *this = ::std::move(from);
  }

  inline CreateProjectRequest& operator=(const CreateProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProjectRequest& operator=(CreateProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProjectRequest* internal_default_instance() {
    return reinterpret_cast<const CreateProjectRequest*>(
               &_CreateProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateProjectRequest& a, CreateProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateProjectRequest* New() const final {
    return new CreateProjectRequest();
  }

  CreateProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.CreateProjectRequest";
  }
  protected:
  explicit CreateProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.CreateProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.CreateProjectResponse) */ {
 public:
  inline CreateProjectResponse() : CreateProjectResponse(nullptr) {}
  ~CreateProjectResponse() override;
  explicit constexpr CreateProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateProjectResponse(const CreateProjectResponse& from);
  CreateProjectResponse(CreateProjectResponse&& from) noexcept
    : CreateProjectResponse() {
    *this = ::std::move(from);
  }

  inline CreateProjectResponse& operator=(const CreateProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProjectResponse& operator=(CreateProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProjectResponse* internal_default_instance() {
    return reinterpret_cast<const CreateProjectResponse*>(
               &_CreateProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateProjectResponse& a, CreateProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateProjectResponse* New() const final {
    return new CreateProjectResponse();
  }

  CreateProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.CreateProjectResponse";
  }
  protected:
  explicit CreateProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string project = 1;
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_MUST_USE_RESULT std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.CreateProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.UpdateProjectRequest) */ {
 public:
  inline UpdateProjectRequest() : UpdateProjectRequest(nullptr) {}
  ~UpdateProjectRequest() override;
  explicit constexpr UpdateProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateProjectRequest(const UpdateProjectRequest& from);
  UpdateProjectRequest(UpdateProjectRequest&& from) noexcept
    : UpdateProjectRequest() {
    *this = ::std::move(from);
  }

  inline UpdateProjectRequest& operator=(const UpdateProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateProjectRequest& operator=(UpdateProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateProjectRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateProjectRequest*>(
               &_UpdateProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpdateProjectRequest& a, UpdateProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateProjectRequest* New() const final {
    return new UpdateProjectRequest();
  }

  UpdateProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.UpdateProjectRequest";
  }
  protected:
  explicit UpdateProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string project = 1;
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_MUST_USE_RESULT std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.UpdateProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.UpdateProjectResponse) */ {
 public:
  inline UpdateProjectResponse() : UpdateProjectResponse(nullptr) {}
  ~UpdateProjectResponse() override;
  explicit constexpr UpdateProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateProjectResponse(const UpdateProjectResponse& from);
  UpdateProjectResponse(UpdateProjectResponse&& from) noexcept
    : UpdateProjectResponse() {
    *this = ::std::move(from);
  }

  inline UpdateProjectResponse& operator=(const UpdateProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateProjectResponse& operator=(UpdateProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateProjectResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateProjectResponse*>(
               &_UpdateProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateProjectResponse& a, UpdateProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateProjectResponse* New() const final {
    return new UpdateProjectResponse();
  }

  UpdateProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.UpdateProjectResponse";
  }
  protected:
  explicit UpdateProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.UpdateProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProjectParticipantsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectParticipantsRequest) */ {
 public:
  inline GetProjectParticipantsRequest() : GetProjectParticipantsRequest(nullptr) {}
  ~GetProjectParticipantsRequest() override;
  explicit constexpr GetProjectParticipantsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProjectParticipantsRequest(const GetProjectParticipantsRequest& from);
  GetProjectParticipantsRequest(GetProjectParticipantsRequest&& from) noexcept
    : GetProjectParticipantsRequest() {
    *this = ::std::move(from);
  }

  inline GetProjectParticipantsRequest& operator=(const GetProjectParticipantsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectParticipantsRequest& operator=(GetProjectParticipantsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectParticipantsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectParticipantsRequest* internal_default_instance() {
    return reinterpret_cast<const GetProjectParticipantsRequest*>(
               &_GetProjectParticipantsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetProjectParticipantsRequest& a, GetProjectParticipantsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectParticipantsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectParticipantsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProjectParticipantsRequest* New() const final {
    return new GetProjectParticipantsRequest();
  }

  GetProjectParticipantsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProjectParticipantsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProjectParticipantsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProjectParticipantsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectParticipantsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.GetProjectParticipantsRequest";
  }
  protected:
  explicit GetProjectParticipantsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
  };
  // string project = 1;
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_MUST_USE_RESULT std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectParticipantsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProjectParticipantsResponse_Participant final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectParticipantsResponse.Participant) */ {
 public:
  inline GetProjectParticipantsResponse_Participant() : GetProjectParticipantsResponse_Participant(nullptr) {}
  ~GetProjectParticipantsResponse_Participant() override;
  explicit constexpr GetProjectParticipantsResponse_Participant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProjectParticipantsResponse_Participant(const GetProjectParticipantsResponse_Participant& from);
  GetProjectParticipantsResponse_Participant(GetProjectParticipantsResponse_Participant&& from) noexcept
    : GetProjectParticipantsResponse_Participant() {
    *this = ::std::move(from);
  }

  inline GetProjectParticipantsResponse_Participant& operator=(const GetProjectParticipantsResponse_Participant& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectParticipantsResponse_Participant& operator=(GetProjectParticipantsResponse_Participant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectParticipantsResponse_Participant& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectParticipantsResponse_Participant* internal_default_instance() {
    return reinterpret_cast<const GetProjectParticipantsResponse_Participant*>(
               &_GetProjectParticipantsResponse_Participant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetProjectParticipantsResponse_Participant& a, GetProjectParticipantsResponse_Participant& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectParticipantsResponse_Participant* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectParticipantsResponse_Participant* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProjectParticipantsResponse_Participant* New() const final {
    return new GetProjectParticipantsResponse_Participant();
  }

  GetProjectParticipantsResponse_Participant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProjectParticipantsResponse_Participant>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProjectParticipantsResponse_Participant& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProjectParticipantsResponse_Participant& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectParticipantsResponse_Participant* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.GetProjectParticipantsResponse.Participant";
  }
  protected:
  explicit GetProjectParticipantsResponse_Participant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEmailFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_MUST_USE_RESULT std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectParticipantsResponse.Participant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProjectParticipantsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectParticipantsResponse) */ {
 public:
  inline GetProjectParticipantsResponse() : GetProjectParticipantsResponse(nullptr) {}
  ~GetProjectParticipantsResponse() override;
  explicit constexpr GetProjectParticipantsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProjectParticipantsResponse(const GetProjectParticipantsResponse& from);
  GetProjectParticipantsResponse(GetProjectParticipantsResponse&& from) noexcept
    : GetProjectParticipantsResponse() {
    *this = ::std::move(from);
  }

  inline GetProjectParticipantsResponse& operator=(const GetProjectParticipantsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectParticipantsResponse& operator=(GetProjectParticipantsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectParticipantsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectParticipantsResponse* internal_default_instance() {
    return reinterpret_cast<const GetProjectParticipantsResponse*>(
               &_GetProjectParticipantsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetProjectParticipantsResponse& a, GetProjectParticipantsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectParticipantsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectParticipantsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProjectParticipantsResponse* New() const final {
    return new GetProjectParticipantsResponse();
  }

  GetProjectParticipantsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProjectParticipantsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProjectParticipantsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProjectParticipantsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectParticipantsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.GetProjectParticipantsResponse";
  }
  protected:
  explicit GetProjectParticipantsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetProjectParticipantsResponse_Participant Participant;

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantsFieldNumber = 1,
  };
  // repeated .speechly.config.v1.GetProjectParticipantsResponse.Participant participants = 1;
  int participants_size() const;
  private:
  int _internal_participants_size() const;
  public:
  void clear_participants();
  ::speechly::config::v1::GetProjectParticipantsResponse_Participant* mutable_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant >*
      mutable_participants();
  private:
  const ::speechly::config::v1::GetProjectParticipantsResponse_Participant& _internal_participants(int index) const;
  ::speechly::config::v1::GetProjectParticipantsResponse_Participant* _internal_add_participants();
  public:
  const ::speechly::config::v1::GetProjectParticipantsResponse_Participant& participants(int index) const;
  ::speechly::config::v1::GetProjectParticipantsResponse_Participant* add_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant >&
      participants() const;

  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectParticipantsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant > participants_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class InviteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.InviteRequest) */ {
 public:
  inline InviteRequest() : InviteRequest(nullptr) {}
  ~InviteRequest() override;
  explicit constexpr InviteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InviteRequest(const InviteRequest& from);
  InviteRequest(InviteRequest&& from) noexcept
    : InviteRequest() {
    *this = ::std::move(from);
  }

  inline InviteRequest& operator=(const InviteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InviteRequest& operator=(InviteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InviteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InviteRequest* internal_default_instance() {
    return reinterpret_cast<const InviteRequest*>(
               &_InviteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InviteRequest& a, InviteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InviteRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InviteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InviteRequest* New() const final {
    return new InviteRequest();
  }

  InviteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InviteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InviteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InviteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InviteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.InviteRequest";
  }
  protected:
  explicit InviteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
  };
  // string project = 1;
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_MUST_USE_RESULT std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.InviteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class InviteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.InviteResponse) */ {
 public:
  inline InviteResponse() : InviteResponse(nullptr) {}
  ~InviteResponse() override;
  explicit constexpr InviteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InviteResponse(const InviteResponse& from);
  InviteResponse(InviteResponse&& from) noexcept
    : InviteResponse() {
    *this = ::std::move(from);
  }

  inline InviteResponse& operator=(const InviteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InviteResponse& operator=(InviteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InviteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InviteResponse* internal_default_instance() {
    return reinterpret_cast<const InviteResponse*>(
               &_InviteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InviteResponse& a, InviteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InviteResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InviteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InviteResponse* New() const final {
    return new InviteResponse();
  }

  InviteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InviteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InviteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InviteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InviteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.InviteResponse";
  }
  protected:
  explicit InviteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvitationTokenFieldNumber = 1,
  };
  // string invitation_token = 1;
  void clear_invitation_token();
  const std::string& invitation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invitation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invitation_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_invitation_token();
  void set_allocated_invitation_token(std::string* invitation_token);
  private:
  const std::string& _internal_invitation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitation_token(const std::string& value);
  std::string* _internal_mutable_invitation_token();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.InviteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invitation_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class JoinProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.JoinProjectRequest) */ {
 public:
  inline JoinProjectRequest() : JoinProjectRequest(nullptr) {}
  ~JoinProjectRequest() override;
  explicit constexpr JoinProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinProjectRequest(const JoinProjectRequest& from);
  JoinProjectRequest(JoinProjectRequest&& from) noexcept
    : JoinProjectRequest() {
    *this = ::std::move(from);
  }

  inline JoinProjectRequest& operator=(const JoinProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinProjectRequest& operator=(JoinProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinProjectRequest* internal_default_instance() {
    return reinterpret_cast<const JoinProjectRequest*>(
               &_JoinProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(JoinProjectRequest& a, JoinProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoinProjectRequest* New() const final {
    return new JoinProjectRequest();
  }

  JoinProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoinProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.JoinProjectRequest";
  }
  protected:
  explicit JoinProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvitationTokenFieldNumber = 1,
  };
  // string invitation_token = 1;
  void clear_invitation_token();
  const std::string& invitation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invitation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invitation_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_invitation_token();
  void set_allocated_invitation_token(std::string* invitation_token);
  private:
  const std::string& _internal_invitation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitation_token(const std::string& value);
  std::string* _internal_mutable_invitation_token();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.JoinProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invitation_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class JoinProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.JoinProjectResponse) */ {
 public:
  inline JoinProjectResponse() : JoinProjectResponse(nullptr) {}
  ~JoinProjectResponse() override;
  explicit constexpr JoinProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinProjectResponse(const JoinProjectResponse& from);
  JoinProjectResponse(JoinProjectResponse&& from) noexcept
    : JoinProjectResponse() {
    *this = ::std::move(from);
  }

  inline JoinProjectResponse& operator=(const JoinProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinProjectResponse& operator=(JoinProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinProjectResponse* internal_default_instance() {
    return reinterpret_cast<const JoinProjectResponse*>(
               &_JoinProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(JoinProjectResponse& a, JoinProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoinProjectResponse* New() const final {
    return new JoinProjectResponse();
  }

  JoinProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoinProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.JoinProjectResponse";
  }
  protected:
  explicit JoinProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.JoinProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListAppsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.ListAppsRequest) */ {
 public:
  inline ListAppsRequest() : ListAppsRequest(nullptr) {}
  ~ListAppsRequest() override;
  explicit constexpr ListAppsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAppsRequest(const ListAppsRequest& from);
  ListAppsRequest(ListAppsRequest&& from) noexcept
    : ListAppsRequest() {
    *this = ::std::move(from);
  }

  inline ListAppsRequest& operator=(const ListAppsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsRequest& operator=(ListAppsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsRequest* internal_default_instance() {
    return reinterpret_cast<const ListAppsRequest*>(
               &_ListAppsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListAppsRequest& a, ListAppsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAppsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListAppsRequest* New() const final {
    return new ListAppsRequest();
  }

  ListAppsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListAppsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAppsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListAppsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAppsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.ListAppsRequest";
  }
  protected:
  explicit ListAppsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
  };
  // string project = 1;
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_MUST_USE_RESULT std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.ListAppsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListAppsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.ListAppsResponse) */ {
 public:
  inline ListAppsResponse() : ListAppsResponse(nullptr) {}
  ~ListAppsResponse() override;
  explicit constexpr ListAppsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAppsResponse(const ListAppsResponse& from);
  ListAppsResponse(ListAppsResponse&& from) noexcept
    : ListAppsResponse() {
    *this = ::std::move(from);
  }

  inline ListAppsResponse& operator=(const ListAppsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsResponse& operator=(ListAppsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAppsResponse*>(
               &_ListAppsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListAppsResponse& a, ListAppsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAppsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListAppsResponse* New() const final {
    return new ListAppsResponse();
  }

  ListAppsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListAppsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAppsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListAppsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAppsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.ListAppsResponse";
  }
  protected:
  explicit ListAppsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppsFieldNumber = 1,
  };
  // repeated .speechly.config.v1.App apps = 1;
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::speechly::config::v1::App* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::App >*
      mutable_apps();
  private:
  const ::speechly::config::v1::App& _internal_apps(int index) const;
  ::speechly::config::v1::App* _internal_add_apps();
  public:
  const ::speechly::config::v1::App& apps(int index) const;
  ::speechly::config::v1::App* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::App >&
      apps() const;

  // @@protoc_insertion_point(class_scope:speechly.config.v1.ListAppsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::App > apps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetAppRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetAppRequest) */ {
 public:
  inline GetAppRequest() : GetAppRequest(nullptr) {}
  ~GetAppRequest() override;
  explicit constexpr GetAppRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAppRequest(const GetAppRequest& from);
  GetAppRequest(GetAppRequest&& from) noexcept
    : GetAppRequest() {
    *this = ::std::move(from);
  }

  inline GetAppRequest& operator=(const GetAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppRequest& operator=(GetAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppRequest* internal_default_instance() {
    return reinterpret_cast<const GetAppRequest*>(
               &_GetAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetAppRequest& a, GetAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAppRequest* New() const final {
    return new GetAppRequest();
  }

  GetAppRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAppRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAppRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAppRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.GetAppRequest";
  }
  protected:
  explicit GetAppRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
  };
  // string app_id = 1;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetAppRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetAppResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetAppResponse) */ {
 public:
  inline GetAppResponse() : GetAppResponse(nullptr) {}
  ~GetAppResponse() override;
  explicit constexpr GetAppResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAppResponse(const GetAppResponse& from);
  GetAppResponse(GetAppResponse&& from) noexcept
    : GetAppResponse() {
    *this = ::std::move(from);
  }

  inline GetAppResponse& operator=(const GetAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppResponse& operator=(GetAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppResponse* internal_default_instance() {
    return reinterpret_cast<const GetAppResponse*>(
               &_GetAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetAppResponse& a, GetAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAppResponse* New() const final {
    return new GetAppResponse();
  }

  GetAppResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAppResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAppResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAppResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.GetAppResponse";
  }
  protected:
  explicit GetAppResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
  };
  // .speechly.config.v1.App app = 1;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const ::speechly::config::v1::App& app() const;
  PROTOBUF_MUST_USE_RESULT ::speechly::config::v1::App* release_app();
  ::speechly::config::v1::App* mutable_app();
  void set_allocated_app(::speechly::config::v1::App* app);
  private:
  const ::speechly::config::v1::App& _internal_app() const;
  ::speechly::config::v1::App* _internal_mutable_app();
  public:
  void unsafe_arena_set_allocated_app(
      ::speechly::config::v1::App* app);
  ::speechly::config::v1::App* unsafe_arena_release_app();

  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::speechly::config::v1::App* app_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateAppRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.CreateAppRequest) */ {
 public:
  inline CreateAppRequest() : CreateAppRequest(nullptr) {}
  ~CreateAppRequest() override;
  explicit constexpr CreateAppRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAppRequest(const CreateAppRequest& from);
  CreateAppRequest(CreateAppRequest&& from) noexcept
    : CreateAppRequest() {
    *this = ::std::move(from);
  }

  inline CreateAppRequest& operator=(const CreateAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAppRequest& operator=(CreateAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAppRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAppRequest*>(
               &_CreateAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateAppRequest& a, CreateAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAppRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAppRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateAppRequest* New() const final {
    return new CreateAppRequest();
  }

  CreateAppRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateAppRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAppRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateAppRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAppRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.CreateAppRequest";
  }
  protected:
  explicit CreateAppRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kAppFieldNumber = 2,
  };
  // string project = 1;
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_MUST_USE_RESULT std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // .speechly.config.v1.App app = 2;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const ::speechly::config::v1::App& app() const;
  PROTOBUF_MUST_USE_RESULT ::speechly::config::v1::App* release_app();
  ::speechly::config::v1::App* mutable_app();
  void set_allocated_app(::speechly::config::v1::App* app);
  private:
  const ::speechly::config::v1::App& _internal_app() const;
  ::speechly::config::v1::App* _internal_mutable_app();
  public:
  void unsafe_arena_set_allocated_app(
      ::speechly::config::v1::App* app);
  ::speechly::config::v1::App* unsafe_arena_release_app();

  // @@protoc_insertion_point(class_scope:speechly.config.v1.CreateAppRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  ::speechly::config::v1::App* app_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateAppResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.CreateAppResponse) */ {
 public:
  inline CreateAppResponse() : CreateAppResponse(nullptr) {}
  ~CreateAppResponse() override;
  explicit constexpr CreateAppResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAppResponse(const CreateAppResponse& from);
  CreateAppResponse(CreateAppResponse&& from) noexcept
    : CreateAppResponse() {
    *this = ::std::move(from);
  }

  inline CreateAppResponse& operator=(const CreateAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAppResponse& operator=(CreateAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAppResponse* internal_default_instance() {
    return reinterpret_cast<const CreateAppResponse*>(
               &_CreateAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CreateAppResponse& a, CreateAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAppResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAppResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateAppResponse* New() const final {
    return new CreateAppResponse();
  }

  CreateAppResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateAppResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAppResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateAppResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAppResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.CreateAppResponse";
  }
  protected:
  explicit CreateAppResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
  };
  // .speechly.config.v1.App app = 1;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const ::speechly::config::v1::App& app() const;
  PROTOBUF_MUST_USE_RESULT ::speechly::config::v1::App* release_app();
  ::speechly::config::v1::App* mutable_app();
  void set_allocated_app(::speechly::config::v1::App* app);
  private:
  const ::speechly::config::v1::App& _internal_app() const;
  ::speechly::config::v1::App* _internal_mutable_app();
  public:
  void unsafe_arena_set_allocated_app(
      ::speechly::config::v1::App* app);
  ::speechly::config::v1::App* unsafe_arena_release_app();

  // @@protoc_insertion_point(class_scope:speechly.config.v1.CreateAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::speechly::config::v1::App* app_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateAppRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.UpdateAppRequest) */ {
 public:
  inline UpdateAppRequest() : UpdateAppRequest(nullptr) {}
  ~UpdateAppRequest() override;
  explicit constexpr UpdateAppRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateAppRequest(const UpdateAppRequest& from);
  UpdateAppRequest(UpdateAppRequest&& from) noexcept
    : UpdateAppRequest() {
    *this = ::std::move(from);
  }

  inline UpdateAppRequest& operator=(const UpdateAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAppRequest& operator=(UpdateAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAppRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateAppRequest*>(
               &_UpdateAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateAppRequest& a, UpdateAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAppRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAppRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateAppRequest* New() const final {
    return new UpdateAppRequest();
  }

  UpdateAppRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateAppRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateAppRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateAppRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAppRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.UpdateAppRequest";
  }
  protected:
  explicit UpdateAppRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
  };
  // .speechly.config.v1.App app = 1;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const ::speechly::config::v1::App& app() const;
  PROTOBUF_MUST_USE_RESULT ::speechly::config::v1::App* release_app();
  ::speechly::config::v1::App* mutable_app();
  void set_allocated_app(::speechly::config::v1::App* app);
  private:
  const ::speechly::config::v1::App& _internal_app() const;
  ::speechly::config::v1::App* _internal_mutable_app();
  public:
  void unsafe_arena_set_allocated_app(
      ::speechly::config::v1::App* app);
  ::speechly::config::v1::App* unsafe_arena_release_app();

  // @@protoc_insertion_point(class_scope:speechly.config.v1.UpdateAppRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::speechly::config::v1::App* app_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateAppResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.UpdateAppResponse) */ {
 public:
  inline UpdateAppResponse() : UpdateAppResponse(nullptr) {}
  ~UpdateAppResponse() override;
  explicit constexpr UpdateAppResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateAppResponse(const UpdateAppResponse& from);
  UpdateAppResponse(UpdateAppResponse&& from) noexcept
    : UpdateAppResponse() {
    *this = ::std::move(from);
  }

  inline UpdateAppResponse& operator=(const UpdateAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAppResponse& operator=(UpdateAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAppResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateAppResponse*>(
               &_UpdateAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateAppResponse& a, UpdateAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAppResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAppResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateAppResponse* New() const final {
    return new UpdateAppResponse();
  }

  UpdateAppResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateAppResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateAppResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateAppResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAppResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.UpdateAppResponse";
  }
  protected:
  explicit UpdateAppResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.UpdateAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteAppRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.DeleteAppRequest) */ {
 public:
  inline DeleteAppRequest() : DeleteAppRequest(nullptr) {}
  ~DeleteAppRequest() override;
  explicit constexpr DeleteAppRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteAppRequest(const DeleteAppRequest& from);
  DeleteAppRequest(DeleteAppRequest&& from) noexcept
    : DeleteAppRequest() {
    *this = ::std::move(from);
  }

  inline DeleteAppRequest& operator=(const DeleteAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAppRequest& operator=(DeleteAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAppRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteAppRequest*>(
               &_DeleteAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DeleteAppRequest& a, DeleteAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAppRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAppRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteAppRequest* New() const final {
    return new DeleteAppRequest();
  }

  DeleteAppRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteAppRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteAppRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteAppRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAppRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.DeleteAppRequest";
  }
  protected:
  explicit DeleteAppRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
  };
  // string app_id = 1;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.DeleteAppRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteAppResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.DeleteAppResponse) */ {
 public:
  inline DeleteAppResponse() : DeleteAppResponse(nullptr) {}
  ~DeleteAppResponse() override;
  explicit constexpr DeleteAppResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteAppResponse(const DeleteAppResponse& from);
  DeleteAppResponse(DeleteAppResponse&& from) noexcept
    : DeleteAppResponse() {
    *this = ::std::move(from);
  }

  inline DeleteAppResponse& operator=(const DeleteAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAppResponse& operator=(DeleteAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAppResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteAppResponse*>(
               &_DeleteAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DeleteAppResponse& a, DeleteAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAppResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAppResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteAppResponse* New() const final {
    return new DeleteAppResponse();
  }

  DeleteAppResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteAppResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteAppResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteAppResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAppResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.DeleteAppResponse";
  }
  protected:
  explicit DeleteAppResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.DeleteAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UploadTrainingDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.UploadTrainingDataRequest) */ {
 public:
  inline UploadTrainingDataRequest() : UploadTrainingDataRequest(nullptr) {}
  ~UploadTrainingDataRequest() override;
  explicit constexpr UploadTrainingDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadTrainingDataRequest(const UploadTrainingDataRequest& from);
  UploadTrainingDataRequest(UploadTrainingDataRequest&& from) noexcept
    : UploadTrainingDataRequest() {
    *this = ::std::move(from);
  }

  inline UploadTrainingDataRequest& operator=(const UploadTrainingDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadTrainingDataRequest& operator=(UploadTrainingDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadTrainingDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadTrainingDataRequest* internal_default_instance() {
    return reinterpret_cast<const UploadTrainingDataRequest*>(
               &_UploadTrainingDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UploadTrainingDataRequest& a, UploadTrainingDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadTrainingDataRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadTrainingDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UploadTrainingDataRequest* New() const final {
    return new UploadTrainingDataRequest();
  }

  UploadTrainingDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadTrainingDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadTrainingDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadTrainingDataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadTrainingDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.UploadTrainingDataRequest";
  }
  protected:
  explicit UploadTrainingDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UploadTrainingDataRequest_ContentType ContentType;
  static constexpr ContentType CONTENT_TYPE_UNSPECIFIED =
    UploadTrainingDataRequest_ContentType_CONTENT_TYPE_UNSPECIFIED;
  static constexpr ContentType CONTENT_TYPE_YAML =
    UploadTrainingDataRequest_ContentType_CONTENT_TYPE_YAML;
  static constexpr ContentType CONTENT_TYPE_TAR =
    UploadTrainingDataRequest_ContentType_CONTENT_TYPE_TAR;
  static inline bool ContentType_IsValid(int value) {
    return UploadTrainingDataRequest_ContentType_IsValid(value);
  }
  static constexpr ContentType ContentType_MIN =
    UploadTrainingDataRequest_ContentType_ContentType_MIN;
  static constexpr ContentType ContentType_MAX =
    UploadTrainingDataRequest_ContentType_ContentType_MAX;
  static constexpr int ContentType_ARRAYSIZE =
    UploadTrainingDataRequest_ContentType_ContentType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContentType_descriptor() {
    return UploadTrainingDataRequest_ContentType_descriptor();
  }
  template<typename T>
  static inline const std::string& ContentType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContentType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContentType_Name.");
    return UploadTrainingDataRequest_ContentType_Name(enum_t_value);
  }
  static inline bool ContentType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ContentType* value) {
    return UploadTrainingDataRequest_ContentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kDataChunkFieldNumber = 2,
    kContentTypeFieldNumber = 3,
  };
  // string app_id = 1;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // bytes data_chunk = 2;
  void clear_data_chunk();
  const std::string& data_chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_chunk();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_chunk();
  void set_allocated_data_chunk(std::string* data_chunk);
  private:
  const std::string& _internal_data_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_chunk(const std::string& value);
  std::string* _internal_mutable_data_chunk();
  public:

  // .speechly.config.v1.UploadTrainingDataRequest.ContentType content_type = 3;
  void clear_content_type();
  ::speechly::config::v1::UploadTrainingDataRequest_ContentType content_type() const;
  void set_content_type(::speechly::config::v1::UploadTrainingDataRequest_ContentType value);
  private:
  ::speechly::config::v1::UploadTrainingDataRequest_ContentType _internal_content_type() const;
  void _internal_set_content_type(::speechly::config::v1::UploadTrainingDataRequest_ContentType value);
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.UploadTrainingDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_chunk_;
  int content_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UploadTrainingDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.UploadTrainingDataResponse) */ {
 public:
  inline UploadTrainingDataResponse() : UploadTrainingDataResponse(nullptr) {}
  ~UploadTrainingDataResponse() override;
  explicit constexpr UploadTrainingDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadTrainingDataResponse(const UploadTrainingDataResponse& from);
  UploadTrainingDataResponse(UploadTrainingDataResponse&& from) noexcept
    : UploadTrainingDataResponse() {
    *this = ::std::move(from);
  }

  inline UploadTrainingDataResponse& operator=(const UploadTrainingDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadTrainingDataResponse& operator=(UploadTrainingDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadTrainingDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadTrainingDataResponse* internal_default_instance() {
    return reinterpret_cast<const UploadTrainingDataResponse*>(
               &_UploadTrainingDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UploadTrainingDataResponse& a, UploadTrainingDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadTrainingDataResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadTrainingDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UploadTrainingDataResponse* New() const final {
    return new UploadTrainingDataResponse();
  }

  UploadTrainingDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadTrainingDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadTrainingDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadTrainingDataResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadTrainingDataResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.UploadTrainingDataResponse";
  }
  protected:
  explicit UploadTrainingDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.UploadTrainingDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DownloadCurrentTrainingDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.DownloadCurrentTrainingDataRequest) */ {
 public:
  inline DownloadCurrentTrainingDataRequest() : DownloadCurrentTrainingDataRequest(nullptr) {}
  ~DownloadCurrentTrainingDataRequest() override;
  explicit constexpr DownloadCurrentTrainingDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadCurrentTrainingDataRequest(const DownloadCurrentTrainingDataRequest& from);
  DownloadCurrentTrainingDataRequest(DownloadCurrentTrainingDataRequest&& from) noexcept
    : DownloadCurrentTrainingDataRequest() {
    *this = ::std::move(from);
  }

  inline DownloadCurrentTrainingDataRequest& operator=(const DownloadCurrentTrainingDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadCurrentTrainingDataRequest& operator=(DownloadCurrentTrainingDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadCurrentTrainingDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadCurrentTrainingDataRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadCurrentTrainingDataRequest*>(
               &_DownloadCurrentTrainingDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DownloadCurrentTrainingDataRequest& a, DownloadCurrentTrainingDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadCurrentTrainingDataRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadCurrentTrainingDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DownloadCurrentTrainingDataRequest* New() const final {
    return new DownloadCurrentTrainingDataRequest();
  }

  DownloadCurrentTrainingDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadCurrentTrainingDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadCurrentTrainingDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DownloadCurrentTrainingDataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadCurrentTrainingDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.DownloadCurrentTrainingDataRequest";
  }
  protected:
  explicit DownloadCurrentTrainingDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kConfigIdFieldNumber = 2,
  };
  // string app_id = 1;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string config_id = 2;
  void clear_config_id();
  const std::string& config_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_config_id();
  void set_allocated_config_id(std::string* config_id);
  private:
  const std::string& _internal_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_id(const std::string& value);
  std::string* _internal_mutable_config_id();
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.DownloadCurrentTrainingDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DownloadCurrentTrainingDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.DownloadCurrentTrainingDataResponse) */ {
 public:
  inline DownloadCurrentTrainingDataResponse() : DownloadCurrentTrainingDataResponse(nullptr) {}
  ~DownloadCurrentTrainingDataResponse() override;
  explicit constexpr DownloadCurrentTrainingDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadCurrentTrainingDataResponse(const DownloadCurrentTrainingDataResponse& from);
  DownloadCurrentTrainingDataResponse(DownloadCurrentTrainingDataResponse&& from) noexcept
    : DownloadCurrentTrainingDataResponse() {
    *this = ::std::move(from);
  }

  inline DownloadCurrentTrainingDataResponse& operator=(const DownloadCurrentTrainingDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadCurrentTrainingDataResponse& operator=(DownloadCurrentTrainingDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadCurrentTrainingDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadCurrentTrainingDataResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadCurrentTrainingDataResponse*>(
               &_DownloadCurrentTrainingDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DownloadCurrentTrainingDataResponse& a, DownloadCurrentTrainingDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadCurrentTrainingDataResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadCurrentTrainingDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DownloadCurrentTrainingDataResponse* New() const final {
    return new DownloadCurrentTrainingDataResponse();
  }

  DownloadCurrentTrainingDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadCurrentTrainingDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadCurrentTrainingDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DownloadCurrentTrainingDataResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadCurrentTrainingDataResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.DownloadCurrentTrainingDataResponse";
  }
  protected:
  explicit DownloadCurrentTrainingDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DownloadCurrentTrainingDataResponse_ContentType ContentType;
  static constexpr ContentType CONTENT_TYPE_UNSPECIFIED =
    DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_UNSPECIFIED;
  static constexpr ContentType CONTENT_TYPE_YAML =
    DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_YAML;
  static constexpr ContentType CONTENT_TYPE_TAR =
    DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_TAR;
  static inline bool ContentType_IsValid(int value) {
    return DownloadCurrentTrainingDataResponse_ContentType_IsValid(value);
  }
  static constexpr ContentType ContentType_MIN =
    DownloadCurrentTrainingDataResponse_ContentType_ContentType_MIN;
  static constexpr ContentType ContentType_MAX =
    DownloadCurrentTrainingDataResponse_ContentType_ContentType_MAX;
  static constexpr int ContentType_ARRAYSIZE =
    DownloadCurrentTrainingDataResponse_ContentType_ContentType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContentType_descriptor() {
    return DownloadCurrentTrainingDataResponse_ContentType_descriptor();
  }
  template<typename T>
  static inline const std::string& ContentType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContentType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContentType_Name.");
    return DownloadCurrentTrainingDataResponse_ContentType_Name(enum_t_value);
  }
  static inline bool ContentType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ContentType* value) {
    return DownloadCurrentTrainingDataResponse_ContentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataChunkFieldNumber = 1,
    kContentTypeFieldNumber = 2,
  };
  // bytes data_chunk = 1;
  void clear_data_chunk();
  const std::string& data_chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_chunk();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_chunk();
  void set_allocated_data_chunk(std::string* data_chunk);
  private:
  const std::string& _internal_data_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_chunk(const std::string& value);
  std::string* _internal_mutable_data_chunk();
  public:

  // .speechly.config.v1.DownloadCurrentTrainingDataResponse.ContentType content_type = 2;
  void clear_content_type();
  ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType content_type() const;
  void set_content_type(::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType value);
  private:
  ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType _internal_content_type() const;
  void _internal_set_content_type(::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType value);
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.DownloadCurrentTrainingDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_chunk_;
  int content_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// -------------------------------------------------------------------

class App final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.App) */ {
 public:
  inline App() : App(nullptr) {}
  ~App() override;
  explicit constexpr App(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  App(const App& from);
  App(App&& from) noexcept
    : App() {
    *this = ::std::move(from);
  }

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  inline App& operator=(App&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const App& default_instance() {
    return *internal_default_instance();
  }
  static inline const App* internal_default_instance() {
    return reinterpret_cast<const App*>(
               &_App_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(App& a, App& b) {
    a.Swap(&b);
  }
  inline void Swap(App* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(App* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline App* New() const final {
    return new App();
  }

  App* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<App>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const App& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const App& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(App* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speechly.config.v1.App";
  }
  protected:
  explicit App(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef App_Status Status;
  static constexpr Status STATUS_UNSPECIFIED =
    App_Status_STATUS_UNSPECIFIED;
  static constexpr Status STATUS_NEW =
    App_Status_STATUS_NEW;
  static constexpr Status STATUS_TRAINING =
    App_Status_STATUS_TRAINING;
  static constexpr Status STATUS_TRAINED =
    App_Status_STATUS_TRAINED;
  static constexpr Status STATUS_FAILED =
    App_Status_STATUS_FAILED;
  static inline bool Status_IsValid(int value) {
    return App_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    App_Status_Status_MIN;
  static constexpr Status Status_MAX =
    App_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    App_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return App_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return App_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return App_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLanguageFieldNumber = 2,
    kNameFieldNumber = 4,
    kErrorMsgFieldNumber = 6,
    kStatusFieldNumber = 3,
    kQueueSizeFieldNumber = 5,
    kEstimatedRemainingSecFieldNumber = 7,
    kEstimatedTrainingTimeSecFieldNumber = 8,
    kTrainingTimeSecFieldNumber = 9,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string language = 2;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_MUST_USE_RESULT std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string error_msg = 6;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // .speechly.config.v1.App.Status status = 3;
  void clear_status();
  ::speechly::config::v1::App_Status status() const;
  void set_status(::speechly::config::v1::App_Status value);
  private:
  ::speechly::config::v1::App_Status _internal_status() const;
  void _internal_set_status(::speechly::config::v1::App_Status value);
  public:

  // int32 queue_size = 5;
  void clear_queue_size();
  ::PROTOBUF_NAMESPACE_ID::int32 queue_size() const;
  void set_queue_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_queue_size() const;
  void _internal_set_queue_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 estimated_remaining_sec = 7;
  void clear_estimated_remaining_sec();
  ::PROTOBUF_NAMESPACE_ID::int32 estimated_remaining_sec() const;
  void set_estimated_remaining_sec(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_estimated_remaining_sec() const;
  void _internal_set_estimated_remaining_sec(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 estimated_training_time_sec = 8;
  void clear_estimated_training_time_sec();
  ::PROTOBUF_NAMESPACE_ID::int32 estimated_training_time_sec() const;
  void set_estimated_training_time_sec(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_estimated_training_time_sec() const;
  void _internal_set_estimated_training_time_sec(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 training_time_sec = 9;
  void clear_training_time_sec();
  ::PROTOBUF_NAMESPACE_ID::int32 training_time_sec() const;
  void set_training_time_sec(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_training_time_sec() const;
  void _internal_set_training_time_sec(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:speechly.config.v1.App)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::int32 queue_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 estimated_remaining_sec_;
  ::PROTOBUF_NAMESPACE_ID::int32 estimated_training_time_sec_;
  ::PROTOBUF_NAMESPACE_ID::int32 training_time_sec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetProjectRequest

// -------------------------------------------------------------------

// GetProjectResponse

// repeated string project = 1;
inline int GetProjectResponse::_internal_project_size() const {
  return project_.size();
}
inline int GetProjectResponse::project_size() const {
  return _internal_project_size();
}
inline void GetProjectResponse::clear_project() {
  project_.Clear();
}
inline std::string* GetProjectResponse::add_project() {
  std::string* _s = _internal_add_project();
  // @@protoc_insertion_point(field_add_mutable:speechly.config.v1.GetProjectResponse.project)
  return _s;
}
inline const std::string& GetProjectResponse::_internal_project(int index) const {
  return project_.Get(index);
}
inline const std::string& GetProjectResponse::project(int index) const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectResponse.project)
  return _internal_project(index);
}
inline std::string* GetProjectResponse::mutable_project(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectResponse.project)
  return project_.Mutable(index);
}
inline void GetProjectResponse::set_project(int index, const std::string& value) {
  project_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::set_project(int index, std::string&& value) {
  project_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::set_project(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  project_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::set_project(int index, const char* value, size_t size) {
  project_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speechly.config.v1.GetProjectResponse.project)
}
inline std::string* GetProjectResponse::_internal_add_project() {
  return project_.Add();
}
inline void GetProjectResponse::add_project(const std::string& value) {
  project_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::add_project(std::string&& value) {
  project_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::add_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  project_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::add_project(const char* value, size_t size) {
  project_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speechly.config.v1.GetProjectResponse.project)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetProjectResponse::project() const {
  // @@protoc_insertion_point(field_list:speechly.config.v1.GetProjectResponse.project)
  return project_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetProjectResponse::mutable_project() {
  // @@protoc_insertion_point(field_mutable_list:speechly.config.v1.GetProjectResponse.project)
  return &project_;
}

// repeated string project_names = 2;
inline int GetProjectResponse::_internal_project_names_size() const {
  return project_names_.size();
}
inline int GetProjectResponse::project_names_size() const {
  return _internal_project_names_size();
}
inline void GetProjectResponse::clear_project_names() {
  project_names_.Clear();
}
inline std::string* GetProjectResponse::add_project_names() {
  std::string* _s = _internal_add_project_names();
  // @@protoc_insertion_point(field_add_mutable:speechly.config.v1.GetProjectResponse.project_names)
  return _s;
}
inline const std::string& GetProjectResponse::_internal_project_names(int index) const {
  return project_names_.Get(index);
}
inline const std::string& GetProjectResponse::project_names(int index) const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectResponse.project_names)
  return _internal_project_names(index);
}
inline std::string* GetProjectResponse::mutable_project_names(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectResponse.project_names)
  return project_names_.Mutable(index);
}
inline void GetProjectResponse::set_project_names(int index, const std::string& value) {
  project_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::set_project_names(int index, std::string&& value) {
  project_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::set_project_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  project_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::set_project_names(int index, const char* value, size_t size) {
  project_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speechly.config.v1.GetProjectResponse.project_names)
}
inline std::string* GetProjectResponse::_internal_add_project_names() {
  return project_names_.Add();
}
inline void GetProjectResponse::add_project_names(const std::string& value) {
  project_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::add_project_names(std::string&& value) {
  project_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::add_project_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  project_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::add_project_names(const char* value, size_t size) {
  project_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speechly.config.v1.GetProjectResponse.project_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetProjectResponse::project_names() const {
  // @@protoc_insertion_point(field_list:speechly.config.v1.GetProjectResponse.project_names)
  return project_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetProjectResponse::mutable_project_names() {
  // @@protoc_insertion_point(field_mutable_list:speechly.config.v1.GetProjectResponse.project_names)
  return &project_names_;
}

// -------------------------------------------------------------------

// CreateProjectRequest

// string name = 1;
inline void CreateProjectRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateProjectRequest::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateProjectRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProjectRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.CreateProjectRequest.name)
}
inline std::string* CreateProjectRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateProjectRequest.name)
  return _s;
}
inline const std::string& CreateProjectRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateProjectRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProjectRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProjectRequest::release_name() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateProjectRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProjectRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateProjectRequest.name)
}

// -------------------------------------------------------------------

// CreateProjectResponse

// string project = 1;
inline void CreateProjectResponse::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& CreateProjectResponse::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateProjectResponse.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProjectResponse::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.CreateProjectResponse.project)
}
inline std::string* CreateProjectResponse::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateProjectResponse.project)
  return _s;
}
inline const std::string& CreateProjectResponse::_internal_project() const {
  return project_.Get();
}
inline void CreateProjectResponse::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::release_project() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateProjectResponse.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProjectResponse::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateProjectResponse.project)
}

// string name = 2;
inline void CreateProjectResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateProjectResponse::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateProjectResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProjectResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.CreateProjectResponse.name)
}
inline std::string* CreateProjectResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateProjectResponse.name)
  return _s;
}
inline const std::string& CreateProjectResponse::_internal_name() const {
  return name_.Get();
}
inline void CreateProjectResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::release_name() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateProjectResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProjectResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateProjectResponse.name)
}

// -------------------------------------------------------------------

// UpdateProjectRequest

// string project = 1;
inline void UpdateProjectRequest::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& UpdateProjectRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UpdateProjectRequest.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateProjectRequest::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.UpdateProjectRequest.project)
}
inline std::string* UpdateProjectRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UpdateProjectRequest.project)
  return _s;
}
inline const std::string& UpdateProjectRequest::_internal_project() const {
  return project_.Get();
}
inline void UpdateProjectRequest::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateProjectRequest::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateProjectRequest::release_project() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.UpdateProjectRequest.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateProjectRequest::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UpdateProjectRequest.project)
}

// string name = 2;
inline void UpdateProjectRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdateProjectRequest::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UpdateProjectRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateProjectRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.UpdateProjectRequest.name)
}
inline std::string* UpdateProjectRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UpdateProjectRequest.name)
  return _s;
}
inline const std::string& UpdateProjectRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateProjectRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateProjectRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateProjectRequest::release_name() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.UpdateProjectRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateProjectRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UpdateProjectRequest.name)
}

// -------------------------------------------------------------------

// UpdateProjectResponse

// -------------------------------------------------------------------

// GetProjectParticipantsRequest

// string project = 1;
inline void GetProjectParticipantsRequest::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& GetProjectParticipantsRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsRequest.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectParticipantsRequest::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectParticipantsRequest.project)
}
inline std::string* GetProjectParticipantsRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsRequest.project)
  return _s;
}
inline const std::string& GetProjectParticipantsRequest::_internal_project() const {
  return project_.Get();
}
inline void GetProjectParticipantsRequest::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsRequest::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsRequest::release_project() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetProjectParticipantsRequest.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectParticipantsRequest::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetProjectParticipantsRequest.project)
}

// -------------------------------------------------------------------

// GetProjectParticipantsResponse_Participant

// string name = 1;
inline void GetProjectParticipantsResponse_Participant::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetProjectParticipantsResponse_Participant::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectParticipantsResponse_Participant::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
}
inline std::string* GetProjectParticipantsResponse_Participant::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
  return _s;
}
inline const std::string& GetProjectParticipantsResponse_Participant::_internal_name() const {
  return name_.Get();
}
inline void GetProjectParticipantsResponse_Participant::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::release_name() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectParticipantsResponse_Participant::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
}

// string email = 2;
inline void GetProjectParticipantsResponse_Participant::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& GetProjectParticipantsResponse_Participant::email() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectParticipantsResponse_Participant::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
}
inline std::string* GetProjectParticipantsResponse_Participant::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
  return _s;
}
inline const std::string& GetProjectParticipantsResponse_Participant::_internal_email() const {
  return email_.Get();
}
inline void GetProjectParticipantsResponse_Participant::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::release_email() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectParticipantsResponse_Participant::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
}

// string id = 3;
inline void GetProjectParticipantsResponse_Participant::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetProjectParticipantsResponse_Participant::id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectParticipantsResponse_Participant::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
}
inline std::string* GetProjectParticipantsResponse_Participant::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
  return _s;
}
inline const std::string& GetProjectParticipantsResponse_Participant::_internal_id() const {
  return id_.Get();
}
inline void GetProjectParticipantsResponse_Participant::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::release_id() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectParticipantsResponse_Participant::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
}

// -------------------------------------------------------------------

// GetProjectParticipantsResponse

// repeated .speechly.config.v1.GetProjectParticipantsResponse.Participant participants = 1;
inline int GetProjectParticipantsResponse::_internal_participants_size() const {
  return participants_.size();
}
inline int GetProjectParticipantsResponse::participants_size() const {
  return _internal_participants_size();
}
inline void GetProjectParticipantsResponse::clear_participants() {
  participants_.Clear();
}
inline ::speechly::config::v1::GetProjectParticipantsResponse_Participant* GetProjectParticipantsResponse::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsResponse.participants)
  return participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant >*
GetProjectParticipantsResponse::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:speechly.config.v1.GetProjectParticipantsResponse.participants)
  return &participants_;
}
inline const ::speechly::config::v1::GetProjectParticipantsResponse_Participant& GetProjectParticipantsResponse::_internal_participants(int index) const {
  return participants_.Get(index);
}
inline const ::speechly::config::v1::GetProjectParticipantsResponse_Participant& GetProjectParticipantsResponse::participants(int index) const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsResponse.participants)
  return _internal_participants(index);
}
inline ::speechly::config::v1::GetProjectParticipantsResponse_Participant* GetProjectParticipantsResponse::_internal_add_participants() {
  return participants_.Add();
}
inline ::speechly::config::v1::GetProjectParticipantsResponse_Participant* GetProjectParticipantsResponse::add_participants() {
  ::speechly::config::v1::GetProjectParticipantsResponse_Participant* _add = _internal_add_participants();
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectParticipantsResponse.participants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant >&
GetProjectParticipantsResponse::participants() const {
  // @@protoc_insertion_point(field_list:speechly.config.v1.GetProjectParticipantsResponse.participants)
  return participants_;
}

// -------------------------------------------------------------------

// InviteRequest

// string project = 1;
inline void InviteRequest::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& InviteRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.InviteRequest.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InviteRequest::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.InviteRequest.project)
}
inline std::string* InviteRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.InviteRequest.project)
  return _s;
}
inline const std::string& InviteRequest::_internal_project() const {
  return project_.Get();
}
inline void InviteRequest::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InviteRequest::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InviteRequest::release_project() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.InviteRequest.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InviteRequest::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.InviteRequest.project)
}

// -------------------------------------------------------------------

// InviteResponse

// string invitation_token = 1;
inline void InviteResponse::clear_invitation_token() {
  invitation_token_.ClearToEmpty();
}
inline const std::string& InviteResponse::invitation_token() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.InviteResponse.invitation_token)
  return _internal_invitation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InviteResponse::set_invitation_token(ArgT0&& arg0, ArgT... args) {
 
 invitation_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.InviteResponse.invitation_token)
}
inline std::string* InviteResponse::mutable_invitation_token() {
  std::string* _s = _internal_mutable_invitation_token();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.InviteResponse.invitation_token)
  return _s;
}
inline const std::string& InviteResponse::_internal_invitation_token() const {
  return invitation_token_.Get();
}
inline void InviteResponse::_internal_set_invitation_token(const std::string& value) {
  
  invitation_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InviteResponse::_internal_mutable_invitation_token() {
  
  return invitation_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InviteResponse::release_invitation_token() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.InviteResponse.invitation_token)
  return invitation_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InviteResponse::set_allocated_invitation_token(std::string* invitation_token) {
  if (invitation_token != nullptr) {
    
  } else {
    
  }
  invitation_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invitation_token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.InviteResponse.invitation_token)
}

// -------------------------------------------------------------------

// JoinProjectRequest

// string invitation_token = 1;
inline void JoinProjectRequest::clear_invitation_token() {
  invitation_token_.ClearToEmpty();
}
inline const std::string& JoinProjectRequest::invitation_token() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.JoinProjectRequest.invitation_token)
  return _internal_invitation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinProjectRequest::set_invitation_token(ArgT0&& arg0, ArgT... args) {
 
 invitation_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.JoinProjectRequest.invitation_token)
}
inline std::string* JoinProjectRequest::mutable_invitation_token() {
  std::string* _s = _internal_mutable_invitation_token();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.JoinProjectRequest.invitation_token)
  return _s;
}
inline const std::string& JoinProjectRequest::_internal_invitation_token() const {
  return invitation_token_.Get();
}
inline void JoinProjectRequest::_internal_set_invitation_token(const std::string& value) {
  
  invitation_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinProjectRequest::_internal_mutable_invitation_token() {
  
  return invitation_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinProjectRequest::release_invitation_token() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.JoinProjectRequest.invitation_token)
  return invitation_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JoinProjectRequest::set_allocated_invitation_token(std::string* invitation_token) {
  if (invitation_token != nullptr) {
    
  } else {
    
  }
  invitation_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invitation_token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.JoinProjectRequest.invitation_token)
}

// -------------------------------------------------------------------

// JoinProjectResponse

// -------------------------------------------------------------------

// ListAppsRequest

// string project = 1;
inline void ListAppsRequest::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& ListAppsRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.ListAppsRequest.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListAppsRequest::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.ListAppsRequest.project)
}
inline std::string* ListAppsRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.ListAppsRequest.project)
  return _s;
}
inline const std::string& ListAppsRequest::_internal_project() const {
  return project_.Get();
}
inline void ListAppsRequest::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListAppsRequest::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListAppsRequest::release_project() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.ListAppsRequest.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListAppsRequest::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.ListAppsRequest.project)
}

// -------------------------------------------------------------------

// ListAppsResponse

// repeated .speechly.config.v1.App apps = 1;
inline int ListAppsResponse::_internal_apps_size() const {
  return apps_.size();
}
inline int ListAppsResponse::apps_size() const {
  return _internal_apps_size();
}
inline void ListAppsResponse::clear_apps() {
  apps_.Clear();
}
inline ::speechly::config::v1::App* ListAppsResponse::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.ListAppsResponse.apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::App >*
ListAppsResponse::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:speechly.config.v1.ListAppsResponse.apps)
  return &apps_;
}
inline const ::speechly::config::v1::App& ListAppsResponse::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::speechly::config::v1::App& ListAppsResponse::apps(int index) const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.ListAppsResponse.apps)
  return _internal_apps(index);
}
inline ::speechly::config::v1::App* ListAppsResponse::_internal_add_apps() {
  return apps_.Add();
}
inline ::speechly::config::v1::App* ListAppsResponse::add_apps() {
  ::speechly::config::v1::App* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:speechly.config.v1.ListAppsResponse.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speechly::config::v1::App >&
ListAppsResponse::apps() const {
  // @@protoc_insertion_point(field_list:speechly.config.v1.ListAppsResponse.apps)
  return apps_;
}

// -------------------------------------------------------------------

// GetAppRequest

// string app_id = 1;
inline void GetAppRequest::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& GetAppRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetAppRequest.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAppRequest::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetAppRequest.app_id)
}
inline std::string* GetAppRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetAppRequest.app_id)
  return _s;
}
inline const std::string& GetAppRequest::_internal_app_id() const {
  return app_id_.Get();
}
inline void GetAppRequest::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAppRequest::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAppRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetAppRequest.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAppRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetAppRequest.app_id)
}

// -------------------------------------------------------------------

// GetAppResponse

// .speechly.config.v1.App app = 1;
inline bool GetAppResponse::_internal_has_app() const {
  return this != internal_default_instance() && app_ != nullptr;
}
inline bool GetAppResponse::has_app() const {
  return _internal_has_app();
}
inline void GetAppResponse::clear_app() {
  if (GetArenaForAllocation() == nullptr && app_ != nullptr) {
    delete app_;
  }
  app_ = nullptr;
}
inline const ::speechly::config::v1::App& GetAppResponse::_internal_app() const {
  const ::speechly::config::v1::App* p = app_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::config::v1::App&>(
      ::speechly::config::v1::_App_default_instance_);
}
inline const ::speechly::config::v1::App& GetAppResponse::app() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetAppResponse.app)
  return _internal_app();
}
inline void GetAppResponse::unsafe_arena_set_allocated_app(
    ::speechly::config::v1::App* app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_);
  }
  app_ = app;
  if (app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.config.v1.GetAppResponse.app)
}
inline ::speechly::config::v1::App* GetAppResponse::release_app() {
  
  ::speechly::config::v1::App* temp = app_;
  app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speechly::config::v1::App* GetAppResponse::unsafe_arena_release_app() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetAppResponse.app)
  
  ::speechly::config::v1::App* temp = app_;
  app_ = nullptr;
  return temp;
}
inline ::speechly::config::v1::App* GetAppResponse::_internal_mutable_app() {
  
  if (app_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::config::v1::App>(GetArenaForAllocation());
    app_ = p;
  }
  return app_;
}
inline ::speechly::config::v1::App* GetAppResponse::mutable_app() {
  ::speechly::config::v1::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetAppResponse.app)
  return _msg;
}
inline void GetAppResponse::set_allocated_app(::speechly::config::v1::App* app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete app_;
  }
  if (app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::speechly::config::v1::App>::GetOwningArena(app);
    if (message_arena != submessage_arena) {
      app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app, submessage_arena);
    }
    
  } else {
    
  }
  app_ = app;
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetAppResponse.app)
}

// -------------------------------------------------------------------

// CreateAppRequest

// string project = 1;
inline void CreateAppRequest::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& CreateAppRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateAppRequest.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAppRequest::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.CreateAppRequest.project)
}
inline std::string* CreateAppRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateAppRequest.project)
  return _s;
}
inline const std::string& CreateAppRequest::_internal_project() const {
  return project_.Get();
}
inline void CreateAppRequest::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateAppRequest::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateAppRequest::release_project() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateAppRequest.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateAppRequest::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateAppRequest.project)
}

// .speechly.config.v1.App app = 2;
inline bool CreateAppRequest::_internal_has_app() const {
  return this != internal_default_instance() && app_ != nullptr;
}
inline bool CreateAppRequest::has_app() const {
  return _internal_has_app();
}
inline void CreateAppRequest::clear_app() {
  if (GetArenaForAllocation() == nullptr && app_ != nullptr) {
    delete app_;
  }
  app_ = nullptr;
}
inline const ::speechly::config::v1::App& CreateAppRequest::_internal_app() const {
  const ::speechly::config::v1::App* p = app_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::config::v1::App&>(
      ::speechly::config::v1::_App_default_instance_);
}
inline const ::speechly::config::v1::App& CreateAppRequest::app() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateAppRequest.app)
  return _internal_app();
}
inline void CreateAppRequest::unsafe_arena_set_allocated_app(
    ::speechly::config::v1::App* app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_);
  }
  app_ = app;
  if (app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.config.v1.CreateAppRequest.app)
}
inline ::speechly::config::v1::App* CreateAppRequest::release_app() {
  
  ::speechly::config::v1::App* temp = app_;
  app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speechly::config::v1::App* CreateAppRequest::unsafe_arena_release_app() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateAppRequest.app)
  
  ::speechly::config::v1::App* temp = app_;
  app_ = nullptr;
  return temp;
}
inline ::speechly::config::v1::App* CreateAppRequest::_internal_mutable_app() {
  
  if (app_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::config::v1::App>(GetArenaForAllocation());
    app_ = p;
  }
  return app_;
}
inline ::speechly::config::v1::App* CreateAppRequest::mutable_app() {
  ::speechly::config::v1::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateAppRequest.app)
  return _msg;
}
inline void CreateAppRequest::set_allocated_app(::speechly::config::v1::App* app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete app_;
  }
  if (app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::speechly::config::v1::App>::GetOwningArena(app);
    if (message_arena != submessage_arena) {
      app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app, submessage_arena);
    }
    
  } else {
    
  }
  app_ = app;
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateAppRequest.app)
}

// -------------------------------------------------------------------

// CreateAppResponse

// .speechly.config.v1.App app = 1;
inline bool CreateAppResponse::_internal_has_app() const {
  return this != internal_default_instance() && app_ != nullptr;
}
inline bool CreateAppResponse::has_app() const {
  return _internal_has_app();
}
inline void CreateAppResponse::clear_app() {
  if (GetArenaForAllocation() == nullptr && app_ != nullptr) {
    delete app_;
  }
  app_ = nullptr;
}
inline const ::speechly::config::v1::App& CreateAppResponse::_internal_app() const {
  const ::speechly::config::v1::App* p = app_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::config::v1::App&>(
      ::speechly::config::v1::_App_default_instance_);
}
inline const ::speechly::config::v1::App& CreateAppResponse::app() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateAppResponse.app)
  return _internal_app();
}
inline void CreateAppResponse::unsafe_arena_set_allocated_app(
    ::speechly::config::v1::App* app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_);
  }
  app_ = app;
  if (app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.config.v1.CreateAppResponse.app)
}
inline ::speechly::config::v1::App* CreateAppResponse::release_app() {
  
  ::speechly::config::v1::App* temp = app_;
  app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speechly::config::v1::App* CreateAppResponse::unsafe_arena_release_app() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateAppResponse.app)
  
  ::speechly::config::v1::App* temp = app_;
  app_ = nullptr;
  return temp;
}
inline ::speechly::config::v1::App* CreateAppResponse::_internal_mutable_app() {
  
  if (app_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::config::v1::App>(GetArenaForAllocation());
    app_ = p;
  }
  return app_;
}
inline ::speechly::config::v1::App* CreateAppResponse::mutable_app() {
  ::speechly::config::v1::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateAppResponse.app)
  return _msg;
}
inline void CreateAppResponse::set_allocated_app(::speechly::config::v1::App* app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete app_;
  }
  if (app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::speechly::config::v1::App>::GetOwningArena(app);
    if (message_arena != submessage_arena) {
      app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app, submessage_arena);
    }
    
  } else {
    
  }
  app_ = app;
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateAppResponse.app)
}

// -------------------------------------------------------------------

// UpdateAppRequest

// .speechly.config.v1.App app = 1;
inline bool UpdateAppRequest::_internal_has_app() const {
  return this != internal_default_instance() && app_ != nullptr;
}
inline bool UpdateAppRequest::has_app() const {
  return _internal_has_app();
}
inline void UpdateAppRequest::clear_app() {
  if (GetArenaForAllocation() == nullptr && app_ != nullptr) {
    delete app_;
  }
  app_ = nullptr;
}
inline const ::speechly::config::v1::App& UpdateAppRequest::_internal_app() const {
  const ::speechly::config::v1::App* p = app_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::config::v1::App&>(
      ::speechly::config::v1::_App_default_instance_);
}
inline const ::speechly::config::v1::App& UpdateAppRequest::app() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UpdateAppRequest.app)
  return _internal_app();
}
inline void UpdateAppRequest::unsafe_arena_set_allocated_app(
    ::speechly::config::v1::App* app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_);
  }
  app_ = app;
  if (app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.config.v1.UpdateAppRequest.app)
}
inline ::speechly::config::v1::App* UpdateAppRequest::release_app() {
  
  ::speechly::config::v1::App* temp = app_;
  app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speechly::config::v1::App* UpdateAppRequest::unsafe_arena_release_app() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.UpdateAppRequest.app)
  
  ::speechly::config::v1::App* temp = app_;
  app_ = nullptr;
  return temp;
}
inline ::speechly::config::v1::App* UpdateAppRequest::_internal_mutable_app() {
  
  if (app_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::config::v1::App>(GetArenaForAllocation());
    app_ = p;
  }
  return app_;
}
inline ::speechly::config::v1::App* UpdateAppRequest::mutable_app() {
  ::speechly::config::v1::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UpdateAppRequest.app)
  return _msg;
}
inline void UpdateAppRequest::set_allocated_app(::speechly::config::v1::App* app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete app_;
  }
  if (app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::speechly::config::v1::App>::GetOwningArena(app);
    if (message_arena != submessage_arena) {
      app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app, submessage_arena);
    }
    
  } else {
    
  }
  app_ = app;
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UpdateAppRequest.app)
}

// -------------------------------------------------------------------

// UpdateAppResponse

// -------------------------------------------------------------------

// DeleteAppRequest

// string app_id = 1;
inline void DeleteAppRequest::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& DeleteAppRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DeleteAppRequest.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAppRequest::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.DeleteAppRequest.app_id)
}
inline std::string* DeleteAppRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.DeleteAppRequest.app_id)
  return _s;
}
inline const std::string& DeleteAppRequest::_internal_app_id() const {
  return app_id_.Get();
}
inline void DeleteAppRequest::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteAppRequest::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteAppRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.DeleteAppRequest.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteAppRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.DeleteAppRequest.app_id)
}

// -------------------------------------------------------------------

// DeleteAppResponse

// -------------------------------------------------------------------

// UploadTrainingDataRequest

// string app_id = 1;
inline void UploadTrainingDataRequest::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& UploadTrainingDataRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UploadTrainingDataRequest.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadTrainingDataRequest::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.UploadTrainingDataRequest.app_id)
}
inline std::string* UploadTrainingDataRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UploadTrainingDataRequest.app_id)
  return _s;
}
inline const std::string& UploadTrainingDataRequest::_internal_app_id() const {
  return app_id_.Get();
}
inline void UploadTrainingDataRequest::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UploadTrainingDataRequest::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UploadTrainingDataRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.UploadTrainingDataRequest.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UploadTrainingDataRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UploadTrainingDataRequest.app_id)
}

// bytes data_chunk = 2;
inline void UploadTrainingDataRequest::clear_data_chunk() {
  data_chunk_.ClearToEmpty();
}
inline const std::string& UploadTrainingDataRequest::data_chunk() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
  return _internal_data_chunk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadTrainingDataRequest::set_data_chunk(ArgT0&& arg0, ArgT... args) {
 
 data_chunk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
}
inline std::string* UploadTrainingDataRequest::mutable_data_chunk() {
  std::string* _s = _internal_mutable_data_chunk();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
  return _s;
}
inline const std::string& UploadTrainingDataRequest::_internal_data_chunk() const {
  return data_chunk_.Get();
}
inline void UploadTrainingDataRequest::_internal_set_data_chunk(const std::string& value) {
  
  data_chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UploadTrainingDataRequest::_internal_mutable_data_chunk() {
  
  return data_chunk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UploadTrainingDataRequest::release_data_chunk() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
  return data_chunk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UploadTrainingDataRequest::set_allocated_data_chunk(std::string* data_chunk) {
  if (data_chunk != nullptr) {
    
  } else {
    
  }
  data_chunk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_chunk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
}

// .speechly.config.v1.UploadTrainingDataRequest.ContentType content_type = 3;
inline void UploadTrainingDataRequest::clear_content_type() {
  content_type_ = 0;
}
inline ::speechly::config::v1::UploadTrainingDataRequest_ContentType UploadTrainingDataRequest::_internal_content_type() const {
  return static_cast< ::speechly::config::v1::UploadTrainingDataRequest_ContentType >(content_type_);
}
inline ::speechly::config::v1::UploadTrainingDataRequest_ContentType UploadTrainingDataRequest::content_type() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UploadTrainingDataRequest.content_type)
  return _internal_content_type();
}
inline void UploadTrainingDataRequest::_internal_set_content_type(::speechly::config::v1::UploadTrainingDataRequest_ContentType value) {
  
  content_type_ = value;
}
inline void UploadTrainingDataRequest::set_content_type(::speechly::config::v1::UploadTrainingDataRequest_ContentType value) {
  _internal_set_content_type(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.UploadTrainingDataRequest.content_type)
}

// -------------------------------------------------------------------

// UploadTrainingDataResponse

// -------------------------------------------------------------------

// DownloadCurrentTrainingDataRequest

// string app_id = 1;
inline void DownloadCurrentTrainingDataRequest::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& DownloadCurrentTrainingDataRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadCurrentTrainingDataRequest::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
}
inline std::string* DownloadCurrentTrainingDataRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
  return _s;
}
inline const std::string& DownloadCurrentTrainingDataRequest::_internal_app_id() const {
  return app_id_.Get();
}
inline void DownloadCurrentTrainingDataRequest::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataRequest::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DownloadCurrentTrainingDataRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
}

// string config_id = 2;
inline void DownloadCurrentTrainingDataRequest::clear_config_id() {
  config_id_.ClearToEmpty();
}
inline const std::string& DownloadCurrentTrainingDataRequest::config_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
  return _internal_config_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadCurrentTrainingDataRequest::set_config_id(ArgT0&& arg0, ArgT... args) {
 
 config_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
}
inline std::string* DownloadCurrentTrainingDataRequest::mutable_config_id() {
  std::string* _s = _internal_mutable_config_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
  return _s;
}
inline const std::string& DownloadCurrentTrainingDataRequest::_internal_config_id() const {
  return config_id_.Get();
}
inline void DownloadCurrentTrainingDataRequest::_internal_set_config_id(const std::string& value) {
  
  config_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataRequest::_internal_mutable_config_id() {
  
  return config_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataRequest::release_config_id() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
  return config_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DownloadCurrentTrainingDataRequest::set_allocated_config_id(std::string* config_id) {
  if (config_id != nullptr) {
    
  } else {
    
  }
  config_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
}

// -------------------------------------------------------------------

// DownloadCurrentTrainingDataResponse

// bytes data_chunk = 1;
inline void DownloadCurrentTrainingDataResponse::clear_data_chunk() {
  data_chunk_.ClearToEmpty();
}
inline const std::string& DownloadCurrentTrainingDataResponse::data_chunk() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
  return _internal_data_chunk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadCurrentTrainingDataResponse::set_data_chunk(ArgT0&& arg0, ArgT... args) {
 
 data_chunk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
}
inline std::string* DownloadCurrentTrainingDataResponse::mutable_data_chunk() {
  std::string* _s = _internal_mutable_data_chunk();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
  return _s;
}
inline const std::string& DownloadCurrentTrainingDataResponse::_internal_data_chunk() const {
  return data_chunk_.Get();
}
inline void DownloadCurrentTrainingDataResponse::_internal_set_data_chunk(const std::string& value) {
  
  data_chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataResponse::_internal_mutable_data_chunk() {
  
  return data_chunk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataResponse::release_data_chunk() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
  return data_chunk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DownloadCurrentTrainingDataResponse::set_allocated_data_chunk(std::string* data_chunk) {
  if (data_chunk != nullptr) {
    
  } else {
    
  }
  data_chunk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_chunk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
}

// .speechly.config.v1.DownloadCurrentTrainingDataResponse.ContentType content_type = 2;
inline void DownloadCurrentTrainingDataResponse::clear_content_type() {
  content_type_ = 0;
}
inline ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType DownloadCurrentTrainingDataResponse::_internal_content_type() const {
  return static_cast< ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType >(content_type_);
}
inline ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType DownloadCurrentTrainingDataResponse::content_type() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DownloadCurrentTrainingDataResponse.content_type)
  return _internal_content_type();
}
inline void DownloadCurrentTrainingDataResponse::_internal_set_content_type(::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType value) {
  
  content_type_ = value;
}
inline void DownloadCurrentTrainingDataResponse::set_content_type(::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType value) {
  _internal_set_content_type(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.DownloadCurrentTrainingDataResponse.content_type)
}

// -------------------------------------------------------------------

// App

// string id = 1;
inline void App::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& App::id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.id)
}
inline std::string* App::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.id)
  return _s;
}
inline const std::string& App::_internal_id() const {
  return id_.Get();
}
inline void App::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* App::release_id() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.App.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void App::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.App.id)
}

// string language = 2;
inline void App::clear_language() {
  language_.ClearToEmpty();
}
inline const std::string& App::language() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_language(ArgT0&& arg0, ArgT... args) {
 
 language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.language)
}
inline std::string* App::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.language)
  return _s;
}
inline const std::string& App::_internal_language() const {
  return language_.Get();
}
inline void App::_internal_set_language(const std::string& value) {
  
  language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_language() {
  
  return language_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* App::release_language() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.App.language)
  return language_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void App::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.App.language)
}

// .speechly.config.v1.App.Status status = 3;
inline void App::clear_status() {
  status_ = 0;
}
inline ::speechly::config::v1::App_Status App::_internal_status() const {
  return static_cast< ::speechly::config::v1::App_Status >(status_);
}
inline ::speechly::config::v1::App_Status App::status() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.status)
  return _internal_status();
}
inline void App::_internal_set_status(::speechly::config::v1::App_Status value) {
  
  status_ = value;
}
inline void App::set_status(::speechly::config::v1::App_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.status)
}

// string name = 4;
inline void App::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& App::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.name)
}
inline std::string* App::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.name)
  return _s;
}
inline const std::string& App::_internal_name() const {
  return name_.Get();
}
inline void App::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* App::release_name() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.App.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void App::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.App.name)
}

// int32 queue_size = 5;
inline void App::clear_queue_size() {
  queue_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 App::_internal_queue_size() const {
  return queue_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 App::queue_size() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.queue_size)
  return _internal_queue_size();
}
inline void App::_internal_set_queue_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  queue_size_ = value;
}
inline void App::set_queue_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_queue_size(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.queue_size)
}

// string error_msg = 6;
inline void App::clear_error_msg() {
  error_msg_.ClearToEmpty();
}
inline const std::string& App::error_msg() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 error_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.error_msg)
}
inline std::string* App::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.error_msg)
  return _s;
}
inline const std::string& App::_internal_error_msg() const {
  return error_msg_.Get();
}
inline void App::_internal_set_error_msg(const std::string& value) {
  
  error_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_error_msg() {
  
  return error_msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* App::release_error_msg() {
  // @@protoc_insertion_point(field_release:speechly.config.v1.App.error_msg)
  return error_msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void App::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  error_msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.App.error_msg)
}

// int32 estimated_remaining_sec = 7;
inline void App::clear_estimated_remaining_sec() {
  estimated_remaining_sec_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 App::_internal_estimated_remaining_sec() const {
  return estimated_remaining_sec_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 App::estimated_remaining_sec() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.estimated_remaining_sec)
  return _internal_estimated_remaining_sec();
}
inline void App::_internal_set_estimated_remaining_sec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  estimated_remaining_sec_ = value;
}
inline void App::set_estimated_remaining_sec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_estimated_remaining_sec(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.estimated_remaining_sec)
}

// int32 estimated_training_time_sec = 8;
inline void App::clear_estimated_training_time_sec() {
  estimated_training_time_sec_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 App::_internal_estimated_training_time_sec() const {
  return estimated_training_time_sec_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 App::estimated_training_time_sec() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.estimated_training_time_sec)
  return _internal_estimated_training_time_sec();
}
inline void App::_internal_set_estimated_training_time_sec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  estimated_training_time_sec_ = value;
}
inline void App::set_estimated_training_time_sec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_estimated_training_time_sec(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.estimated_training_time_sec)
}

// int32 training_time_sec = 9;
inline void App::clear_training_time_sec() {
  training_time_sec_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 App::_internal_training_time_sec() const {
  return training_time_sec_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 App::training_time_sec() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.training_time_sec)
  return _internal_training_time_sec();
}
inline void App::_internal_set_training_time_sec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  training_time_sec_ = value;
}
inline void App::set_training_time_sec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_training_time_sec(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.training_time_sec)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace config
}  // namespace speechly

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::speechly::config::v1::UploadTrainingDataRequest_ContentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speechly::config::v1::UploadTrainingDataRequest_ContentType>() {
  return ::speechly::config::v1::UploadTrainingDataRequest_ContentType_descriptor();
}
template <> struct is_proto_enum< ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType>() {
  return ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType_descriptor();
}
template <> struct is_proto_enum< ::speechly::config::v1::App_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speechly::config::v1::App_Status>() {
  return ::speechly::config::v1::App_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto
