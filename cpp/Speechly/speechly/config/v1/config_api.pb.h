// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: speechly/config/v1/config_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
namespace speechly {
namespace config {
namespace v1 {
class App;
struct AppDefaultTypeInternal;
extern AppDefaultTypeInternal _App_default_instance_;
class CreateAppRequest;
struct CreateAppRequestDefaultTypeInternal;
extern CreateAppRequestDefaultTypeInternal _CreateAppRequest_default_instance_;
class CreateAppResponse;
struct CreateAppResponseDefaultTypeInternal;
extern CreateAppResponseDefaultTypeInternal _CreateAppResponse_default_instance_;
class CreateProjectRequest;
struct CreateProjectRequestDefaultTypeInternal;
extern CreateProjectRequestDefaultTypeInternal _CreateProjectRequest_default_instance_;
class CreateProjectResponse;
struct CreateProjectResponseDefaultTypeInternal;
extern CreateProjectResponseDefaultTypeInternal _CreateProjectResponse_default_instance_;
class DeleteAppRequest;
struct DeleteAppRequestDefaultTypeInternal;
extern DeleteAppRequestDefaultTypeInternal _DeleteAppRequest_default_instance_;
class DeleteAppResponse;
struct DeleteAppResponseDefaultTypeInternal;
extern DeleteAppResponseDefaultTypeInternal _DeleteAppResponse_default_instance_;
class DownloadCurrentTrainingDataRequest;
struct DownloadCurrentTrainingDataRequestDefaultTypeInternal;
extern DownloadCurrentTrainingDataRequestDefaultTypeInternal _DownloadCurrentTrainingDataRequest_default_instance_;
class DownloadCurrentTrainingDataResponse;
struct DownloadCurrentTrainingDataResponseDefaultTypeInternal;
extern DownloadCurrentTrainingDataResponseDefaultTypeInternal _DownloadCurrentTrainingDataResponse_default_instance_;
class GetAppRequest;
struct GetAppRequestDefaultTypeInternal;
extern GetAppRequestDefaultTypeInternal _GetAppRequest_default_instance_;
class GetAppResponse;
struct GetAppResponseDefaultTypeInternal;
extern GetAppResponseDefaultTypeInternal _GetAppResponse_default_instance_;
class GetProjectParticipantsRequest;
struct GetProjectParticipantsRequestDefaultTypeInternal;
extern GetProjectParticipantsRequestDefaultTypeInternal _GetProjectParticipantsRequest_default_instance_;
class GetProjectParticipantsResponse;
struct GetProjectParticipantsResponseDefaultTypeInternal;
extern GetProjectParticipantsResponseDefaultTypeInternal _GetProjectParticipantsResponse_default_instance_;
class GetProjectParticipantsResponse_Participant;
struct GetProjectParticipantsResponse_ParticipantDefaultTypeInternal;
extern GetProjectParticipantsResponse_ParticipantDefaultTypeInternal _GetProjectParticipantsResponse_Participant_default_instance_;
class GetProjectRequest;
struct GetProjectRequestDefaultTypeInternal;
extern GetProjectRequestDefaultTypeInternal _GetProjectRequest_default_instance_;
class GetProjectResponse;
struct GetProjectResponseDefaultTypeInternal;
extern GetProjectResponseDefaultTypeInternal _GetProjectResponse_default_instance_;
class InviteRequest;
struct InviteRequestDefaultTypeInternal;
extern InviteRequestDefaultTypeInternal _InviteRequest_default_instance_;
class InviteResponse;
struct InviteResponseDefaultTypeInternal;
extern InviteResponseDefaultTypeInternal _InviteResponse_default_instance_;
class JoinProjectRequest;
struct JoinProjectRequestDefaultTypeInternal;
extern JoinProjectRequestDefaultTypeInternal _JoinProjectRequest_default_instance_;
class JoinProjectResponse;
struct JoinProjectResponseDefaultTypeInternal;
extern JoinProjectResponseDefaultTypeInternal _JoinProjectResponse_default_instance_;
class ListAppsRequest;
struct ListAppsRequestDefaultTypeInternal;
extern ListAppsRequestDefaultTypeInternal _ListAppsRequest_default_instance_;
class ListAppsResponse;
struct ListAppsResponseDefaultTypeInternal;
extern ListAppsResponseDefaultTypeInternal _ListAppsResponse_default_instance_;
class UpdateAppRequest;
struct UpdateAppRequestDefaultTypeInternal;
extern UpdateAppRequestDefaultTypeInternal _UpdateAppRequest_default_instance_;
class UpdateAppResponse;
struct UpdateAppResponseDefaultTypeInternal;
extern UpdateAppResponseDefaultTypeInternal _UpdateAppResponse_default_instance_;
class UpdateProjectRequest;
struct UpdateProjectRequestDefaultTypeInternal;
extern UpdateProjectRequestDefaultTypeInternal _UpdateProjectRequest_default_instance_;
class UpdateProjectResponse;
struct UpdateProjectResponseDefaultTypeInternal;
extern UpdateProjectResponseDefaultTypeInternal _UpdateProjectResponse_default_instance_;
class UploadTrainingDataRequest;
struct UploadTrainingDataRequestDefaultTypeInternal;
extern UploadTrainingDataRequestDefaultTypeInternal _UploadTrainingDataRequest_default_instance_;
class UploadTrainingDataResponse;
struct UploadTrainingDataResponseDefaultTypeInternal;
extern UploadTrainingDataResponseDefaultTypeInternal _UploadTrainingDataResponse_default_instance_;
}  // namespace v1
}  // namespace config
}  // namespace speechly
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace speechly {
namespace config {
namespace v1 {
enum UploadTrainingDataRequest_ContentType : int {
  UploadTrainingDataRequest_ContentType_CONTENT_TYPE_UNSPECIFIED = 0,
  UploadTrainingDataRequest_ContentType_CONTENT_TYPE_YAML = 1,
  UploadTrainingDataRequest_ContentType_CONTENT_TYPE_TAR = 2,
  UploadTrainingDataRequest_ContentType_UploadTrainingDataRequest_ContentType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UploadTrainingDataRequest_ContentType_UploadTrainingDataRequest_ContentType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UploadTrainingDataRequest_ContentType_IsValid(int value);
constexpr UploadTrainingDataRequest_ContentType UploadTrainingDataRequest_ContentType_ContentType_MIN = static_cast<UploadTrainingDataRequest_ContentType>(0);
constexpr UploadTrainingDataRequest_ContentType UploadTrainingDataRequest_ContentType_ContentType_MAX = static_cast<UploadTrainingDataRequest_ContentType>(2);
constexpr int UploadTrainingDataRequest_ContentType_ContentType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UploadTrainingDataRequest_ContentType_descriptor();
template <typename T>
const std::string& UploadTrainingDataRequest_ContentType_Name(T value) {
  static_assert(std::is_same<T, UploadTrainingDataRequest_ContentType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContentType_Name().");
  return UploadTrainingDataRequest_ContentType_Name(static_cast<UploadTrainingDataRequest_ContentType>(value));
}
template <>
inline const std::string& UploadTrainingDataRequest_ContentType_Name(UploadTrainingDataRequest_ContentType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UploadTrainingDataRequest_ContentType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UploadTrainingDataRequest_ContentType_Parse(absl::string_view name, UploadTrainingDataRequest_ContentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UploadTrainingDataRequest_ContentType>(
      UploadTrainingDataRequest_ContentType_descriptor(), name, value);
}
enum DownloadCurrentTrainingDataResponse_ContentType : int {
  DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_UNSPECIFIED = 0,
  DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_YAML = 1,
  DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_TAR = 2,
  DownloadCurrentTrainingDataResponse_ContentType_DownloadCurrentTrainingDataResponse_ContentType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DownloadCurrentTrainingDataResponse_ContentType_DownloadCurrentTrainingDataResponse_ContentType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DownloadCurrentTrainingDataResponse_ContentType_IsValid(int value);
constexpr DownloadCurrentTrainingDataResponse_ContentType DownloadCurrentTrainingDataResponse_ContentType_ContentType_MIN = static_cast<DownloadCurrentTrainingDataResponse_ContentType>(0);
constexpr DownloadCurrentTrainingDataResponse_ContentType DownloadCurrentTrainingDataResponse_ContentType_ContentType_MAX = static_cast<DownloadCurrentTrainingDataResponse_ContentType>(2);
constexpr int DownloadCurrentTrainingDataResponse_ContentType_ContentType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DownloadCurrentTrainingDataResponse_ContentType_descriptor();
template <typename T>
const std::string& DownloadCurrentTrainingDataResponse_ContentType_Name(T value) {
  static_assert(std::is_same<T, DownloadCurrentTrainingDataResponse_ContentType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContentType_Name().");
  return DownloadCurrentTrainingDataResponse_ContentType_Name(static_cast<DownloadCurrentTrainingDataResponse_ContentType>(value));
}
template <>
inline const std::string& DownloadCurrentTrainingDataResponse_ContentType_Name(DownloadCurrentTrainingDataResponse_ContentType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DownloadCurrentTrainingDataResponse_ContentType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DownloadCurrentTrainingDataResponse_ContentType_Parse(absl::string_view name, DownloadCurrentTrainingDataResponse_ContentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DownloadCurrentTrainingDataResponse_ContentType>(
      DownloadCurrentTrainingDataResponse_ContentType_descriptor(), name, value);
}
enum App_Status : int {
  App_Status_STATUS_UNSPECIFIED = 0,
  App_Status_STATUS_NEW = 1,
  App_Status_STATUS_TRAINING = 2,
  App_Status_STATUS_TRAINED = 3,
  App_Status_STATUS_FAILED = 4,
  App_Status_STATUS_INACTIVE = 5,
  App_Status_STATUS_DELETED = 6,
  App_Status_App_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  App_Status_App_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool App_Status_IsValid(int value);
constexpr App_Status App_Status_Status_MIN = static_cast<App_Status>(0);
constexpr App_Status App_Status_Status_MAX = static_cast<App_Status>(6);
constexpr int App_Status_Status_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
App_Status_descriptor();
template <typename T>
const std::string& App_Status_Name(T value) {
  static_assert(std::is_same<T, App_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return App_Status_Name(static_cast<App_Status>(value));
}
template <>
inline const std::string& App_Status_Name(App_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<App_Status_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool App_Status_Parse(absl::string_view name, App_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<App_Status>(
      App_Status_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class GetProjectRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectRequest) */ {
 public:
  inline GetProjectRequest() : GetProjectRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProjectRequest(::google::protobuf::internal::ConstantInitialized);

  GetProjectRequest(const GetProjectRequest& from);
  GetProjectRequest(GetProjectRequest&& from) noexcept
    : GetProjectRequest() {
    *this = ::std::move(from);
  }

  inline GetProjectRequest& operator=(const GetProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectRequest& operator=(GetProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectRequest* internal_default_instance() {
    return reinterpret_cast<const GetProjectRequest*>(
               &_GetProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetProjectRequest& a, GetProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProjectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProjectRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetProjectRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetProjectRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.GetProjectRequest";
  }
  protected:
  explicit GetProjectRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class GetProjectResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectResponse) */ {
 public:
  inline GetProjectResponse() : GetProjectResponse(nullptr) {}
  ~GetProjectResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProjectResponse(::google::protobuf::internal::ConstantInitialized);

  GetProjectResponse(const GetProjectResponse& from);
  GetProjectResponse(GetProjectResponse&& from) noexcept
    : GetProjectResponse() {
    *this = ::std::move(from);
  }

  inline GetProjectResponse& operator=(const GetProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectResponse& operator=(GetProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectResponse* internal_default_instance() {
    return reinterpret_cast<const GetProjectResponse*>(
               &_GetProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetProjectResponse& a, GetProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProjectResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProjectResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProjectResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetProjectResponse& from) {
    GetProjectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.GetProjectResponse";
  }
  protected:
  explicit GetProjectResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kProjectNamesFieldNumber = 2,
  };
  // repeated string project = 1;
  int project_size() const;
  private:
  int _internal_project_size() const;

  public:
  void clear_project() ;
  const std::string& project(int index) const;
  std::string* mutable_project(int index);
  void set_project(int index, const std::string& value);
  void set_project(int index, std::string&& value);
  void set_project(int index, const char* value);
  void set_project(int index, const char* value, std::size_t size);
  void set_project(int index, absl::string_view value);
  std::string* add_project();
  void add_project(const std::string& value);
  void add_project(std::string&& value);
  void add_project(const char* value);
  void add_project(const char* value, std::size_t size);
  void add_project(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& project() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_project();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_project() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_project();

  public:
  // repeated string project_names = 2;
  int project_names_size() const;
  private:
  int _internal_project_names_size() const;

  public:
  void clear_project_names() ;
  const std::string& project_names(int index) const;
  std::string* mutable_project_names(int index);
  void set_project_names(int index, const std::string& value);
  void set_project_names(int index, std::string&& value);
  void set_project_names(int index, const char* value);
  void set_project_names(int index, const char* value, std::size_t size);
  void set_project_names(int index, absl::string_view value);
  std::string* add_project_names();
  void add_project_names(const std::string& value);
  void add_project_names(std::string&& value);
  void add_project_names(const char* value);
  void add_project_names(const char* value, std::size_t size);
  void add_project_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& project_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_project_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_project_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_project_names();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 66, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> project_;
    ::google::protobuf::RepeatedPtrField<std::string> project_names_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class CreateProjectRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.CreateProjectRequest) */ {
 public:
  inline CreateProjectRequest() : CreateProjectRequest(nullptr) {}
  ~CreateProjectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateProjectRequest(::google::protobuf::internal::ConstantInitialized);

  CreateProjectRequest(const CreateProjectRequest& from);
  CreateProjectRequest(CreateProjectRequest&& from) noexcept
    : CreateProjectRequest() {
    *this = ::std::move(from);
  }

  inline CreateProjectRequest& operator=(const CreateProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProjectRequest& operator=(CreateProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProjectRequest* internal_default_instance() {
    return reinterpret_cast<const CreateProjectRequest*>(
               &_CreateProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateProjectRequest& a, CreateProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProjectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateProjectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateProjectRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateProjectRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateProjectRequest& from) {
    CreateProjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProjectRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.CreateProjectRequest";
  }
  protected:
  explicit CreateProjectRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.CreateProjectRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class CreateProjectResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.CreateProjectResponse) */ {
 public:
  inline CreateProjectResponse() : CreateProjectResponse(nullptr) {}
  ~CreateProjectResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateProjectResponse(::google::protobuf::internal::ConstantInitialized);

  CreateProjectResponse(const CreateProjectResponse& from);
  CreateProjectResponse(CreateProjectResponse&& from) noexcept
    : CreateProjectResponse() {
    *this = ::std::move(from);
  }

  inline CreateProjectResponse& operator=(const CreateProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProjectResponse& operator=(CreateProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProjectResponse* internal_default_instance() {
    return reinterpret_cast<const CreateProjectResponse*>(
               &_CreateProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateProjectResponse& a, CreateProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProjectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateProjectResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateProjectResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateProjectResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateProjectResponse& from) {
    CreateProjectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProjectResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.CreateProjectResponse";
  }
  protected:
  explicit CreateProjectResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string project = 1;
  void clear_project() ;
  const std::string& project() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project(Arg_&& arg, Args_... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* ptr);

  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(
      const std::string& value);
  std::string* _internal_mutable_project();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.CreateProjectResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 60, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr project_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class UpdateProjectRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.UpdateProjectRequest) */ {
 public:
  inline UpdateProjectRequest() : UpdateProjectRequest(nullptr) {}
  ~UpdateProjectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateProjectRequest(::google::protobuf::internal::ConstantInitialized);

  UpdateProjectRequest(const UpdateProjectRequest& from);
  UpdateProjectRequest(UpdateProjectRequest&& from) noexcept
    : UpdateProjectRequest() {
    *this = ::std::move(from);
  }

  inline UpdateProjectRequest& operator=(const UpdateProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateProjectRequest& operator=(UpdateProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateProjectRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateProjectRequest*>(
               &_UpdateProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpdateProjectRequest& a, UpdateProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateProjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateProjectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateProjectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateProjectRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateProjectRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateProjectRequest& from) {
    UpdateProjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateProjectRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.UpdateProjectRequest";
  }
  protected:
  explicit UpdateProjectRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string project = 1;
  void clear_project() ;
  const std::string& project() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project(Arg_&& arg, Args_... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* ptr);

  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(
      const std::string& value);
  std::string* _internal_mutable_project();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.UpdateProjectRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 59, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr project_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class UpdateProjectResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.config.v1.UpdateProjectResponse) */ {
 public:
  inline UpdateProjectResponse() : UpdateProjectResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateProjectResponse(::google::protobuf::internal::ConstantInitialized);

  UpdateProjectResponse(const UpdateProjectResponse& from);
  UpdateProjectResponse(UpdateProjectResponse&& from) noexcept
    : UpdateProjectResponse() {
    *this = ::std::move(from);
  }

  inline UpdateProjectResponse& operator=(const UpdateProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateProjectResponse& operator=(UpdateProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateProjectResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateProjectResponse*>(
               &_UpdateProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateProjectResponse& a, UpdateProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateProjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateProjectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateProjectResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateProjectResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateProjectResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateProjectResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.UpdateProjectResponse";
  }
  protected:
  explicit UpdateProjectResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.UpdateProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class GetProjectParticipantsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectParticipantsRequest) */ {
 public:
  inline GetProjectParticipantsRequest() : GetProjectParticipantsRequest(nullptr) {}
  ~GetProjectParticipantsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProjectParticipantsRequest(::google::protobuf::internal::ConstantInitialized);

  GetProjectParticipantsRequest(const GetProjectParticipantsRequest& from);
  GetProjectParticipantsRequest(GetProjectParticipantsRequest&& from) noexcept
    : GetProjectParticipantsRequest() {
    *this = ::std::move(from);
  }

  inline GetProjectParticipantsRequest& operator=(const GetProjectParticipantsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectParticipantsRequest& operator=(GetProjectParticipantsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectParticipantsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectParticipantsRequest* internal_default_instance() {
    return reinterpret_cast<const GetProjectParticipantsRequest*>(
               &_GetProjectParticipantsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetProjectParticipantsRequest& a, GetProjectParticipantsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectParticipantsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectParticipantsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProjectParticipantsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProjectParticipantsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProjectParticipantsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetProjectParticipantsRequest& from) {
    GetProjectParticipantsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectParticipantsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.GetProjectParticipantsRequest";
  }
  protected:
  explicit GetProjectParticipantsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
  };
  // string project = 1;
  void clear_project() ;
  const std::string& project() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project(Arg_&& arg, Args_... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* ptr);

  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(
      const std::string& value);
  std::string* _internal_mutable_project();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectParticipantsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 64, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr project_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class GetProjectParticipantsResponse_Participant final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectParticipantsResponse.Participant) */ {
 public:
  inline GetProjectParticipantsResponse_Participant() : GetProjectParticipantsResponse_Participant(nullptr) {}
  ~GetProjectParticipantsResponse_Participant() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProjectParticipantsResponse_Participant(::google::protobuf::internal::ConstantInitialized);

  GetProjectParticipantsResponse_Participant(const GetProjectParticipantsResponse_Participant& from);
  GetProjectParticipantsResponse_Participant(GetProjectParticipantsResponse_Participant&& from) noexcept
    : GetProjectParticipantsResponse_Participant() {
    *this = ::std::move(from);
  }

  inline GetProjectParticipantsResponse_Participant& operator=(const GetProjectParticipantsResponse_Participant& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectParticipantsResponse_Participant& operator=(GetProjectParticipantsResponse_Participant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectParticipantsResponse_Participant& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectParticipantsResponse_Participant* internal_default_instance() {
    return reinterpret_cast<const GetProjectParticipantsResponse_Participant*>(
               &_GetProjectParticipantsResponse_Participant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetProjectParticipantsResponse_Participant& a, GetProjectParticipantsResponse_Participant& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectParticipantsResponse_Participant* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectParticipantsResponse_Participant* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProjectParticipantsResponse_Participant* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProjectParticipantsResponse_Participant>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProjectParticipantsResponse_Participant& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetProjectParticipantsResponse_Participant& from) {
    GetProjectParticipantsResponse_Participant::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectParticipantsResponse_Participant* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.GetProjectParticipantsResponse.Participant";
  }
  protected:
  explicit GetProjectParticipantsResponse_Participant(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEmailFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string email = 2;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string id = 3;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectParticipantsResponse.Participant)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 81, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class GetProjectParticipantsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetProjectParticipantsResponse) */ {
 public:
  inline GetProjectParticipantsResponse() : GetProjectParticipantsResponse(nullptr) {}
  ~GetProjectParticipantsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProjectParticipantsResponse(::google::protobuf::internal::ConstantInitialized);

  GetProjectParticipantsResponse(const GetProjectParticipantsResponse& from);
  GetProjectParticipantsResponse(GetProjectParticipantsResponse&& from) noexcept
    : GetProjectParticipantsResponse() {
    *this = ::std::move(from);
  }

  inline GetProjectParticipantsResponse& operator=(const GetProjectParticipantsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectParticipantsResponse& operator=(GetProjectParticipantsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectParticipantsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectParticipantsResponse* internal_default_instance() {
    return reinterpret_cast<const GetProjectParticipantsResponse*>(
               &_GetProjectParticipantsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetProjectParticipantsResponse& a, GetProjectParticipantsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectParticipantsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectParticipantsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProjectParticipantsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProjectParticipantsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProjectParticipantsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetProjectParticipantsResponse& from) {
    GetProjectParticipantsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectParticipantsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.GetProjectParticipantsResponse";
  }
  protected:
  explicit GetProjectParticipantsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetProjectParticipantsResponse_Participant Participant;

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantsFieldNumber = 1,
  };
  // repeated .speechly.config.v1.GetProjectParticipantsResponse.Participant participants = 1;
  int participants_size() const;
  private:
  int _internal_participants_size() const;

  public:
  void clear_participants() ;
  ::speechly::config::v1::GetProjectParticipantsResponse_Participant* mutable_participants(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant >*
      mutable_participants();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::config::v1::GetProjectParticipantsResponse_Participant>& _internal_participants() const;
  ::google::protobuf::RepeatedPtrField<::speechly::config::v1::GetProjectParticipantsResponse_Participant>* _internal_mutable_participants();
  public:
  const ::speechly::config::v1::GetProjectParticipantsResponse_Participant& participants(int index) const;
  ::speechly::config::v1::GetProjectParticipantsResponse_Participant* add_participants();
  const ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant >&
      participants() const;
  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetProjectParticipantsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant > participants_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class InviteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.InviteRequest) */ {
 public:
  inline InviteRequest() : InviteRequest(nullptr) {}
  ~InviteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InviteRequest(::google::protobuf::internal::ConstantInitialized);

  InviteRequest(const InviteRequest& from);
  InviteRequest(InviteRequest&& from) noexcept
    : InviteRequest() {
    *this = ::std::move(from);
  }

  inline InviteRequest& operator=(const InviteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InviteRequest& operator=(InviteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InviteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InviteRequest* internal_default_instance() {
    return reinterpret_cast<const InviteRequest*>(
               &_InviteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InviteRequest& a, InviteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InviteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InviteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InviteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InviteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InviteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InviteRequest& from) {
    InviteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InviteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.InviteRequest";
  }
  protected:
  explicit InviteRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
  };
  // string project = 1;
  void clear_project() ;
  const std::string& project() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project(Arg_&& arg, Args_... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* ptr);

  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(
      const std::string& value);
  std::string* _internal_mutable_project();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.InviteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr project_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class InviteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.InviteResponse) */ {
 public:
  inline InviteResponse() : InviteResponse(nullptr) {}
  ~InviteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InviteResponse(::google::protobuf::internal::ConstantInitialized);

  InviteResponse(const InviteResponse& from);
  InviteResponse(InviteResponse&& from) noexcept
    : InviteResponse() {
    *this = ::std::move(from);
  }

  inline InviteResponse& operator=(const InviteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InviteResponse& operator=(InviteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InviteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InviteResponse* internal_default_instance() {
    return reinterpret_cast<const InviteResponse*>(
               &_InviteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InviteResponse& a, InviteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InviteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InviteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InviteResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InviteResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InviteResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InviteResponse& from) {
    InviteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InviteResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.InviteResponse";
  }
  protected:
  explicit InviteResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvitationTokenFieldNumber = 1,
  };
  // string invitation_token = 1;
  void clear_invitation_token() ;
  const std::string& invitation_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_invitation_token(Arg_&& arg, Args_... args);
  std::string* mutable_invitation_token();
  PROTOBUF_NODISCARD std::string* release_invitation_token();
  void set_allocated_invitation_token(std::string* ptr);

  private:
  const std::string& _internal_invitation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitation_token(
      const std::string& value);
  std::string* _internal_mutable_invitation_token();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.InviteResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 58, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr invitation_token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class JoinProjectRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.JoinProjectRequest) */ {
 public:
  inline JoinProjectRequest() : JoinProjectRequest(nullptr) {}
  ~JoinProjectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JoinProjectRequest(::google::protobuf::internal::ConstantInitialized);

  JoinProjectRequest(const JoinProjectRequest& from);
  JoinProjectRequest(JoinProjectRequest&& from) noexcept
    : JoinProjectRequest() {
    *this = ::std::move(from);
  }

  inline JoinProjectRequest& operator=(const JoinProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinProjectRequest& operator=(JoinProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinProjectRequest* internal_default_instance() {
    return reinterpret_cast<const JoinProjectRequest*>(
               &_JoinProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(JoinProjectRequest& a, JoinProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinProjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinProjectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinProjectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinProjectRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinProjectRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JoinProjectRequest& from) {
    JoinProjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinProjectRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.JoinProjectRequest";
  }
  protected:
  explicit JoinProjectRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvitationTokenFieldNumber = 1,
  };
  // string invitation_token = 1;
  void clear_invitation_token() ;
  const std::string& invitation_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_invitation_token(Arg_&& arg, Args_... args);
  std::string* mutable_invitation_token();
  PROTOBUF_NODISCARD std::string* release_invitation_token();
  void set_allocated_invitation_token(std::string* ptr);

  private:
  const std::string& _internal_invitation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitation_token(
      const std::string& value);
  std::string* _internal_mutable_invitation_token();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.JoinProjectRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 62, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr invitation_token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class JoinProjectResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.config.v1.JoinProjectResponse) */ {
 public:
  inline JoinProjectResponse() : JoinProjectResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JoinProjectResponse(::google::protobuf::internal::ConstantInitialized);

  JoinProjectResponse(const JoinProjectResponse& from);
  JoinProjectResponse(JoinProjectResponse&& from) noexcept
    : JoinProjectResponse() {
    *this = ::std::move(from);
  }

  inline JoinProjectResponse& operator=(const JoinProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinProjectResponse& operator=(JoinProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinProjectResponse* internal_default_instance() {
    return reinterpret_cast<const JoinProjectResponse*>(
               &_JoinProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(JoinProjectResponse& a, JoinProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinProjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinProjectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinProjectResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinProjectResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const JoinProjectResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const JoinProjectResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.JoinProjectResponse";
  }
  protected:
  explicit JoinProjectResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.JoinProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class ListAppsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.ListAppsRequest) */ {
 public:
  inline ListAppsRequest() : ListAppsRequest(nullptr) {}
  ~ListAppsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListAppsRequest(::google::protobuf::internal::ConstantInitialized);

  ListAppsRequest(const ListAppsRequest& from);
  ListAppsRequest(ListAppsRequest&& from) noexcept
    : ListAppsRequest() {
    *this = ::std::move(from);
  }

  inline ListAppsRequest& operator=(const ListAppsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsRequest& operator=(ListAppsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsRequest* internal_default_instance() {
    return reinterpret_cast<const ListAppsRequest*>(
               &_ListAppsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListAppsRequest& a, ListAppsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAppsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAppsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAppsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAppsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListAppsRequest& from) {
    ListAppsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAppsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.ListAppsRequest";
  }
  protected:
  explicit ListAppsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
  };
  // string project = 1;
  void clear_project() ;
  const std::string& project() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project(Arg_&& arg, Args_... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* ptr);

  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(
      const std::string& value);
  std::string* _internal_mutable_project();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.ListAppsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr project_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class ListAppsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.ListAppsResponse) */ {
 public:
  inline ListAppsResponse() : ListAppsResponse(nullptr) {}
  ~ListAppsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListAppsResponse(::google::protobuf::internal::ConstantInitialized);

  ListAppsResponse(const ListAppsResponse& from);
  ListAppsResponse(ListAppsResponse&& from) noexcept
    : ListAppsResponse() {
    *this = ::std::move(from);
  }

  inline ListAppsResponse& operator=(const ListAppsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsResponse& operator=(ListAppsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAppsResponse*>(
               &_ListAppsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListAppsResponse& a, ListAppsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAppsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAppsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAppsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAppsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListAppsResponse& from) {
    ListAppsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAppsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.ListAppsResponse";
  }
  protected:
  explicit ListAppsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppsFieldNumber = 1,
  };
  // repeated .speechly.config.v1.App apps = 1;
  int apps_size() const;
  private:
  int _internal_apps_size() const;

  public:
  void clear_apps() ;
  ::speechly::config::v1::App* mutable_apps(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::App >*
      mutable_apps();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::config::v1::App>& _internal_apps() const;
  ::google::protobuf::RepeatedPtrField<::speechly::config::v1::App>* _internal_mutable_apps();
  public:
  const ::speechly::config::v1::App& apps(int index) const;
  ::speechly::config::v1::App* add_apps();
  const ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::App >&
      apps() const;
  // @@protoc_insertion_point(class_scope:speechly.config.v1.ListAppsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::App > apps_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class GetAppRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetAppRequest) */ {
 public:
  inline GetAppRequest() : GetAppRequest(nullptr) {}
  ~GetAppRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAppRequest(::google::protobuf::internal::ConstantInitialized);

  GetAppRequest(const GetAppRequest& from);
  GetAppRequest(GetAppRequest&& from) noexcept
    : GetAppRequest() {
    *this = ::std::move(from);
  }

  inline GetAppRequest& operator=(const GetAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppRequest& operator=(GetAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppRequest* internal_default_instance() {
    return reinterpret_cast<const GetAppRequest*>(
               &_GetAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetAppRequest& a, GetAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetAppRequest& from) {
    GetAppRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.GetAppRequest";
  }
  protected:
  explicit GetAppRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
  };
  // string app_id = 1;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetAppRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class GetAppResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.GetAppResponse) */ {
 public:
  inline GetAppResponse() : GetAppResponse(nullptr) {}
  ~GetAppResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAppResponse(::google::protobuf::internal::ConstantInitialized);

  GetAppResponse(const GetAppResponse& from);
  GetAppResponse(GetAppResponse&& from) noexcept
    : GetAppResponse() {
    *this = ::std::move(from);
  }

  inline GetAppResponse& operator=(const GetAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppResponse& operator=(GetAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppResponse* internal_default_instance() {
    return reinterpret_cast<const GetAppResponse*>(
               &_GetAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetAppResponse& a, GetAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAppResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAppResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetAppResponse& from) {
    GetAppResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.GetAppResponse";
  }
  protected:
  explicit GetAppResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
  };
  // .speechly.config.v1.App app = 1;
  bool has_app() const;
  void clear_app() ;
  const ::speechly::config::v1::App& app() const;
  PROTOBUF_NODISCARD ::speechly::config::v1::App* release_app();
  ::speechly::config::v1::App* mutable_app();
  void set_allocated_app(::speechly::config::v1::App* value);
  void unsafe_arena_set_allocated_app(::speechly::config::v1::App* value);
  ::speechly::config::v1::App* unsafe_arena_release_app();

  private:
  const ::speechly::config::v1::App& _internal_app() const;
  ::speechly::config::v1::App* _internal_mutable_app();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.GetAppResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::speechly::config::v1::App* app_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class CreateAppRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.CreateAppRequest) */ {
 public:
  inline CreateAppRequest() : CreateAppRequest(nullptr) {}
  ~CreateAppRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateAppRequest(::google::protobuf::internal::ConstantInitialized);

  CreateAppRequest(const CreateAppRequest& from);
  CreateAppRequest(CreateAppRequest&& from) noexcept
    : CreateAppRequest() {
    *this = ::std::move(from);
  }

  inline CreateAppRequest& operator=(const CreateAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAppRequest& operator=(CreateAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAppRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAppRequest*>(
               &_CreateAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateAppRequest& a, CreateAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAppRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateAppRequest& from) {
    CreateAppRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAppRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.CreateAppRequest";
  }
  protected:
  explicit CreateAppRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kAppFieldNumber = 2,
  };
  // string project = 1;
  void clear_project() ;
  const std::string& project() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project(Arg_&& arg, Args_... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* ptr);

  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(
      const std::string& value);
  std::string* _internal_mutable_project();

  public:
  // .speechly.config.v1.App app = 2;
  bool has_app() const;
  void clear_app() ;
  const ::speechly::config::v1::App& app() const;
  PROTOBUF_NODISCARD ::speechly::config::v1::App* release_app();
  ::speechly::config::v1::App* mutable_app();
  void set_allocated_app(::speechly::config::v1::App* value);
  void unsafe_arena_set_allocated_app(::speechly::config::v1::App* value);
  ::speechly::config::v1::App* unsafe_arena_release_app();

  private:
  const ::speechly::config::v1::App& _internal_app() const;
  ::speechly::config::v1::App* _internal_mutable_app();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.CreateAppRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 51, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr project_;
    ::speechly::config::v1::App* app_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class CreateAppResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.CreateAppResponse) */ {
 public:
  inline CreateAppResponse() : CreateAppResponse(nullptr) {}
  ~CreateAppResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateAppResponse(::google::protobuf::internal::ConstantInitialized);

  CreateAppResponse(const CreateAppResponse& from);
  CreateAppResponse(CreateAppResponse&& from) noexcept
    : CreateAppResponse() {
    *this = ::std::move(from);
  }

  inline CreateAppResponse& operator=(const CreateAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAppResponse& operator=(CreateAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAppResponse* internal_default_instance() {
    return reinterpret_cast<const CreateAppResponse*>(
               &_CreateAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CreateAppResponse& a, CreateAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAppResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAppResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAppResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAppResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateAppResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateAppResponse& from) {
    CreateAppResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAppResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.CreateAppResponse";
  }
  protected:
  explicit CreateAppResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
  };
  // .speechly.config.v1.App app = 1;
  bool has_app() const;
  void clear_app() ;
  const ::speechly::config::v1::App& app() const;
  PROTOBUF_NODISCARD ::speechly::config::v1::App* release_app();
  ::speechly::config::v1::App* mutable_app();
  void set_allocated_app(::speechly::config::v1::App* value);
  void unsafe_arena_set_allocated_app(::speechly::config::v1::App* value);
  ::speechly::config::v1::App* unsafe_arena_release_app();

  private:
  const ::speechly::config::v1::App& _internal_app() const;
  ::speechly::config::v1::App* _internal_mutable_app();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.CreateAppResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::speechly::config::v1::App* app_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class UpdateAppRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.UpdateAppRequest) */ {
 public:
  inline UpdateAppRequest() : UpdateAppRequest(nullptr) {}
  ~UpdateAppRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateAppRequest(::google::protobuf::internal::ConstantInitialized);

  UpdateAppRequest(const UpdateAppRequest& from);
  UpdateAppRequest(UpdateAppRequest&& from) noexcept
    : UpdateAppRequest() {
    *this = ::std::move(from);
  }

  inline UpdateAppRequest& operator=(const UpdateAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAppRequest& operator=(UpdateAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAppRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateAppRequest*>(
               &_UpdateAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateAppRequest& a, UpdateAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAppRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateAppRequest& from) {
    UpdateAppRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAppRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.UpdateAppRequest";
  }
  protected:
  explicit UpdateAppRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
  };
  // .speechly.config.v1.App app = 1;
  bool has_app() const;
  void clear_app() ;
  const ::speechly::config::v1::App& app() const;
  PROTOBUF_NODISCARD ::speechly::config::v1::App* release_app();
  ::speechly::config::v1::App* mutable_app();
  void set_allocated_app(::speechly::config::v1::App* value);
  void unsafe_arena_set_allocated_app(::speechly::config::v1::App* value);
  ::speechly::config::v1::App* unsafe_arena_release_app();

  private:
  const ::speechly::config::v1::App& _internal_app() const;
  ::speechly::config::v1::App* _internal_mutable_app();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.UpdateAppRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::speechly::config::v1::App* app_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class UpdateAppResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.config.v1.UpdateAppResponse) */ {
 public:
  inline UpdateAppResponse() : UpdateAppResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateAppResponse(::google::protobuf::internal::ConstantInitialized);

  UpdateAppResponse(const UpdateAppResponse& from);
  UpdateAppResponse(UpdateAppResponse&& from) noexcept
    : UpdateAppResponse() {
    *this = ::std::move(from);
  }

  inline UpdateAppResponse& operator=(const UpdateAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAppResponse& operator=(UpdateAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAppResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateAppResponse*>(
               &_UpdateAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateAppResponse& a, UpdateAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAppResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAppResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAppResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateAppResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateAppResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateAppResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.UpdateAppResponse";
  }
  protected:
  explicit UpdateAppResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.UpdateAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class DeleteAppRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.DeleteAppRequest) */ {
 public:
  inline DeleteAppRequest() : DeleteAppRequest(nullptr) {}
  ~DeleteAppRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteAppRequest(::google::protobuf::internal::ConstantInitialized);

  DeleteAppRequest(const DeleteAppRequest& from);
  DeleteAppRequest(DeleteAppRequest&& from) noexcept
    : DeleteAppRequest() {
    *this = ::std::move(from);
  }

  inline DeleteAppRequest& operator=(const DeleteAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAppRequest& operator=(DeleteAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAppRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteAppRequest*>(
               &_DeleteAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DeleteAppRequest& a, DeleteAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAppRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteAppRequest& from) {
    DeleteAppRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAppRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.DeleteAppRequest";
  }
  protected:
  explicit DeleteAppRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
  };
  // string app_id = 1;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.DeleteAppRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class DeleteAppResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.config.v1.DeleteAppResponse) */ {
 public:
  inline DeleteAppResponse() : DeleteAppResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteAppResponse(::google::protobuf::internal::ConstantInitialized);

  DeleteAppResponse(const DeleteAppResponse& from);
  DeleteAppResponse(DeleteAppResponse&& from) noexcept
    : DeleteAppResponse() {
    *this = ::std::move(from);
  }

  inline DeleteAppResponse& operator=(const DeleteAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAppResponse& operator=(DeleteAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAppResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteAppResponse*>(
               &_DeleteAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DeleteAppResponse& a, DeleteAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAppResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAppResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAppResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAppResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteAppResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteAppResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.DeleteAppResponse";
  }
  protected:
  explicit DeleteAppResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.DeleteAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class UploadTrainingDataRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.UploadTrainingDataRequest) */ {
 public:
  inline UploadTrainingDataRequest() : UploadTrainingDataRequest(nullptr) {}
  ~UploadTrainingDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UploadTrainingDataRequest(::google::protobuf::internal::ConstantInitialized);

  UploadTrainingDataRequest(const UploadTrainingDataRequest& from);
  UploadTrainingDataRequest(UploadTrainingDataRequest&& from) noexcept
    : UploadTrainingDataRequest() {
    *this = ::std::move(from);
  }

  inline UploadTrainingDataRequest& operator=(const UploadTrainingDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadTrainingDataRequest& operator=(UploadTrainingDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadTrainingDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadTrainingDataRequest* internal_default_instance() {
    return reinterpret_cast<const UploadTrainingDataRequest*>(
               &_UploadTrainingDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UploadTrainingDataRequest& a, UploadTrainingDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadTrainingDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadTrainingDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadTrainingDataRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadTrainingDataRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UploadTrainingDataRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UploadTrainingDataRequest& from) {
    UploadTrainingDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadTrainingDataRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.UploadTrainingDataRequest";
  }
  protected:
  explicit UploadTrainingDataRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ContentType = UploadTrainingDataRequest_ContentType;
  static constexpr ContentType CONTENT_TYPE_UNSPECIFIED = UploadTrainingDataRequest_ContentType_CONTENT_TYPE_UNSPECIFIED;
  static constexpr ContentType CONTENT_TYPE_YAML = UploadTrainingDataRequest_ContentType_CONTENT_TYPE_YAML;
  static constexpr ContentType CONTENT_TYPE_TAR = UploadTrainingDataRequest_ContentType_CONTENT_TYPE_TAR;
  static inline bool ContentType_IsValid(int value) {
    return UploadTrainingDataRequest_ContentType_IsValid(value);
  }
  static constexpr ContentType ContentType_MIN = UploadTrainingDataRequest_ContentType_ContentType_MIN;
  static constexpr ContentType ContentType_MAX = UploadTrainingDataRequest_ContentType_ContentType_MAX;
  static constexpr int ContentType_ARRAYSIZE = UploadTrainingDataRequest_ContentType_ContentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ContentType_descriptor() {
    return UploadTrainingDataRequest_ContentType_descriptor();
  }
  template <typename T>
  static inline const std::string& ContentType_Name(T value) {
    return UploadTrainingDataRequest_ContentType_Name(value);
  }
  static inline bool ContentType_Parse(absl::string_view name, ContentType* value) {
    return UploadTrainingDataRequest_ContentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kDataChunkFieldNumber = 2,
    kContentTypeFieldNumber = 3,
  };
  // string app_id = 1;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // bytes data_chunk = 2;
  void clear_data_chunk() ;
  const std::string& data_chunk() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_chunk(Arg_&& arg, Args_... args);
  std::string* mutable_data_chunk();
  PROTOBUF_NODISCARD std::string* release_data_chunk();
  void set_allocated_data_chunk(std::string* ptr);

  private:
  const std::string& _internal_data_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_chunk(
      const std::string& value);
  std::string* _internal_mutable_data_chunk();

  public:
  // .speechly.config.v1.UploadTrainingDataRequest.ContentType content_type = 3;
  void clear_content_type() ;
  ::speechly::config::v1::UploadTrainingDataRequest_ContentType content_type() const;
  void set_content_type(::speechly::config::v1::UploadTrainingDataRequest_ContentType value);

  private:
  ::speechly::config::v1::UploadTrainingDataRequest_ContentType _internal_content_type() const;
  void _internal_set_content_type(::speechly::config::v1::UploadTrainingDataRequest_ContentType value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.UploadTrainingDataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 59, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr data_chunk_;
    int content_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class UploadTrainingDataResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.config.v1.UploadTrainingDataResponse) */ {
 public:
  inline UploadTrainingDataResponse() : UploadTrainingDataResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UploadTrainingDataResponse(::google::protobuf::internal::ConstantInitialized);

  UploadTrainingDataResponse(const UploadTrainingDataResponse& from);
  UploadTrainingDataResponse(UploadTrainingDataResponse&& from) noexcept
    : UploadTrainingDataResponse() {
    *this = ::std::move(from);
  }

  inline UploadTrainingDataResponse& operator=(const UploadTrainingDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadTrainingDataResponse& operator=(UploadTrainingDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadTrainingDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadTrainingDataResponse* internal_default_instance() {
    return reinterpret_cast<const UploadTrainingDataResponse*>(
               &_UploadTrainingDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UploadTrainingDataResponse& a, UploadTrainingDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadTrainingDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadTrainingDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadTrainingDataResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadTrainingDataResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UploadTrainingDataResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UploadTrainingDataResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.UploadTrainingDataResponse";
  }
  protected:
  explicit UploadTrainingDataResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.config.v1.UploadTrainingDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class DownloadCurrentTrainingDataRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.DownloadCurrentTrainingDataRequest) */ {
 public:
  inline DownloadCurrentTrainingDataRequest() : DownloadCurrentTrainingDataRequest(nullptr) {}
  ~DownloadCurrentTrainingDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadCurrentTrainingDataRequest(::google::protobuf::internal::ConstantInitialized);

  DownloadCurrentTrainingDataRequest(const DownloadCurrentTrainingDataRequest& from);
  DownloadCurrentTrainingDataRequest(DownloadCurrentTrainingDataRequest&& from) noexcept
    : DownloadCurrentTrainingDataRequest() {
    *this = ::std::move(from);
  }

  inline DownloadCurrentTrainingDataRequest& operator=(const DownloadCurrentTrainingDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadCurrentTrainingDataRequest& operator=(DownloadCurrentTrainingDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadCurrentTrainingDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadCurrentTrainingDataRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadCurrentTrainingDataRequest*>(
               &_DownloadCurrentTrainingDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DownloadCurrentTrainingDataRequest& a, DownloadCurrentTrainingDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadCurrentTrainingDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadCurrentTrainingDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadCurrentTrainingDataRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadCurrentTrainingDataRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadCurrentTrainingDataRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadCurrentTrainingDataRequest& from) {
    DownloadCurrentTrainingDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadCurrentTrainingDataRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.DownloadCurrentTrainingDataRequest";
  }
  protected:
  explicit DownloadCurrentTrainingDataRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kConfigIdFieldNumber = 2,
  };
  // string app_id = 1;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string config_id = 2;
  void clear_config_id() ;
  const std::string& config_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_config_id(Arg_&& arg, Args_... args);
  std::string* mutable_config_id();
  PROTOBUF_NODISCARD std::string* release_config_id();
  void set_allocated_config_id(std::string* ptr);

  private:
  const std::string& _internal_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_id(
      const std::string& value);
  std::string* _internal_mutable_config_id();

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.DownloadCurrentTrainingDataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 77, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr config_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class DownloadCurrentTrainingDataResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.DownloadCurrentTrainingDataResponse) */ {
 public:
  inline DownloadCurrentTrainingDataResponse() : DownloadCurrentTrainingDataResponse(nullptr) {}
  ~DownloadCurrentTrainingDataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadCurrentTrainingDataResponse(::google::protobuf::internal::ConstantInitialized);

  DownloadCurrentTrainingDataResponse(const DownloadCurrentTrainingDataResponse& from);
  DownloadCurrentTrainingDataResponse(DownloadCurrentTrainingDataResponse&& from) noexcept
    : DownloadCurrentTrainingDataResponse() {
    *this = ::std::move(from);
  }

  inline DownloadCurrentTrainingDataResponse& operator=(const DownloadCurrentTrainingDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadCurrentTrainingDataResponse& operator=(DownloadCurrentTrainingDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadCurrentTrainingDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadCurrentTrainingDataResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadCurrentTrainingDataResponse*>(
               &_DownloadCurrentTrainingDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DownloadCurrentTrainingDataResponse& a, DownloadCurrentTrainingDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadCurrentTrainingDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadCurrentTrainingDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadCurrentTrainingDataResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadCurrentTrainingDataResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadCurrentTrainingDataResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadCurrentTrainingDataResponse& from) {
    DownloadCurrentTrainingDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadCurrentTrainingDataResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.DownloadCurrentTrainingDataResponse";
  }
  protected:
  explicit DownloadCurrentTrainingDataResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ContentType = DownloadCurrentTrainingDataResponse_ContentType;
  static constexpr ContentType CONTENT_TYPE_UNSPECIFIED = DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_UNSPECIFIED;
  static constexpr ContentType CONTENT_TYPE_YAML = DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_YAML;
  static constexpr ContentType CONTENT_TYPE_TAR = DownloadCurrentTrainingDataResponse_ContentType_CONTENT_TYPE_TAR;
  static inline bool ContentType_IsValid(int value) {
    return DownloadCurrentTrainingDataResponse_ContentType_IsValid(value);
  }
  static constexpr ContentType ContentType_MIN = DownloadCurrentTrainingDataResponse_ContentType_ContentType_MIN;
  static constexpr ContentType ContentType_MAX = DownloadCurrentTrainingDataResponse_ContentType_ContentType_MAX;
  static constexpr int ContentType_ARRAYSIZE = DownloadCurrentTrainingDataResponse_ContentType_ContentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ContentType_descriptor() {
    return DownloadCurrentTrainingDataResponse_ContentType_descriptor();
  }
  template <typename T>
  static inline const std::string& ContentType_Name(T value) {
    return DownloadCurrentTrainingDataResponse_ContentType_Name(value);
  }
  static inline bool ContentType_Parse(absl::string_view name, ContentType* value) {
    return DownloadCurrentTrainingDataResponse_ContentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataChunkFieldNumber = 1,
    kContentTypeFieldNumber = 2,
  };
  // bytes data_chunk = 1;
  void clear_data_chunk() ;
  const std::string& data_chunk() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_chunk(Arg_&& arg, Args_... args);
  std::string* mutable_data_chunk();
  PROTOBUF_NODISCARD std::string* release_data_chunk();
  void set_allocated_data_chunk(std::string* ptr);

  private:
  const std::string& _internal_data_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_chunk(
      const std::string& value);
  std::string* _internal_mutable_data_chunk();

  public:
  // .speechly.config.v1.DownloadCurrentTrainingDataResponse.ContentType content_type = 2;
  void clear_content_type() ;
  ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType content_type() const;
  void set_content_type(::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType value);

  private:
  ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType _internal_content_type() const;
  void _internal_set_content_type(::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.DownloadCurrentTrainingDataResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr data_chunk_;
    int content_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};// -------------------------------------------------------------------

class App final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.config.v1.App) */ {
 public:
  inline App() : App(nullptr) {}
  ~App() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR App(::google::protobuf::internal::ConstantInitialized);

  App(const App& from);
  App(App&& from) noexcept
    : App() {
    *this = ::std::move(from);
  }

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  inline App& operator=(App&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const App& default_instance() {
    return *internal_default_instance();
  }
  static inline const App* internal_default_instance() {
    return reinterpret_cast<const App*>(
               &_App_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(App& a, App& b) {
    a.Swap(&b);
  }
  inline void Swap(App* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(App* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  App* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<App>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const App& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const App& from) {
    App::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(App* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.config.v1.App";
  }
  protected:
  explicit App(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Status = App_Status;
  static constexpr Status STATUS_UNSPECIFIED = App_Status_STATUS_UNSPECIFIED;
  static constexpr Status STATUS_NEW = App_Status_STATUS_NEW;
  static constexpr Status STATUS_TRAINING = App_Status_STATUS_TRAINING;
  static constexpr Status STATUS_TRAINED = App_Status_STATUS_TRAINED;
  static constexpr Status STATUS_FAILED = App_Status_STATUS_FAILED;
  static constexpr Status STATUS_INACTIVE = App_Status_STATUS_INACTIVE;
  static constexpr Status STATUS_DELETED = App_Status_STATUS_DELETED;
  static inline bool Status_IsValid(int value) {
    return App_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = App_Status_Status_MIN;
  static constexpr Status Status_MAX = App_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = App_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return App_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return App_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return App_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 10,
    kIdFieldNumber = 1,
    kLanguageFieldNumber = 2,
    kNameFieldNumber = 4,
    kErrorMsgFieldNumber = 6,
    kDeployedAtTimeFieldNumber = 11,
    kStatusFieldNumber = 3,
    kQueueSizeFieldNumber = 5,
    kEstimatedRemainingSecFieldNumber = 7,
    kEstimatedTrainingTimeSecFieldNumber = 8,
    kTrainingTimeSecFieldNumber = 9,
  };
  // repeated string tags = 10;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string language = 2;
  void clear_language() ;
  const std::string& language() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language(Arg_&& arg, Args_... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* ptr);

  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(
      const std::string& value);
  std::string* _internal_mutable_language();

  public:
  // string name = 4;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string error_msg = 6;
  void clear_error_msg() ;
  const std::string& error_msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_msg(Arg_&& arg, Args_... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* ptr);

  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(
      const std::string& value);
  std::string* _internal_mutable_error_msg();

  public:
  // .google.protobuf.Timestamp deployed_at_time = 11;
  bool has_deployed_at_time() const;
  void clear_deployed_at_time() ;
  const ::google::protobuf::Timestamp& deployed_at_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_deployed_at_time();
  ::google::protobuf::Timestamp* mutable_deployed_at_time();
  void set_allocated_deployed_at_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_deployed_at_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_deployed_at_time();

  private:
  const ::google::protobuf::Timestamp& _internal_deployed_at_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_deployed_at_time();

  public:
  // .speechly.config.v1.App.Status status = 3;
  void clear_status() ;
  ::speechly::config::v1::App_Status status() const;
  void set_status(::speechly::config::v1::App_Status value);

  private:
  ::speechly::config::v1::App_Status _internal_status() const;
  void _internal_set_status(::speechly::config::v1::App_Status value);

  public:
  // int32 queue_size = 5;
  void clear_queue_size() ;
  ::int32_t queue_size() const;
  void set_queue_size(::int32_t value);

  private:
  ::int32_t _internal_queue_size() const;
  void _internal_set_queue_size(::int32_t value);

  public:
  // int32 estimated_remaining_sec = 7;
  void clear_estimated_remaining_sec() ;
  ::int32_t estimated_remaining_sec() const;
  void set_estimated_remaining_sec(::int32_t value);

  private:
  ::int32_t _internal_estimated_remaining_sec() const;
  void _internal_set_estimated_remaining_sec(::int32_t value);

  public:
  // int32 estimated_training_time_sec = 8;
  void clear_estimated_training_time_sec() ;
  ::int32_t estimated_training_time_sec() const;
  void set_estimated_training_time_sec(::int32_t value);

  private:
  ::int32_t _internal_estimated_training_time_sec() const;
  void _internal_set_estimated_training_time_sec(::int32_t value);

  public:
  // int32 training_time_sec = 9;
  void clear_training_time_sec() ;
  ::int32_t training_time_sec() const;
  void set_training_time_sec(::int32_t value);

  private:
  ::int32_t _internal_training_time_sec() const;
  void _internal_set_training_time_sec(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.config.v1.App)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11, 1, 66, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr language_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr error_msg_;
    ::google::protobuf::Timestamp* deployed_at_time_;
    int status_;
    ::int32_t queue_size_;
    ::int32_t estimated_remaining_sec_;
    ::int32_t estimated_training_time_sec_;
    ::int32_t training_time_sec_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetProjectRequest

// -------------------------------------------------------------------

// GetProjectResponse

// repeated string project = 1;
inline int GetProjectResponse::_internal_project_size() const {
  return _internal_project().size();
}
inline int GetProjectResponse::project_size() const {
  return _internal_project_size();
}
inline void GetProjectResponse::clear_project() {
  _internal_mutable_project()->Clear();
}
inline std::string* GetProjectResponse::add_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_project()->Add();
  // @@protoc_insertion_point(field_add_mutable:speechly.config.v1.GetProjectResponse.project)
  return _s;
}
inline const std::string& GetProjectResponse::project(int index) const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectResponse.project)
  return _internal_project().Get(index);
}
inline std::string* GetProjectResponse::mutable_project(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectResponse.project)
  return _internal_mutable_project()->Mutable(index);
}
inline void GetProjectResponse::set_project(int index, const std::string& value) {
  _internal_mutable_project()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::set_project(int index, std::string&& value) {
  _internal_mutable_project()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::set_project(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_project()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::set_project(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_project()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::set_project(int index, absl::string_view value) {
  _internal_mutable_project()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::add_project(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::add_project(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::add_project(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::add_project(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speechly.config.v1.GetProjectResponse.project)
}
inline void GetProjectResponse::add_project(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:speechly.config.v1.GetProjectResponse.project)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetProjectResponse::project() const {
  // @@protoc_insertion_point(field_list:speechly.config.v1.GetProjectResponse.project)
  return _internal_project();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* GetProjectResponse::mutable_project() {
  // @@protoc_insertion_point(field_mutable_list:speechly.config.v1.GetProjectResponse.project)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_project();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetProjectResponse::_internal_project() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetProjectResponse::_internal_mutable_project() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.project_;
}

// repeated string project_names = 2;
inline int GetProjectResponse::_internal_project_names_size() const {
  return _internal_project_names().size();
}
inline int GetProjectResponse::project_names_size() const {
  return _internal_project_names_size();
}
inline void GetProjectResponse::clear_project_names() {
  _internal_mutable_project_names()->Clear();
}
inline std::string* GetProjectResponse::add_project_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_project_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:speechly.config.v1.GetProjectResponse.project_names)
  return _s;
}
inline const std::string& GetProjectResponse::project_names(int index) const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectResponse.project_names)
  return _internal_project_names().Get(index);
}
inline std::string* GetProjectResponse::mutable_project_names(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectResponse.project_names)
  return _internal_mutable_project_names()->Mutable(index);
}
inline void GetProjectResponse::set_project_names(int index, const std::string& value) {
  _internal_mutable_project_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::set_project_names(int index, std::string&& value) {
  _internal_mutable_project_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::set_project_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_project_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::set_project_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_project_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::set_project_names(int index, absl::string_view value) {
  _internal_mutable_project_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::add_project_names(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::add_project_names(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::add_project_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::add_project_names(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speechly.config.v1.GetProjectResponse.project_names)
}
inline void GetProjectResponse::add_project_names(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_project_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:speechly.config.v1.GetProjectResponse.project_names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetProjectResponse::project_names() const {
  // @@protoc_insertion_point(field_list:speechly.config.v1.GetProjectResponse.project_names)
  return _internal_project_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* GetProjectResponse::mutable_project_names() {
  // @@protoc_insertion_point(field_mutable_list:speechly.config.v1.GetProjectResponse.project_names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_project_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetProjectResponse::_internal_project_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetProjectResponse::_internal_mutable_project_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.project_names_;
}

// -------------------------------------------------------------------

// CreateProjectRequest

// string name = 1;
inline void CreateProjectRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateProjectRequest::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateProjectRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateProjectRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.CreateProjectRequest.name)
}
inline std::string* CreateProjectRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateProjectRequest.name)
  return _s;
}
inline const std::string& CreateProjectRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreateProjectRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateProjectRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateProjectRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateProjectRequest.name)
  return _impl_.name_.Release();
}
inline void CreateProjectRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateProjectRequest.name)
}

// -------------------------------------------------------------------

// CreateProjectResponse

// string project = 1;
inline void CreateProjectResponse::clear_project() {
  _impl_.project_.ClearToEmpty();
}
inline const std::string& CreateProjectResponse::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateProjectResponse.project)
  return _internal_project();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateProjectResponse::set_project(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.CreateProjectResponse.project)
}
inline std::string* CreateProjectResponse::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateProjectResponse.project)
  return _s;
}
inline const std::string& CreateProjectResponse::_internal_project() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_.Get();
}
inline void CreateProjectResponse::_internal_set_project(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::_internal_mutable_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::release_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateProjectResponse.project)
  return _impl_.project_.Release();
}
inline void CreateProjectResponse::set_allocated_project(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_.IsDefault()) {
          _impl_.project_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateProjectResponse.project)
}

// string name = 2;
inline void CreateProjectResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateProjectResponse::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateProjectResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateProjectResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.CreateProjectResponse.name)
}
inline std::string* CreateProjectResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateProjectResponse.name)
  return _s;
}
inline const std::string& CreateProjectResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreateProjectResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateProjectResponse.name)
  return _impl_.name_.Release();
}
inline void CreateProjectResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateProjectResponse.name)
}

// -------------------------------------------------------------------

// UpdateProjectRequest

// string project = 1;
inline void UpdateProjectRequest::clear_project() {
  _impl_.project_.ClearToEmpty();
}
inline const std::string& UpdateProjectRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UpdateProjectRequest.project)
  return _internal_project();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateProjectRequest::set_project(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.UpdateProjectRequest.project)
}
inline std::string* UpdateProjectRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UpdateProjectRequest.project)
  return _s;
}
inline const std::string& UpdateProjectRequest::_internal_project() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_.Get();
}
inline void UpdateProjectRequest::_internal_set_project(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateProjectRequest::_internal_mutable_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateProjectRequest::release_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.UpdateProjectRequest.project)
  return _impl_.project_.Release();
}
inline void UpdateProjectRequest::set_allocated_project(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_.IsDefault()) {
          _impl_.project_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UpdateProjectRequest.project)
}

// string name = 2;
inline void UpdateProjectRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateProjectRequest::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UpdateProjectRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateProjectRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.UpdateProjectRequest.name)
}
inline std::string* UpdateProjectRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UpdateProjectRequest.name)
  return _s;
}
inline const std::string& UpdateProjectRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void UpdateProjectRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateProjectRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateProjectRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.UpdateProjectRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateProjectRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UpdateProjectRequest.name)
}

// -------------------------------------------------------------------

// UpdateProjectResponse

// -------------------------------------------------------------------

// GetProjectParticipantsRequest

// string project = 1;
inline void GetProjectParticipantsRequest::clear_project() {
  _impl_.project_.ClearToEmpty();
}
inline const std::string& GetProjectParticipantsRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsRequest.project)
  return _internal_project();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProjectParticipantsRequest::set_project(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectParticipantsRequest.project)
}
inline std::string* GetProjectParticipantsRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsRequest.project)
  return _s;
}
inline const std::string& GetProjectParticipantsRequest::_internal_project() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_.Get();
}
inline void GetProjectParticipantsRequest::_internal_set_project(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsRequest::_internal_mutable_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_.Mutable( GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsRequest::release_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetProjectParticipantsRequest.project)
  return _impl_.project_.Release();
}
inline void GetProjectParticipantsRequest::set_allocated_project(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_.IsDefault()) {
          _impl_.project_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetProjectParticipantsRequest.project)
}

// -------------------------------------------------------------------

// GetProjectParticipantsResponse_Participant

// string name = 1;
inline void GetProjectParticipantsResponse_Participant::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetProjectParticipantsResponse_Participant::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProjectParticipantsResponse_Participant::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
}
inline std::string* GetProjectParticipantsResponse_Participant::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
  return _s;
}
inline const std::string& GetProjectParticipantsResponse_Participant::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetProjectParticipantsResponse_Participant::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
  return _impl_.name_.Release();
}
inline void GetProjectParticipantsResponse_Participant::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetProjectParticipantsResponse.Participant.name)
}

// string email = 2;
inline void GetProjectParticipantsResponse_Participant::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& GetProjectParticipantsResponse_Participant::email() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProjectParticipantsResponse_Participant::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
}
inline std::string* GetProjectParticipantsResponse_Participant::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
  return _s;
}
inline const std::string& GetProjectParticipantsResponse_Participant::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void GetProjectParticipantsResponse_Participant::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
  return _impl_.email_.Release();
}
inline void GetProjectParticipantsResponse_Participant::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetProjectParticipantsResponse.Participant.email)
}

// string id = 3;
inline void GetProjectParticipantsResponse_Participant::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetProjectParticipantsResponse_Participant::id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProjectParticipantsResponse_Participant::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
}
inline std::string* GetProjectParticipantsResponse_Participant::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
  return _s;
}
inline const std::string& GetProjectParticipantsResponse_Participant::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GetProjectParticipantsResponse_Participant::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetProjectParticipantsResponse_Participant::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
  return _impl_.id_.Release();
}
inline void GetProjectParticipantsResponse_Participant::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetProjectParticipantsResponse.Participant.id)
}

// -------------------------------------------------------------------

// GetProjectParticipantsResponse

// repeated .speechly.config.v1.GetProjectParticipantsResponse.Participant participants = 1;
inline int GetProjectParticipantsResponse::_internal_participants_size() const {
  return _internal_participants().size();
}
inline int GetProjectParticipantsResponse::participants_size() const {
  return _internal_participants_size();
}
inline void GetProjectParticipantsResponse::clear_participants() {
  _internal_mutable_participants()->Clear();
}
inline ::speechly::config::v1::GetProjectParticipantsResponse_Participant* GetProjectParticipantsResponse::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetProjectParticipantsResponse.participants)
  return _internal_mutable_participants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant >*
GetProjectParticipantsResponse::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:speechly.config.v1.GetProjectParticipantsResponse.participants)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_participants();
}
inline const ::speechly::config::v1::GetProjectParticipantsResponse_Participant& GetProjectParticipantsResponse::participants(int index) const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetProjectParticipantsResponse.participants)
    return _internal_participants().Get(index);
}
inline ::speechly::config::v1::GetProjectParticipantsResponse_Participant* GetProjectParticipantsResponse::add_participants() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::config::v1::GetProjectParticipantsResponse_Participant* _add = _internal_mutable_participants()->Add();
  // @@protoc_insertion_point(field_add:speechly.config.v1.GetProjectParticipantsResponse.participants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::GetProjectParticipantsResponse_Participant >&
GetProjectParticipantsResponse::participants() const {
  // @@protoc_insertion_point(field_list:speechly.config.v1.GetProjectParticipantsResponse.participants)
  return _internal_participants();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::config::v1::GetProjectParticipantsResponse_Participant>&
GetProjectParticipantsResponse::_internal_participants() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.participants_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::config::v1::GetProjectParticipantsResponse_Participant>*
GetProjectParticipantsResponse::_internal_mutable_participants() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.participants_;
}

// -------------------------------------------------------------------

// InviteRequest

// string project = 1;
inline void InviteRequest::clear_project() {
  _impl_.project_.ClearToEmpty();
}
inline const std::string& InviteRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.InviteRequest.project)
  return _internal_project();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InviteRequest::set_project(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.InviteRequest.project)
}
inline std::string* InviteRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.InviteRequest.project)
  return _s;
}
inline const std::string& InviteRequest::_internal_project() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_.Get();
}
inline void InviteRequest::_internal_set_project(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(value, GetArenaForAllocation());
}
inline std::string* InviteRequest::_internal_mutable_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_.Mutable( GetArenaForAllocation());
}
inline std::string* InviteRequest::release_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.InviteRequest.project)
  return _impl_.project_.Release();
}
inline void InviteRequest::set_allocated_project(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_.IsDefault()) {
          _impl_.project_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.InviteRequest.project)
}

// -------------------------------------------------------------------

// InviteResponse

// string invitation_token = 1;
inline void InviteResponse::clear_invitation_token() {
  _impl_.invitation_token_.ClearToEmpty();
}
inline const std::string& InviteResponse::invitation_token() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.InviteResponse.invitation_token)
  return _internal_invitation_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InviteResponse::set_invitation_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.invitation_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.InviteResponse.invitation_token)
}
inline std::string* InviteResponse::mutable_invitation_token() {
  std::string* _s = _internal_mutable_invitation_token();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.InviteResponse.invitation_token)
  return _s;
}
inline const std::string& InviteResponse::_internal_invitation_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.invitation_token_.Get();
}
inline void InviteResponse::_internal_set_invitation_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.invitation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* InviteResponse::_internal_mutable_invitation_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.invitation_token_.Mutable( GetArenaForAllocation());
}
inline std::string* InviteResponse::release_invitation_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.InviteResponse.invitation_token)
  return _impl_.invitation_token_.Release();
}
inline void InviteResponse::set_allocated_invitation_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.invitation_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.invitation_token_.IsDefault()) {
          _impl_.invitation_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.InviteResponse.invitation_token)
}

// -------------------------------------------------------------------

// JoinProjectRequest

// string invitation_token = 1;
inline void JoinProjectRequest::clear_invitation_token() {
  _impl_.invitation_token_.ClearToEmpty();
}
inline const std::string& JoinProjectRequest::invitation_token() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.JoinProjectRequest.invitation_token)
  return _internal_invitation_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JoinProjectRequest::set_invitation_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.invitation_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.JoinProjectRequest.invitation_token)
}
inline std::string* JoinProjectRequest::mutable_invitation_token() {
  std::string* _s = _internal_mutable_invitation_token();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.JoinProjectRequest.invitation_token)
  return _s;
}
inline const std::string& JoinProjectRequest::_internal_invitation_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.invitation_token_.Get();
}
inline void JoinProjectRequest::_internal_set_invitation_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.invitation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinProjectRequest::_internal_mutable_invitation_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.invitation_token_.Mutable( GetArenaForAllocation());
}
inline std::string* JoinProjectRequest::release_invitation_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.JoinProjectRequest.invitation_token)
  return _impl_.invitation_token_.Release();
}
inline void JoinProjectRequest::set_allocated_invitation_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.invitation_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.invitation_token_.IsDefault()) {
          _impl_.invitation_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.JoinProjectRequest.invitation_token)
}

// -------------------------------------------------------------------

// JoinProjectResponse

// -------------------------------------------------------------------

// ListAppsRequest

// string project = 1;
inline void ListAppsRequest::clear_project() {
  _impl_.project_.ClearToEmpty();
}
inline const std::string& ListAppsRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.ListAppsRequest.project)
  return _internal_project();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListAppsRequest::set_project(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.ListAppsRequest.project)
}
inline std::string* ListAppsRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.ListAppsRequest.project)
  return _s;
}
inline const std::string& ListAppsRequest::_internal_project() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_.Get();
}
inline void ListAppsRequest::_internal_set_project(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(value, GetArenaForAllocation());
}
inline std::string* ListAppsRequest::_internal_mutable_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_.Mutable( GetArenaForAllocation());
}
inline std::string* ListAppsRequest::release_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.ListAppsRequest.project)
  return _impl_.project_.Release();
}
inline void ListAppsRequest::set_allocated_project(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_.IsDefault()) {
          _impl_.project_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.ListAppsRequest.project)
}

// -------------------------------------------------------------------

// ListAppsResponse

// repeated .speechly.config.v1.App apps = 1;
inline int ListAppsResponse::_internal_apps_size() const {
  return _internal_apps().size();
}
inline int ListAppsResponse::apps_size() const {
  return _internal_apps_size();
}
inline void ListAppsResponse::clear_apps() {
  _internal_mutable_apps()->Clear();
}
inline ::speechly::config::v1::App* ListAppsResponse::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.ListAppsResponse.apps)
  return _internal_mutable_apps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::App >*
ListAppsResponse::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:speechly.config.v1.ListAppsResponse.apps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_apps();
}
inline const ::speechly::config::v1::App& ListAppsResponse::apps(int index) const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.ListAppsResponse.apps)
    return _internal_apps().Get(index);
}
inline ::speechly::config::v1::App* ListAppsResponse::add_apps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::config::v1::App* _add = _internal_mutable_apps()->Add();
  // @@protoc_insertion_point(field_add:speechly.config.v1.ListAppsResponse.apps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::config::v1::App >&
ListAppsResponse::apps() const {
  // @@protoc_insertion_point(field_list:speechly.config.v1.ListAppsResponse.apps)
  return _internal_apps();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::config::v1::App>&
ListAppsResponse::_internal_apps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.apps_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::config::v1::App>*
ListAppsResponse::_internal_mutable_apps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.apps_;
}

// -------------------------------------------------------------------

// GetAppRequest

// string app_id = 1;
inline void GetAppRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& GetAppRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetAppRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAppRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.GetAppRequest.app_id)
}
inline std::string* GetAppRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetAppRequest.app_id)
  return _s;
}
inline const std::string& GetAppRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void GetAppRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAppRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetAppRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetAppRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void GetAppRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetAppRequest.app_id)
}

// -------------------------------------------------------------------

// GetAppResponse

// .speechly.config.v1.App app = 1;
inline bool GetAppResponse::has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_ != nullptr);
  return value;
}
inline void GetAppResponse::clear_app() {
  if (_impl_.app_ != nullptr) _impl_.app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::speechly::config::v1::App& GetAppResponse::_internal_app() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::speechly::config::v1::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::config::v1::App&>(::speechly::config::v1::_App_default_instance_);
}
inline const ::speechly::config::v1::App& GetAppResponse::app() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.GetAppResponse.app)
  return _internal_app();
}
inline void GetAppResponse::unsafe_arena_set_allocated_app(::speechly::config::v1::App* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.config.v1.GetAppResponse.app)
}
inline ::speechly::config::v1::App* GetAppResponse::release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::config::v1::App* released = _impl_.app_;
  _impl_.app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::speechly::config::v1::App* GetAppResponse::unsafe_arena_release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.GetAppResponse.app)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::config::v1::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::speechly::config::v1::App* GetAppResponse::_internal_mutable_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.app_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::config::v1::App>(GetArenaForAllocation());
    _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(p);
  }
  return _impl_.app_;
}
inline ::speechly::config::v1::App* GetAppResponse::mutable_app() {
  ::speechly::config::v1::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.GetAppResponse.app)
  return _msg;
}
inline void GetAppResponse::set_allocated_app(::speechly::config::v1::App* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::speechly::config::v1::App*>(_impl_.app_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::speechly::config::v1::App*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.GetAppResponse.app)
}

// -------------------------------------------------------------------

// CreateAppRequest

// string project = 1;
inline void CreateAppRequest::clear_project() {
  _impl_.project_.ClearToEmpty();
}
inline const std::string& CreateAppRequest::project() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateAppRequest.project)
  return _internal_project();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateAppRequest::set_project(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.CreateAppRequest.project)
}
inline std::string* CreateAppRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateAppRequest.project)
  return _s;
}
inline const std::string& CreateAppRequest::_internal_project() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.project_.Get();
}
inline void CreateAppRequest::_internal_set_project(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.project_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAppRequest::_internal_mutable_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.project_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateAppRequest::release_project() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateAppRequest.project)
  return _impl_.project_.Release();
}
inline void CreateAppRequest::set_allocated_project(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.project_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_.IsDefault()) {
          _impl_.project_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateAppRequest.project)
}

// .speechly.config.v1.App app = 2;
inline bool CreateAppRequest::has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_ != nullptr);
  return value;
}
inline void CreateAppRequest::clear_app() {
  if (_impl_.app_ != nullptr) _impl_.app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::speechly::config::v1::App& CreateAppRequest::_internal_app() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::speechly::config::v1::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::config::v1::App&>(::speechly::config::v1::_App_default_instance_);
}
inline const ::speechly::config::v1::App& CreateAppRequest::app() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateAppRequest.app)
  return _internal_app();
}
inline void CreateAppRequest::unsafe_arena_set_allocated_app(::speechly::config::v1::App* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.config.v1.CreateAppRequest.app)
}
inline ::speechly::config::v1::App* CreateAppRequest::release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::config::v1::App* released = _impl_.app_;
  _impl_.app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::speechly::config::v1::App* CreateAppRequest::unsafe_arena_release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateAppRequest.app)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::config::v1::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::speechly::config::v1::App* CreateAppRequest::_internal_mutable_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.app_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::config::v1::App>(GetArenaForAllocation());
    _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(p);
  }
  return _impl_.app_;
}
inline ::speechly::config::v1::App* CreateAppRequest::mutable_app() {
  ::speechly::config::v1::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateAppRequest.app)
  return _msg;
}
inline void CreateAppRequest::set_allocated_app(::speechly::config::v1::App* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::speechly::config::v1::App*>(_impl_.app_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::speechly::config::v1::App*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateAppRequest.app)
}

// -------------------------------------------------------------------

// CreateAppResponse

// .speechly.config.v1.App app = 1;
inline bool CreateAppResponse::has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_ != nullptr);
  return value;
}
inline void CreateAppResponse::clear_app() {
  if (_impl_.app_ != nullptr) _impl_.app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::speechly::config::v1::App& CreateAppResponse::_internal_app() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::speechly::config::v1::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::config::v1::App&>(::speechly::config::v1::_App_default_instance_);
}
inline const ::speechly::config::v1::App& CreateAppResponse::app() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.CreateAppResponse.app)
  return _internal_app();
}
inline void CreateAppResponse::unsafe_arena_set_allocated_app(::speechly::config::v1::App* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.config.v1.CreateAppResponse.app)
}
inline ::speechly::config::v1::App* CreateAppResponse::release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::config::v1::App* released = _impl_.app_;
  _impl_.app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::speechly::config::v1::App* CreateAppResponse::unsafe_arena_release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.CreateAppResponse.app)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::config::v1::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::speechly::config::v1::App* CreateAppResponse::_internal_mutable_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.app_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::config::v1::App>(GetArenaForAllocation());
    _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(p);
  }
  return _impl_.app_;
}
inline ::speechly::config::v1::App* CreateAppResponse::mutable_app() {
  ::speechly::config::v1::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.CreateAppResponse.app)
  return _msg;
}
inline void CreateAppResponse::set_allocated_app(::speechly::config::v1::App* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::speechly::config::v1::App*>(_impl_.app_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::speechly::config::v1::App*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.CreateAppResponse.app)
}

// -------------------------------------------------------------------

// UpdateAppRequest

// .speechly.config.v1.App app = 1;
inline bool UpdateAppRequest::has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_ != nullptr);
  return value;
}
inline void UpdateAppRequest::clear_app() {
  if (_impl_.app_ != nullptr) _impl_.app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::speechly::config::v1::App& UpdateAppRequest::_internal_app() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::speechly::config::v1::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::config::v1::App&>(::speechly::config::v1::_App_default_instance_);
}
inline const ::speechly::config::v1::App& UpdateAppRequest::app() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UpdateAppRequest.app)
  return _internal_app();
}
inline void UpdateAppRequest::unsafe_arena_set_allocated_app(::speechly::config::v1::App* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.config.v1.UpdateAppRequest.app)
}
inline ::speechly::config::v1::App* UpdateAppRequest::release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::config::v1::App* released = _impl_.app_;
  _impl_.app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::speechly::config::v1::App* UpdateAppRequest::unsafe_arena_release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.UpdateAppRequest.app)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::config::v1::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::speechly::config::v1::App* UpdateAppRequest::_internal_mutable_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.app_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::config::v1::App>(GetArenaForAllocation());
    _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(p);
  }
  return _impl_.app_;
}
inline ::speechly::config::v1::App* UpdateAppRequest::mutable_app() {
  ::speechly::config::v1::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UpdateAppRequest.app)
  return _msg;
}
inline void UpdateAppRequest::set_allocated_app(::speechly::config::v1::App* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::speechly::config::v1::App*>(_impl_.app_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::speechly::config::v1::App*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.app_ = reinterpret_cast<::speechly::config::v1::App*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UpdateAppRequest.app)
}

// -------------------------------------------------------------------

// UpdateAppResponse

// -------------------------------------------------------------------

// DeleteAppRequest

// string app_id = 1;
inline void DeleteAppRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& DeleteAppRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DeleteAppRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteAppRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.DeleteAppRequest.app_id)
}
inline std::string* DeleteAppRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.DeleteAppRequest.app_id)
  return _s;
}
inline const std::string& DeleteAppRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void DeleteAppRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAppRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteAppRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.DeleteAppRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void DeleteAppRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.DeleteAppRequest.app_id)
}

// -------------------------------------------------------------------

// DeleteAppResponse

// -------------------------------------------------------------------

// UploadTrainingDataRequest

// string app_id = 1;
inline void UploadTrainingDataRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& UploadTrainingDataRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UploadTrainingDataRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UploadTrainingDataRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.UploadTrainingDataRequest.app_id)
}
inline std::string* UploadTrainingDataRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UploadTrainingDataRequest.app_id)
  return _s;
}
inline const std::string& UploadTrainingDataRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void UploadTrainingDataRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadTrainingDataRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* UploadTrainingDataRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.UploadTrainingDataRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void UploadTrainingDataRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UploadTrainingDataRequest.app_id)
}

// bytes data_chunk = 2;
inline void UploadTrainingDataRequest::clear_data_chunk() {
  _impl_.data_chunk_.ClearToEmpty();
}
inline const std::string& UploadTrainingDataRequest::data_chunk() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
  return _internal_data_chunk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UploadTrainingDataRequest::set_data_chunk(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_chunk_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
}
inline std::string* UploadTrainingDataRequest::mutable_data_chunk() {
  std::string* _s = _internal_mutable_data_chunk();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
  return _s;
}
inline const std::string& UploadTrainingDataRequest::_internal_data_chunk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_chunk_.Get();
}
inline void UploadTrainingDataRequest::_internal_set_data_chunk(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadTrainingDataRequest::_internal_mutable_data_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_chunk_.Mutable( GetArenaForAllocation());
}
inline std::string* UploadTrainingDataRequest::release_data_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
  return _impl_.data_chunk_.Release();
}
inline void UploadTrainingDataRequest::set_allocated_data_chunk(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_chunk_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_chunk_.IsDefault()) {
          _impl_.data_chunk_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.UploadTrainingDataRequest.data_chunk)
}

// .speechly.config.v1.UploadTrainingDataRequest.ContentType content_type = 3;
inline void UploadTrainingDataRequest::clear_content_type() {
  _impl_.content_type_ = 0;
}
inline ::speechly::config::v1::UploadTrainingDataRequest_ContentType UploadTrainingDataRequest::content_type() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.UploadTrainingDataRequest.content_type)
  return _internal_content_type();
}
inline void UploadTrainingDataRequest::set_content_type(::speechly::config::v1::UploadTrainingDataRequest_ContentType value) {
  _internal_set_content_type(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.UploadTrainingDataRequest.content_type)
}
inline ::speechly::config::v1::UploadTrainingDataRequest_ContentType UploadTrainingDataRequest::_internal_content_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::config::v1::UploadTrainingDataRequest_ContentType>(_impl_.content_type_);
}
inline void UploadTrainingDataRequest::_internal_set_content_type(::speechly::config::v1::UploadTrainingDataRequest_ContentType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_type_ = value;
}

// -------------------------------------------------------------------

// UploadTrainingDataResponse

// -------------------------------------------------------------------

// DownloadCurrentTrainingDataRequest

// string app_id = 1;
inline void DownloadCurrentTrainingDataRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& DownloadCurrentTrainingDataRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadCurrentTrainingDataRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
}
inline std::string* DownloadCurrentTrainingDataRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
  return _s;
}
inline const std::string& DownloadCurrentTrainingDataRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void DownloadCurrentTrainingDataRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void DownloadCurrentTrainingDataRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.DownloadCurrentTrainingDataRequest.app_id)
}

// string config_id = 2;
inline void DownloadCurrentTrainingDataRequest::clear_config_id() {
  _impl_.config_id_.ClearToEmpty();
}
inline const std::string& DownloadCurrentTrainingDataRequest::config_id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
  return _internal_config_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadCurrentTrainingDataRequest::set_config_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.config_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
}
inline std::string* DownloadCurrentTrainingDataRequest::mutable_config_id() {
  std::string* _s = _internal_mutable_config_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
  return _s;
}
inline const std::string& DownloadCurrentTrainingDataRequest::_internal_config_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.config_id_.Get();
}
inline void DownloadCurrentTrainingDataRequest::_internal_set_config_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataRequest::_internal_mutable_config_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.config_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataRequest::release_config_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
  return _impl_.config_id_.Release();
}
inline void DownloadCurrentTrainingDataRequest::set_allocated_config_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.config_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.config_id_.IsDefault()) {
          _impl_.config_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.DownloadCurrentTrainingDataRequest.config_id)
}

// -------------------------------------------------------------------

// DownloadCurrentTrainingDataResponse

// bytes data_chunk = 1;
inline void DownloadCurrentTrainingDataResponse::clear_data_chunk() {
  _impl_.data_chunk_.ClearToEmpty();
}
inline const std::string& DownloadCurrentTrainingDataResponse::data_chunk() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
  return _internal_data_chunk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadCurrentTrainingDataResponse::set_data_chunk(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_chunk_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
}
inline std::string* DownloadCurrentTrainingDataResponse::mutable_data_chunk() {
  std::string* _s = _internal_mutable_data_chunk();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
  return _s;
}
inline const std::string& DownloadCurrentTrainingDataResponse::_internal_data_chunk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_chunk_.Get();
}
inline void DownloadCurrentTrainingDataResponse::_internal_set_data_chunk(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataResponse::_internal_mutable_data_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_chunk_.Mutable( GetArenaForAllocation());
}
inline std::string* DownloadCurrentTrainingDataResponse::release_data_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
  return _impl_.data_chunk_.Release();
}
inline void DownloadCurrentTrainingDataResponse::set_allocated_data_chunk(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_chunk_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_chunk_.IsDefault()) {
          _impl_.data_chunk_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.DownloadCurrentTrainingDataResponse.data_chunk)
}

// .speechly.config.v1.DownloadCurrentTrainingDataResponse.ContentType content_type = 2;
inline void DownloadCurrentTrainingDataResponse::clear_content_type() {
  _impl_.content_type_ = 0;
}
inline ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType DownloadCurrentTrainingDataResponse::content_type() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.DownloadCurrentTrainingDataResponse.content_type)
  return _internal_content_type();
}
inline void DownloadCurrentTrainingDataResponse::set_content_type(::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType value) {
  _internal_set_content_type(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.DownloadCurrentTrainingDataResponse.content_type)
}
inline ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType DownloadCurrentTrainingDataResponse::_internal_content_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType>(_impl_.content_type_);
}
inline void DownloadCurrentTrainingDataResponse::_internal_set_content_type(::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_type_ = value;
}

// -------------------------------------------------------------------

// App

// string id = 1;
inline void App::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& App::id() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.id)
}
inline std::string* App::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.id)
  return _s;
}
inline const std::string& App::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void App::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.App.id)
  return _impl_.id_.Release();
}
inline void App::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.App.id)
}

// string language = 2;
inline void App::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& App::language() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.language)
  return _internal_language();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_language(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.language)
}
inline std::string* App::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.language)
  return _s;
}
inline const std::string& App::_internal_language() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_.Get();
}
inline void App::_internal_set_language(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.language_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.App.language)
  return _impl_.language_.Release();
}
inline void App::set_allocated_language(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_.IsDefault()) {
          _impl_.language_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.App.language)
}

// .speechly.config.v1.App.Status status = 3;
inline void App::clear_status() {
  _impl_.status_ = 0;
}
inline ::speechly::config::v1::App_Status App::status() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.status)
  return _internal_status();
}
inline void App::set_status(::speechly::config::v1::App_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.status)
}
inline ::speechly::config::v1::App_Status App::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::config::v1::App_Status>(_impl_.status_);
}
inline void App::_internal_set_status(::speechly::config::v1::App_Status value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// string name = 4;
inline void App::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& App::name() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.name)
}
inline std::string* App::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.name)
  return _s;
}
inline const std::string& App::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void App::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.App.name)
  return _impl_.name_.Release();
}
inline void App::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.App.name)
}

// int32 queue_size = 5;
inline void App::clear_queue_size() {
  _impl_.queue_size_ = 0;
}
inline ::int32_t App::queue_size() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.queue_size)
  return _internal_queue_size();
}
inline void App::set_queue_size(::int32_t value) {
  _internal_set_queue_size(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.queue_size)
}
inline ::int32_t App::_internal_queue_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.queue_size_;
}
inline void App::_internal_set_queue_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.queue_size_ = value;
}

// string error_msg = 6;
inline void App::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& App::error_msg() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.error_msg)
  return _internal_error_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_error_msg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_msg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.error_msg)
}
inline std::string* App::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.error_msg)
  return _s;
}
inline const std::string& App::_internal_error_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_msg_.Get();
}
inline void App::_internal_set_error_msg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_error_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_msg_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_error_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.App.error_msg)
  return _impl_.error_msg_.Release();
}
inline void App::set_allocated_error_msg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_msg_.IsDefault()) {
          _impl_.error_msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.App.error_msg)
}

// int32 estimated_remaining_sec = 7;
inline void App::clear_estimated_remaining_sec() {
  _impl_.estimated_remaining_sec_ = 0;
}
inline ::int32_t App::estimated_remaining_sec() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.estimated_remaining_sec)
  return _internal_estimated_remaining_sec();
}
inline void App::set_estimated_remaining_sec(::int32_t value) {
  _internal_set_estimated_remaining_sec(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.estimated_remaining_sec)
}
inline ::int32_t App::_internal_estimated_remaining_sec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.estimated_remaining_sec_;
}
inline void App::_internal_set_estimated_remaining_sec(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.estimated_remaining_sec_ = value;
}

// int32 estimated_training_time_sec = 8;
inline void App::clear_estimated_training_time_sec() {
  _impl_.estimated_training_time_sec_ = 0;
}
inline ::int32_t App::estimated_training_time_sec() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.estimated_training_time_sec)
  return _internal_estimated_training_time_sec();
}
inline void App::set_estimated_training_time_sec(::int32_t value) {
  _internal_set_estimated_training_time_sec(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.estimated_training_time_sec)
}
inline ::int32_t App::_internal_estimated_training_time_sec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.estimated_training_time_sec_;
}
inline void App::_internal_set_estimated_training_time_sec(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.estimated_training_time_sec_ = value;
}

// int32 training_time_sec = 9;
inline void App::clear_training_time_sec() {
  _impl_.training_time_sec_ = 0;
}
inline ::int32_t App::training_time_sec() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.training_time_sec)
  return _internal_training_time_sec();
}
inline void App::set_training_time_sec(::int32_t value) {
  _internal_set_training_time_sec(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.training_time_sec)
}
inline ::int32_t App::_internal_training_time_sec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.training_time_sec_;
}
inline void App::_internal_set_training_time_sec(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.training_time_sec_ = value;
}

// repeated string tags = 10;
inline int App::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int App::tags_size() const {
  return _internal_tags_size();
}
inline void App::clear_tags() {
  _internal_mutable_tags()->Clear();
}
inline std::string* App::add_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:speechly.config.v1.App.tags)
  return _s;
}
inline const std::string& App::tags(int index) const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.tags)
  return _internal_tags().Get(index);
}
inline std::string* App::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void App::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.tags)
}
inline void App::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speechly.config.v1.App.tags)
}
inline void App::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speechly.config.v1.App.tags)
}
inline void App::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speechly.config.v1.App.tags)
}
inline void App::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:speechly.config.v1.App.tags)
}
inline void App::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:speechly.config.v1.App.tags)
}
inline void App::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:speechly.config.v1.App.tags)
}
inline void App::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speechly.config.v1.App.tags)
}
inline void App::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speechly.config.v1.App.tags)
}
inline void App::add_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:speechly.config.v1.App.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
App::tags() const {
  // @@protoc_insertion_point(field_list:speechly.config.v1.App.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* App::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:speechly.config.v1.App.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
App::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
App::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// .google.protobuf.Timestamp deployed_at_time = 11;
inline bool App::has_deployed_at_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deployed_at_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& App::_internal_deployed_at_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.deployed_at_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& App::deployed_at_time() const {
  // @@protoc_insertion_point(field_get:speechly.config.v1.App.deployed_at_time)
  return _internal_deployed_at_time();
}
inline void App::unsafe_arena_set_allocated_deployed_at_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.deployed_at_time_);
  }
  _impl_.deployed_at_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.config.v1.App.deployed_at_time)
}
inline ::google::protobuf::Timestamp* App::release_deployed_at_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.deployed_at_time_;
  _impl_.deployed_at_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* App::unsafe_arena_release_deployed_at_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.config.v1.App.deployed_at_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.deployed_at_time_;
  _impl_.deployed_at_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* App::_internal_mutable_deployed_at_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deployed_at_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.deployed_at_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.deployed_at_time_;
}
inline ::google::protobuf::Timestamp* App::mutable_deployed_at_time() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_deployed_at_time();
  // @@protoc_insertion_point(field_mutable:speechly.config.v1.App.deployed_at_time)
  return _msg;
}
inline void App::set_allocated_deployed_at_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.deployed_at_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.deployed_at_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.config.v1.App.deployed_at_time)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace config
}  // namespace speechly


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::speechly::config::v1::UploadTrainingDataRequest_ContentType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::speechly::config::v1::UploadTrainingDataRequest_ContentType>() {
  return ::speechly::config::v1::UploadTrainingDataRequest_ContentType_descriptor();
}
template <>
struct is_proto_enum<::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType>() {
  return ::speechly::config::v1::DownloadCurrentTrainingDataResponse_ContentType_descriptor();
}
template <>
struct is_proto_enum<::speechly::config::v1::App_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::speechly::config::v1::App_Status>() {
  return ::speechly::config::v1::App_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_speechly_2fconfig_2fv1_2fconfig_5fapi_2eproto_2epb_2eh
