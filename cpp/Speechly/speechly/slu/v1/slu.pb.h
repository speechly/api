// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: speechly/slu/v1/slu.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_speechly_2fslu_2fv1_2fslu_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_speechly_2fslu_2fv1_2fslu_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_speechly_2fslu_2fv1_2fslu_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_speechly_2fslu_2fv1_2fslu_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_speechly_2fslu_2fv1_2fslu_2eproto;
namespace speechly {
namespace slu {
namespace v1 {
class RoundTripMeasurementRequest;
struct RoundTripMeasurementRequestDefaultTypeInternal;
extern RoundTripMeasurementRequestDefaultTypeInternal _RoundTripMeasurementRequest_default_instance_;
class RoundTripMeasurementResponse;
struct RoundTripMeasurementResponseDefaultTypeInternal;
extern RoundTripMeasurementResponseDefaultTypeInternal _RoundTripMeasurementResponse_default_instance_;
class SLUConfig;
struct SLUConfigDefaultTypeInternal;
extern SLUConfigDefaultTypeInternal _SLUConfig_default_instance_;
class SLUConfig_Option;
struct SLUConfig_OptionDefaultTypeInternal;
extern SLUConfig_OptionDefaultTypeInternal _SLUConfig_Option_default_instance_;
class SLUEntity;
struct SLUEntityDefaultTypeInternal;
extern SLUEntityDefaultTypeInternal _SLUEntity_default_instance_;
class SLUError;
struct SLUErrorDefaultTypeInternal;
extern SLUErrorDefaultTypeInternal _SLUError_default_instance_;
class SLUEvent;
struct SLUEventDefaultTypeInternal;
extern SLUEventDefaultTypeInternal _SLUEvent_default_instance_;
class SLUFinished;
struct SLUFinishedDefaultTypeInternal;
extern SLUFinishedDefaultTypeInternal _SLUFinished_default_instance_;
class SLUIntent;
struct SLUIntentDefaultTypeInternal;
extern SLUIntentDefaultTypeInternal _SLUIntent_default_instance_;
class SLURequest;
struct SLURequestDefaultTypeInternal;
extern SLURequestDefaultTypeInternal _SLURequest_default_instance_;
class SLUResponse;
struct SLUResponseDefaultTypeInternal;
extern SLUResponseDefaultTypeInternal _SLUResponse_default_instance_;
class SLUSegmentEnd;
struct SLUSegmentEndDefaultTypeInternal;
extern SLUSegmentEndDefaultTypeInternal _SLUSegmentEnd_default_instance_;
class SLUStart;
struct SLUStartDefaultTypeInternal;
extern SLUStartDefaultTypeInternal _SLUStart_default_instance_;
class SLUStart_Option;
struct SLUStart_OptionDefaultTypeInternal;
extern SLUStart_OptionDefaultTypeInternal _SLUStart_Option_default_instance_;
class SLUStarted;
struct SLUStartedDefaultTypeInternal;
extern SLUStartedDefaultTypeInternal _SLUStarted_default_instance_;
class SLUStop;
struct SLUStopDefaultTypeInternal;
extern SLUStopDefaultTypeInternal _SLUStop_default_instance_;
class SLUTentativeEntities;
struct SLUTentativeEntitiesDefaultTypeInternal;
extern SLUTentativeEntitiesDefaultTypeInternal _SLUTentativeEntities_default_instance_;
class SLUTentativeTranscript;
struct SLUTentativeTranscriptDefaultTypeInternal;
extern SLUTentativeTranscriptDefaultTypeInternal _SLUTentativeTranscript_default_instance_;
class SLUTranscript;
struct SLUTranscriptDefaultTypeInternal;
extern SLUTranscriptDefaultTypeInternal _SLUTranscript_default_instance_;
}  // namespace v1
}  // namespace slu
}  // namespace speechly
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace speechly {
namespace slu {
namespace v1 {
enum SLUConfig_Encoding : int {
  SLUConfig_Encoding_LINEAR16 = 0,
  SLUConfig_Encoding_SLUConfig_Encoding_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SLUConfig_Encoding_SLUConfig_Encoding_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SLUConfig_Encoding_IsValid(int value);
constexpr SLUConfig_Encoding SLUConfig_Encoding_Encoding_MIN = static_cast<SLUConfig_Encoding>(0);
constexpr SLUConfig_Encoding SLUConfig_Encoding_Encoding_MAX = static_cast<SLUConfig_Encoding>(0);
constexpr int SLUConfig_Encoding_Encoding_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
SLUConfig_Encoding_descriptor();
template <typename T>
const std::string& SLUConfig_Encoding_Name(T value) {
  static_assert(std::is_same<T, SLUConfig_Encoding>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Encoding_Name().");
  return SLUConfig_Encoding_Name(static_cast<SLUConfig_Encoding>(value));
}
template <>
inline const std::string& SLUConfig_Encoding_Name(SLUConfig_Encoding value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SLUConfig_Encoding_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool SLUConfig_Encoding_Parse(absl::string_view name, SLUConfig_Encoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLUConfig_Encoding>(
      SLUConfig_Encoding_descriptor(), name, value);
}
enum SLUEvent_Event : int {
  SLUEvent_Event_START = 0,
  SLUEvent_Event_STOP = 1,
  SLUEvent_Event_SLUEvent_Event_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SLUEvent_Event_SLUEvent_Event_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SLUEvent_Event_IsValid(int value);
constexpr SLUEvent_Event SLUEvent_Event_Event_MIN = static_cast<SLUEvent_Event>(0);
constexpr SLUEvent_Event SLUEvent_Event_Event_MAX = static_cast<SLUEvent_Event>(1);
constexpr int SLUEvent_Event_Event_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
SLUEvent_Event_descriptor();
template <typename T>
const std::string& SLUEvent_Event_Name(T value) {
  static_assert(std::is_same<T, SLUEvent_Event>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Event_Name().");
  return SLUEvent_Event_Name(static_cast<SLUEvent_Event>(value));
}
template <>
inline const std::string& SLUEvent_Event_Name(SLUEvent_Event value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SLUEvent_Event_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SLUEvent_Event_Parse(absl::string_view name, SLUEvent_Event* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLUEvent_Event>(
      SLUEvent_Event_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SLURequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLURequest) */ {
 public:
  inline SLURequest() : SLURequest(nullptr) {}
  ~SLURequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLURequest(::google::protobuf::internal::ConstantInitialized);

  SLURequest(const SLURequest& from);
  SLURequest(SLURequest&& from) noexcept
    : SLURequest() {
    *this = ::std::move(from);
  }

  inline SLURequest& operator=(const SLURequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLURequest& operator=(SLURequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLURequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kEvent = 2,
    kAudio = 3,
    kRttResponse = 4,
    kStart = 5,
    kStop = 6,
    STREAMING_REQUEST_NOT_SET = 0,
  };

  static inline const SLURequest* internal_default_instance() {
    return reinterpret_cast<const SLURequest*>(
               &_SLURequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SLURequest& a, SLURequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SLURequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLURequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLURequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLURequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLURequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLURequest& from) {
    SLURequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLURequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLURequest";
  }
  protected:
  explicit SLURequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kEventFieldNumber = 2,
    kAudioFieldNumber = 3,
    kRttResponseFieldNumber = 4,
    kStartFieldNumber = 5,
    kStopFieldNumber = 6,
  };
  // .speechly.slu.v1.SLUConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;

  public:
  void clear_config() ;
  const ::speechly::slu::v1::SLUConfig& config() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUConfig* release_config();
  ::speechly::slu::v1::SLUConfig* mutable_config();
  void set_allocated_config(::speechly::slu::v1::SLUConfig* value);
  void unsafe_arena_set_allocated_config(::speechly::slu::v1::SLUConfig* value);
  ::speechly::slu::v1::SLUConfig* unsafe_arena_release_config();

  private:
  const ::speechly::slu::v1::SLUConfig& _internal_config() const;
  ::speechly::slu::v1::SLUConfig* _internal_mutable_config();

  public:
  // .speechly.slu.v1.SLUEvent event = 2 [deprecated = true];
  [[deprecated]]  bool has_event() const;
  private:
  bool _internal_has_event() const;

  public:
  [[deprecated]]  void clear_event() ;
  [[deprecated]] const ::speechly::slu::v1::SLUEvent& event() const;
  [[deprecated]] PROTOBUF_NODISCARD ::speechly::slu::v1::SLUEvent* release_event();
  [[deprecated]] ::speechly::slu::v1::SLUEvent* mutable_event();
  [[deprecated]] void set_allocated_event(::speechly::slu::v1::SLUEvent* value);
  [[deprecated]] void unsafe_arena_set_allocated_event(::speechly::slu::v1::SLUEvent* value);
  [[deprecated]] ::speechly::slu::v1::SLUEvent* unsafe_arena_release_event();

  private:
  const ::speechly::slu::v1::SLUEvent& _internal_event() const;
  ::speechly::slu::v1::SLUEvent* _internal_mutable_event();

  public:
  // bytes audio = 3;
  bool has_audio() const;
  void clear_audio() ;
  const std::string& audio() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio(Arg_&& arg, Args_... args);
  std::string* mutable_audio();
  PROTOBUF_NODISCARD std::string* release_audio();
  void set_allocated_audio(std::string* ptr);

  private:
  const std::string& _internal_audio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio(
      const std::string& value);
  std::string* _internal_mutable_audio();

  public:
  // .speechly.slu.v1.RoundTripMeasurementResponse rtt_response = 4;
  bool has_rtt_response() const;
  private:
  bool _internal_has_rtt_response() const;

  public:
  void clear_rtt_response() ;
  const ::speechly::slu::v1::RoundTripMeasurementResponse& rtt_response() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::RoundTripMeasurementResponse* release_rtt_response();
  ::speechly::slu::v1::RoundTripMeasurementResponse* mutable_rtt_response();
  void set_allocated_rtt_response(::speechly::slu::v1::RoundTripMeasurementResponse* value);
  void unsafe_arena_set_allocated_rtt_response(::speechly::slu::v1::RoundTripMeasurementResponse* value);
  ::speechly::slu::v1::RoundTripMeasurementResponse* unsafe_arena_release_rtt_response();

  private:
  const ::speechly::slu::v1::RoundTripMeasurementResponse& _internal_rtt_response() const;
  ::speechly::slu::v1::RoundTripMeasurementResponse* _internal_mutable_rtt_response();

  public:
  // .speechly.slu.v1.SLUStart start = 5;
  bool has_start() const;
  private:
  bool _internal_has_start() const;

  public:
  void clear_start() ;
  const ::speechly::slu::v1::SLUStart& start() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUStart* release_start();
  ::speechly::slu::v1::SLUStart* mutable_start();
  void set_allocated_start(::speechly::slu::v1::SLUStart* value);
  void unsafe_arena_set_allocated_start(::speechly::slu::v1::SLUStart* value);
  ::speechly::slu::v1::SLUStart* unsafe_arena_release_start();

  private:
  const ::speechly::slu::v1::SLUStart& _internal_start() const;
  ::speechly::slu::v1::SLUStart* _internal_mutable_start();

  public:
  // .speechly.slu.v1.SLUStop stop = 6;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;

  public:
  void clear_stop() ;
  const ::speechly::slu::v1::SLUStop& stop() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUStop* release_stop();
  ::speechly::slu::v1::SLUStop* mutable_stop();
  void set_allocated_stop(::speechly::slu::v1::SLUStop* value);
  void unsafe_arena_set_allocated_stop(::speechly::slu::v1::SLUStop* value);
  ::speechly::slu::v1::SLUStop* unsafe_arena_release_stop();

  private:
  const ::speechly::slu::v1::SLUStop& _internal_stop() const;
  ::speechly::slu::v1::SLUStop* _internal_mutable_stop();

  public:
  void clear_streaming_request();
  StreamingRequestCase streaming_request_case() const;
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLURequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_event();
  void set_has_audio();
  void set_has_rtt_response();
  void set_has_start();
  void set_has_stop();

  inline bool has_streaming_request() const;
  inline void clear_has_streaming_request();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 6, 5, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union StreamingRequestUnion {
      constexpr StreamingRequestUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::speechly::slu::v1::SLUConfig* config_;
      ::speechly::slu::v1::SLUEvent* event_;
      ::google::protobuf::internal::ArenaStringPtr audio_;
      ::speechly::slu::v1::RoundTripMeasurementResponse* rtt_response_;
      ::speechly::slu::v1::SLUStart* start_;
      ::speechly::slu::v1::SLUStop* stop_;
    } streaming_request_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUConfig_Option final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUConfig.Option) */ {
 public:
  inline SLUConfig_Option() : SLUConfig_Option(nullptr) {}
  ~SLUConfig_Option() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUConfig_Option(::google::protobuf::internal::ConstantInitialized);

  SLUConfig_Option(const SLUConfig_Option& from);
  SLUConfig_Option(SLUConfig_Option&& from) noexcept
    : SLUConfig_Option() {
    *this = ::std::move(from);
  }

  inline SLUConfig_Option& operator=(const SLUConfig_Option& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUConfig_Option& operator=(SLUConfig_Option&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUConfig_Option& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUConfig_Option* internal_default_instance() {
    return reinterpret_cast<const SLUConfig_Option*>(
               &_SLUConfig_Option_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SLUConfig_Option& a, SLUConfig_Option& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUConfig_Option* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUConfig_Option* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUConfig_Option* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUConfig_Option>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUConfig_Option& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUConfig_Option& from) {
    SLUConfig_Option::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUConfig_Option* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUConfig.Option";
  }
  protected:
  explicit SLUConfig_Option(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // repeated string value = 2;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, std::size_t size);
  void set_value(int index, absl::string_view value);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, std::size_t size);
  void add_value(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_value();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_value();

  public:
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUConfig.Option)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> value_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUConfig) */ {
 public:
  inline SLUConfig() : SLUConfig(nullptr) {}
  ~SLUConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUConfig(::google::protobuf::internal::ConstantInitialized);

  SLUConfig(const SLUConfig& from);
  SLUConfig(SLUConfig&& from) noexcept
    : SLUConfig() {
    *this = ::std::move(from);
  }

  inline SLUConfig& operator=(const SLUConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUConfig& operator=(SLUConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUConfig* internal_default_instance() {
    return reinterpret_cast<const SLUConfig*>(
               &_SLUConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SLUConfig& a, SLUConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUConfig& from) {
    SLUConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUConfig";
  }
  protected:
  explicit SLUConfig(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLUConfig_Option Option;

  using Encoding = SLUConfig_Encoding;
  static constexpr Encoding LINEAR16 = SLUConfig_Encoding_LINEAR16;
  static inline bool Encoding_IsValid(int value) {
    return SLUConfig_Encoding_IsValid(value);
  }
  static constexpr Encoding Encoding_MIN = SLUConfig_Encoding_Encoding_MIN;
  static constexpr Encoding Encoding_MAX = SLUConfig_Encoding_Encoding_MAX;
  static constexpr int Encoding_ARRAYSIZE = SLUConfig_Encoding_Encoding_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Encoding_descriptor() {
    return SLUConfig_Encoding_descriptor();
  }
  template <typename T>
  static inline const std::string& Encoding_Name(T value) {
    return SLUConfig_Encoding_Name(value);
  }
  static inline bool Encoding_Parse(absl::string_view name, Encoding* value) {
    return SLUConfig_Encoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 5,
    kLanguageCodeFieldNumber = 4,
    kEncodingFieldNumber = 1,
    kChannelsFieldNumber = 2,
    kSampleRateHertzFieldNumber = 3,
  };
  // repeated .speechly.slu.v1.SLUConfig.Option options = 5;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::speechly::slu::v1::SLUConfig_Option* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUConfig_Option >*
      mutable_options();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUConfig_Option>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUConfig_Option>* _internal_mutable_options();
  public:
  const ::speechly::slu::v1::SLUConfig_Option& options(int index) const;
  ::speechly::slu::v1::SLUConfig_Option* add_options();
  const ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUConfig_Option >&
      options() const;
  // string language_code = 4;
  void clear_language_code() ;
  const std::string& language_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language_code(Arg_&& arg, Args_... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* ptr);

  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(
      const std::string& value);
  std::string* _internal_mutable_language_code();

  public:
  // .speechly.slu.v1.SLUConfig.Encoding encoding = 1;
  void clear_encoding() ;
  ::speechly::slu::v1::SLUConfig_Encoding encoding() const;
  void set_encoding(::speechly::slu::v1::SLUConfig_Encoding value);

  private:
  ::speechly::slu::v1::SLUConfig_Encoding _internal_encoding() const;
  void _internal_set_encoding(::speechly::slu::v1::SLUConfig_Encoding value);

  public:
  // int32 channels = 2;
  void clear_channels() ;
  ::int32_t channels() const;
  void set_channels(::int32_t value);

  private:
  ::int32_t _internal_channels() const;
  void _internal_set_channels(::int32_t value);

  public:
  // int32 sample_rate_hertz = 3;
  void clear_sample_rate_hertz() ;
  ::int32_t sample_rate_hertz() const;
  void set_sample_rate_hertz(::int32_t value);

  private:
  ::int32_t _internal_sample_rate_hertz() const;
  void _internal_set_sample_rate_hertz(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 1, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUConfig_Option > options_;
    ::google::protobuf::internal::ArenaStringPtr language_code_;
    int encoding_;
    ::int32_t channels_;
    ::int32_t sample_rate_hertz_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUEvent) */ {
 public:
  inline SLUEvent() : SLUEvent(nullptr) {}
  ~SLUEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUEvent(::google::protobuf::internal::ConstantInitialized);

  SLUEvent(const SLUEvent& from);
  SLUEvent(SLUEvent&& from) noexcept
    : SLUEvent() {
    *this = ::std::move(from);
  }

  inline SLUEvent& operator=(const SLUEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUEvent& operator=(SLUEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUEvent* internal_default_instance() {
    return reinterpret_cast<const SLUEvent*>(
               &_SLUEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SLUEvent& a, SLUEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUEvent& from) {
    SLUEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUEvent";
  }
  protected:
  explicit SLUEvent(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Event = SLUEvent_Event;
  static constexpr Event START = SLUEvent_Event_START;
  static constexpr Event STOP = SLUEvent_Event_STOP;
  static inline bool Event_IsValid(int value) {
    return SLUEvent_Event_IsValid(value);
  }
  static constexpr Event Event_MIN = SLUEvent_Event_Event_MIN;
  static constexpr Event Event_MAX = SLUEvent_Event_Event_MAX;
  static constexpr int Event_ARRAYSIZE = SLUEvent_Event_Event_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Event_descriptor() {
    return SLUEvent_Event_descriptor();
  }
  template <typename T>
  static inline const std::string& Event_Name(T value) {
    return SLUEvent_Event_Name(value);
  }
  static inline bool Event_Parse(absl::string_view name, Event* value) {
    return SLUEvent_Event_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 2,
    kEventFieldNumber = 1,
  };
  // string app_id = 2;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // .speechly.slu.v1.SLUEvent.Event event = 1;
  void clear_event() ;
  ::speechly::slu::v1::SLUEvent_Event event() const;
  void set_event(::speechly::slu::v1::SLUEvent_Event value);

  private:
  ::speechly::slu::v1::SLUEvent_Event _internal_event() const;
  void _internal_set_event(::speechly::slu::v1::SLUEvent_Event value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    int event_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUStart_Option final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUStart.Option) */ {
 public:
  inline SLUStart_Option() : SLUStart_Option(nullptr) {}
  ~SLUStart_Option() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUStart_Option(::google::protobuf::internal::ConstantInitialized);

  SLUStart_Option(const SLUStart_Option& from);
  SLUStart_Option(SLUStart_Option&& from) noexcept
    : SLUStart_Option() {
    *this = ::std::move(from);
  }

  inline SLUStart_Option& operator=(const SLUStart_Option& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUStart_Option& operator=(SLUStart_Option&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUStart_Option& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUStart_Option* internal_default_instance() {
    return reinterpret_cast<const SLUStart_Option*>(
               &_SLUStart_Option_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SLUStart_Option& a, SLUStart_Option& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUStart_Option* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUStart_Option* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUStart_Option* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUStart_Option>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUStart_Option& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUStart_Option& from) {
    SLUStart_Option::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUStart_Option* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUStart.Option";
  }
  protected:
  explicit SLUStart_Option(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // repeated string value = 2;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, std::size_t size);
  void set_value(int index, absl::string_view value);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, std::size_t size);
  void add_value(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_value();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_value();

  public:
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUStart.Option)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> value_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUStart final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUStart) */ {
 public:
  inline SLUStart() : SLUStart(nullptr) {}
  ~SLUStart() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUStart(::google::protobuf::internal::ConstantInitialized);

  SLUStart(const SLUStart& from);
  SLUStart(SLUStart&& from) noexcept
    : SLUStart() {
    *this = ::std::move(from);
  }

  inline SLUStart& operator=(const SLUStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUStart& operator=(SLUStart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUStart& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUStart* internal_default_instance() {
    return reinterpret_cast<const SLUStart*>(
               &_SLUStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SLUStart& a, SLUStart& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUStart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUStart* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUStart* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUStart>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUStart& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUStart& from) {
    SLUStart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUStart* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUStart";
  }
  protected:
  explicit SLUStart(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLUStart_Option Option;

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 2,
    kAppIdFieldNumber = 1,
  };
  // repeated .speechly.slu.v1.SLUStart.Option options = 2;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::speechly::slu::v1::SLUStart_Option* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUStart_Option >*
      mutable_options();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUStart_Option>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUStart_Option>* _internal_mutable_options();
  public:
  const ::speechly::slu::v1::SLUStart_Option& options(int index) const;
  ::speechly::slu::v1::SLUStart_Option* add_options();
  const ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUStart_Option >&
      options() const;
  // string app_id = 1;
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUStart)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUStart_Option > options_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUStop final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUStop) */ {
 public:
  inline SLUStop() : SLUStop(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUStop(::google::protobuf::internal::ConstantInitialized);

  SLUStop(const SLUStop& from);
  SLUStop(SLUStop&& from) noexcept
    : SLUStop() {
    *this = ::std::move(from);
  }

  inline SLUStop& operator=(const SLUStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUStop& operator=(SLUStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUStop* internal_default_instance() {
    return reinterpret_cast<const SLUStop*>(
               &_SLUStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SLUStop& a, SLUStop& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUStop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUStop>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SLUStop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SLUStop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUStop";
  }
  protected:
  explicit SLUStop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUStop)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUResponse) */ {
 public:
  inline SLUResponse() : SLUResponse(nullptr) {}
  ~SLUResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUResponse(::google::protobuf::internal::ConstantInitialized);

  SLUResponse(const SLUResponse& from);
  SLUResponse(SLUResponse&& from) noexcept
    : SLUResponse() {
    *this = ::std::move(from);
  }

  inline SLUResponse& operator=(const SLUResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUResponse& operator=(SLUResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUResponse& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingResponseCase {
    kTranscript = 3,
    kEntity = 4,
    kIntent = 5,
    kSegmentEnd = 6,
    kTentativeTranscript = 7,
    kTentativeEntities = 8,
    kTentativeIntent = 9,
    kStarted = 10,
    kFinished = 11,
    kRttRequest = 12,
    STREAMING_RESPONSE_NOT_SET = 0,
  };

  static inline const SLUResponse* internal_default_instance() {
    return reinterpret_cast<const SLUResponse*>(
               &_SLUResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SLUResponse& a, SLUResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUResponse& from) {
    SLUResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUResponse";
  }
  protected:
  explicit SLUResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioContextFieldNumber = 1,
    kSegmentIdFieldNumber = 2,
    kTranscriptFieldNumber = 3,
    kEntityFieldNumber = 4,
    kIntentFieldNumber = 5,
    kSegmentEndFieldNumber = 6,
    kTentativeTranscriptFieldNumber = 7,
    kTentativeEntitiesFieldNumber = 8,
    kTentativeIntentFieldNumber = 9,
    kStartedFieldNumber = 10,
    kFinishedFieldNumber = 11,
    kRttRequestFieldNumber = 12,
  };
  // string audio_context = 1;
  void clear_audio_context() ;
  const std::string& audio_context() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_context(Arg_&& arg, Args_... args);
  std::string* mutable_audio_context();
  PROTOBUF_NODISCARD std::string* release_audio_context();
  void set_allocated_audio_context(std::string* ptr);

  private:
  const std::string& _internal_audio_context() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_context(
      const std::string& value);
  std::string* _internal_mutable_audio_context();

  public:
  // int32 segment_id = 2;
  void clear_segment_id() ;
  ::int32_t segment_id() const;
  void set_segment_id(::int32_t value);

  private:
  ::int32_t _internal_segment_id() const;
  void _internal_set_segment_id(::int32_t value);

  public:
  // .speechly.slu.v1.SLUTranscript transcript = 3;
  bool has_transcript() const;
  private:
  bool _internal_has_transcript() const;

  public:
  void clear_transcript() ;
  const ::speechly::slu::v1::SLUTranscript& transcript() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUTranscript* release_transcript();
  ::speechly::slu::v1::SLUTranscript* mutable_transcript();
  void set_allocated_transcript(::speechly::slu::v1::SLUTranscript* value);
  void unsafe_arena_set_allocated_transcript(::speechly::slu::v1::SLUTranscript* value);
  ::speechly::slu::v1::SLUTranscript* unsafe_arena_release_transcript();

  private:
  const ::speechly::slu::v1::SLUTranscript& _internal_transcript() const;
  ::speechly::slu::v1::SLUTranscript* _internal_mutable_transcript();

  public:
  // .speechly.slu.v1.SLUEntity entity = 4;
  bool has_entity() const;
  private:
  bool _internal_has_entity() const;

  public:
  void clear_entity() ;
  const ::speechly::slu::v1::SLUEntity& entity() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUEntity* release_entity();
  ::speechly::slu::v1::SLUEntity* mutable_entity();
  void set_allocated_entity(::speechly::slu::v1::SLUEntity* value);
  void unsafe_arena_set_allocated_entity(::speechly::slu::v1::SLUEntity* value);
  ::speechly::slu::v1::SLUEntity* unsafe_arena_release_entity();

  private:
  const ::speechly::slu::v1::SLUEntity& _internal_entity() const;
  ::speechly::slu::v1::SLUEntity* _internal_mutable_entity();

  public:
  // .speechly.slu.v1.SLUIntent intent = 5;
  bool has_intent() const;
  private:
  bool _internal_has_intent() const;

  public:
  void clear_intent() ;
  const ::speechly::slu::v1::SLUIntent& intent() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUIntent* release_intent();
  ::speechly::slu::v1::SLUIntent* mutable_intent();
  void set_allocated_intent(::speechly::slu::v1::SLUIntent* value);
  void unsafe_arena_set_allocated_intent(::speechly::slu::v1::SLUIntent* value);
  ::speechly::slu::v1::SLUIntent* unsafe_arena_release_intent();

  private:
  const ::speechly::slu::v1::SLUIntent& _internal_intent() const;
  ::speechly::slu::v1::SLUIntent* _internal_mutable_intent();

  public:
  // .speechly.slu.v1.SLUSegmentEnd segment_end = 6;
  bool has_segment_end() const;
  private:
  bool _internal_has_segment_end() const;

  public:
  void clear_segment_end() ;
  const ::speechly::slu::v1::SLUSegmentEnd& segment_end() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUSegmentEnd* release_segment_end();
  ::speechly::slu::v1::SLUSegmentEnd* mutable_segment_end();
  void set_allocated_segment_end(::speechly::slu::v1::SLUSegmentEnd* value);
  void unsafe_arena_set_allocated_segment_end(::speechly::slu::v1::SLUSegmentEnd* value);
  ::speechly::slu::v1::SLUSegmentEnd* unsafe_arena_release_segment_end();

  private:
  const ::speechly::slu::v1::SLUSegmentEnd& _internal_segment_end() const;
  ::speechly::slu::v1::SLUSegmentEnd* _internal_mutable_segment_end();

  public:
  // .speechly.slu.v1.SLUTentativeTranscript tentative_transcript = 7;
  bool has_tentative_transcript() const;
  private:
  bool _internal_has_tentative_transcript() const;

  public:
  void clear_tentative_transcript() ;
  const ::speechly::slu::v1::SLUTentativeTranscript& tentative_transcript() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUTentativeTranscript* release_tentative_transcript();
  ::speechly::slu::v1::SLUTentativeTranscript* mutable_tentative_transcript();
  void set_allocated_tentative_transcript(::speechly::slu::v1::SLUTentativeTranscript* value);
  void unsafe_arena_set_allocated_tentative_transcript(::speechly::slu::v1::SLUTentativeTranscript* value);
  ::speechly::slu::v1::SLUTentativeTranscript* unsafe_arena_release_tentative_transcript();

  private:
  const ::speechly::slu::v1::SLUTentativeTranscript& _internal_tentative_transcript() const;
  ::speechly::slu::v1::SLUTentativeTranscript* _internal_mutable_tentative_transcript();

  public:
  // .speechly.slu.v1.SLUTentativeEntities tentative_entities = 8;
  bool has_tentative_entities() const;
  private:
  bool _internal_has_tentative_entities() const;

  public:
  void clear_tentative_entities() ;
  const ::speechly::slu::v1::SLUTentativeEntities& tentative_entities() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUTentativeEntities* release_tentative_entities();
  ::speechly::slu::v1::SLUTentativeEntities* mutable_tentative_entities();
  void set_allocated_tentative_entities(::speechly::slu::v1::SLUTentativeEntities* value);
  void unsafe_arena_set_allocated_tentative_entities(::speechly::slu::v1::SLUTentativeEntities* value);
  ::speechly::slu::v1::SLUTentativeEntities* unsafe_arena_release_tentative_entities();

  private:
  const ::speechly::slu::v1::SLUTentativeEntities& _internal_tentative_entities() const;
  ::speechly::slu::v1::SLUTentativeEntities* _internal_mutable_tentative_entities();

  public:
  // .speechly.slu.v1.SLUIntent tentative_intent = 9;
  bool has_tentative_intent() const;
  private:
  bool _internal_has_tentative_intent() const;

  public:
  void clear_tentative_intent() ;
  const ::speechly::slu::v1::SLUIntent& tentative_intent() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUIntent* release_tentative_intent();
  ::speechly::slu::v1::SLUIntent* mutable_tentative_intent();
  void set_allocated_tentative_intent(::speechly::slu::v1::SLUIntent* value);
  void unsafe_arena_set_allocated_tentative_intent(::speechly::slu::v1::SLUIntent* value);
  ::speechly::slu::v1::SLUIntent* unsafe_arena_release_tentative_intent();

  private:
  const ::speechly::slu::v1::SLUIntent& _internal_tentative_intent() const;
  ::speechly::slu::v1::SLUIntent* _internal_mutable_tentative_intent();

  public:
  // .speechly.slu.v1.SLUStarted started = 10;
  bool has_started() const;
  private:
  bool _internal_has_started() const;

  public:
  void clear_started() ;
  const ::speechly::slu::v1::SLUStarted& started() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUStarted* release_started();
  ::speechly::slu::v1::SLUStarted* mutable_started();
  void set_allocated_started(::speechly::slu::v1::SLUStarted* value);
  void unsafe_arena_set_allocated_started(::speechly::slu::v1::SLUStarted* value);
  ::speechly::slu::v1::SLUStarted* unsafe_arena_release_started();

  private:
  const ::speechly::slu::v1::SLUStarted& _internal_started() const;
  ::speechly::slu::v1::SLUStarted* _internal_mutable_started();

  public:
  // .speechly.slu.v1.SLUFinished finished = 11;
  bool has_finished() const;
  private:
  bool _internal_has_finished() const;

  public:
  void clear_finished() ;
  const ::speechly::slu::v1::SLUFinished& finished() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUFinished* release_finished();
  ::speechly::slu::v1::SLUFinished* mutable_finished();
  void set_allocated_finished(::speechly::slu::v1::SLUFinished* value);
  void unsafe_arena_set_allocated_finished(::speechly::slu::v1::SLUFinished* value);
  ::speechly::slu::v1::SLUFinished* unsafe_arena_release_finished();

  private:
  const ::speechly::slu::v1::SLUFinished& _internal_finished() const;
  ::speechly::slu::v1::SLUFinished* _internal_mutable_finished();

  public:
  // .speechly.slu.v1.RoundTripMeasurementRequest rtt_request = 12;
  bool has_rtt_request() const;
  private:
  bool _internal_has_rtt_request() const;

  public:
  void clear_rtt_request() ;
  const ::speechly::slu::v1::RoundTripMeasurementRequest& rtt_request() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::RoundTripMeasurementRequest* release_rtt_request();
  ::speechly::slu::v1::RoundTripMeasurementRequest* mutable_rtt_request();
  void set_allocated_rtt_request(::speechly::slu::v1::RoundTripMeasurementRequest* value);
  void unsafe_arena_set_allocated_rtt_request(::speechly::slu::v1::RoundTripMeasurementRequest* value);
  ::speechly::slu::v1::RoundTripMeasurementRequest* unsafe_arena_release_rtt_request();

  private:
  const ::speechly::slu::v1::RoundTripMeasurementRequest& _internal_rtt_request() const;
  ::speechly::slu::v1::RoundTripMeasurementRequest* _internal_mutable_rtt_request();

  public:
  void clear_streaming_response();
  StreamingResponseCase streaming_response_case() const;
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUResponse)
 private:
  class _Internal;
  void set_has_transcript();
  void set_has_entity();
  void set_has_intent();
  void set_has_segment_end();
  void set_has_tentative_transcript();
  void set_has_tentative_entities();
  void set_has_tentative_intent();
  void set_has_started();
  void set_has_finished();
  void set_has_rtt_request();

  inline bool has_streaming_response() const;
  inline void clear_has_streaming_response();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 12, 10, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr audio_context_;
    ::int32_t segment_id_;
    union StreamingResponseUnion {
      constexpr StreamingResponseUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::speechly::slu::v1::SLUTranscript* transcript_;
      ::speechly::slu::v1::SLUEntity* entity_;
      ::speechly::slu::v1::SLUIntent* intent_;
      ::speechly::slu::v1::SLUSegmentEnd* segment_end_;
      ::speechly::slu::v1::SLUTentativeTranscript* tentative_transcript_;
      ::speechly::slu::v1::SLUTentativeEntities* tentative_entities_;
      ::speechly::slu::v1::SLUIntent* tentative_intent_;
      ::speechly::slu::v1::SLUStarted* started_;
      ::speechly::slu::v1::SLUFinished* finished_;
      ::speechly::slu::v1::RoundTripMeasurementRequest* rtt_request_;
    } streaming_response_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUTranscript final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUTranscript) */ {
 public:
  inline SLUTranscript() : SLUTranscript(nullptr) {}
  ~SLUTranscript() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUTranscript(::google::protobuf::internal::ConstantInitialized);

  SLUTranscript(const SLUTranscript& from);
  SLUTranscript(SLUTranscript&& from) noexcept
    : SLUTranscript() {
    *this = ::std::move(from);
  }

  inline SLUTranscript& operator=(const SLUTranscript& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUTranscript& operator=(SLUTranscript&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUTranscript& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUTranscript* internal_default_instance() {
    return reinterpret_cast<const SLUTranscript*>(
               &_SLUTranscript_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SLUTranscript& a, SLUTranscript& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUTranscript* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUTranscript* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUTranscript* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUTranscript>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUTranscript& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUTranscript& from) {
    SLUTranscript::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUTranscript* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUTranscript";
  }
  protected:
  explicit SLUTranscript(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordFieldNumber = 1,
    kIndexFieldNumber = 2,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
  };
  // string word = 1;
  void clear_word() ;
  const std::string& word() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_word(Arg_&& arg, Args_... args);
  std::string* mutable_word();
  PROTOBUF_NODISCARD std::string* release_word();
  void set_allocated_word(std::string* ptr);

  private:
  const std::string& _internal_word() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_word(
      const std::string& value);
  std::string* _internal_mutable_word();

  public:
  // int32 index = 2;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // int32 start_time = 3;
  void clear_start_time() ;
  ::int32_t start_time() const;
  void set_start_time(::int32_t value);

  private:
  ::int32_t _internal_start_time() const;
  void _internal_set_start_time(::int32_t value);

  public:
  // int32 end_time = 4;
  void clear_end_time() ;
  ::int32_t end_time() const;
  void set_end_time(::int32_t value);

  private:
  ::int32_t _internal_end_time() const;
  void _internal_set_end_time(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUTranscript)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 42, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr word_;
    ::int32_t index_;
    ::int32_t start_time_;
    ::int32_t end_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUEntity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUEntity) */ {
 public:
  inline SLUEntity() : SLUEntity(nullptr) {}
  ~SLUEntity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUEntity(::google::protobuf::internal::ConstantInitialized);

  SLUEntity(const SLUEntity& from);
  SLUEntity(SLUEntity&& from) noexcept
    : SLUEntity() {
    *this = ::std::move(from);
  }

  inline SLUEntity& operator=(const SLUEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUEntity& operator=(SLUEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUEntity* internal_default_instance() {
    return reinterpret_cast<const SLUEntity*>(
               &_SLUEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SLUEntity& a, SLUEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUEntity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUEntity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUEntity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUEntity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUEntity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUEntity& from) {
    SLUEntity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUEntity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUEntity";
  }
  protected:
  explicit SLUEntity(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 1,
    kValueFieldNumber = 2,
    kStartPositionFieldNumber = 3,
    kEndPositionFieldNumber = 4,
  };
  // string entity = 1;
  void clear_entity() ;
  const std::string& entity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity(Arg_&& arg, Args_... args);
  std::string* mutable_entity();
  PROTOBUF_NODISCARD std::string* release_entity();
  void set_allocated_entity(std::string* ptr);

  private:
  const std::string& _internal_entity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity(
      const std::string& value);
  std::string* _internal_mutable_entity();

  public:
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // int32 start_position = 3;
  void clear_start_position() ;
  ::int32_t start_position() const;
  void set_start_position(::int32_t value);

  private:
  ::int32_t _internal_start_position() const;
  void _internal_set_start_position(::int32_t value);

  public:
  // int32 end_position = 4;
  void clear_end_position() ;
  ::int32_t end_position() const;
  void set_end_position(::int32_t value);

  private:
  ::int32_t _internal_end_position() const;
  void _internal_set_end_position(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUEntity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 45, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr entity_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::int32_t start_position_;
    ::int32_t end_position_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUIntent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUIntent) */ {
 public:
  inline SLUIntent() : SLUIntent(nullptr) {}
  ~SLUIntent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUIntent(::google::protobuf::internal::ConstantInitialized);

  SLUIntent(const SLUIntent& from);
  SLUIntent(SLUIntent&& from) noexcept
    : SLUIntent() {
    *this = ::std::move(from);
  }

  inline SLUIntent& operator=(const SLUIntent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUIntent& operator=(SLUIntent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUIntent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUIntent* internal_default_instance() {
    return reinterpret_cast<const SLUIntent*>(
               &_SLUIntent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SLUIntent& a, SLUIntent& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUIntent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUIntent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUIntent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUIntent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUIntent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUIntent& from) {
    SLUIntent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUIntent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUIntent";
  }
  protected:
  explicit SLUIntent(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntentFieldNumber = 1,
  };
  // string intent = 1;
  void clear_intent() ;
  const std::string& intent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_intent(Arg_&& arg, Args_... args);
  std::string* mutable_intent();
  PROTOBUF_NODISCARD std::string* release_intent();
  void set_allocated_intent(std::string* ptr);

  private:
  const std::string& _internal_intent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_intent(
      const std::string& value);
  std::string* _internal_mutable_intent();

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUIntent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 40, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr intent_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUSegmentEnd final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUSegmentEnd) */ {
 public:
  inline SLUSegmentEnd() : SLUSegmentEnd(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUSegmentEnd(::google::protobuf::internal::ConstantInitialized);

  SLUSegmentEnd(const SLUSegmentEnd& from);
  SLUSegmentEnd(SLUSegmentEnd&& from) noexcept
    : SLUSegmentEnd() {
    *this = ::std::move(from);
  }

  inline SLUSegmentEnd& operator=(const SLUSegmentEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUSegmentEnd& operator=(SLUSegmentEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUSegmentEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUSegmentEnd* internal_default_instance() {
    return reinterpret_cast<const SLUSegmentEnd*>(
               &_SLUSegmentEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SLUSegmentEnd& a, SLUSegmentEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUSegmentEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUSegmentEnd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUSegmentEnd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUSegmentEnd>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SLUSegmentEnd& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SLUSegmentEnd& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUSegmentEnd";
  }
  protected:
  explicit SLUSegmentEnd(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUSegmentEnd)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUTentativeTranscript final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUTentativeTranscript) */ {
 public:
  inline SLUTentativeTranscript() : SLUTentativeTranscript(nullptr) {}
  ~SLUTentativeTranscript() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUTentativeTranscript(::google::protobuf::internal::ConstantInitialized);

  SLUTentativeTranscript(const SLUTentativeTranscript& from);
  SLUTentativeTranscript(SLUTentativeTranscript&& from) noexcept
    : SLUTentativeTranscript() {
    *this = ::std::move(from);
  }

  inline SLUTentativeTranscript& operator=(const SLUTentativeTranscript& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUTentativeTranscript& operator=(SLUTentativeTranscript&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUTentativeTranscript& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUTentativeTranscript* internal_default_instance() {
    return reinterpret_cast<const SLUTentativeTranscript*>(
               &_SLUTentativeTranscript_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SLUTentativeTranscript& a, SLUTentativeTranscript& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUTentativeTranscript* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUTentativeTranscript* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUTentativeTranscript* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUTentativeTranscript>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUTentativeTranscript& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUTentativeTranscript& from) {
    SLUTentativeTranscript::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUTentativeTranscript* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUTentativeTranscript";
  }
  protected:
  explicit SLUTentativeTranscript(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTentativeWordsFieldNumber = 2,
    kTentativeTranscriptFieldNumber = 1,
  };
  // repeated .speechly.slu.v1.SLUTranscript tentative_words = 2;
  int tentative_words_size() const;
  private:
  int _internal_tentative_words_size() const;

  public:
  void clear_tentative_words() ;
  ::speechly::slu::v1::SLUTranscript* mutable_tentative_words(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUTranscript >*
      mutable_tentative_words();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUTranscript>& _internal_tentative_words() const;
  ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUTranscript>* _internal_mutable_tentative_words();
  public:
  const ::speechly::slu::v1::SLUTranscript& tentative_words(int index) const;
  ::speechly::slu::v1::SLUTranscript* add_tentative_words();
  const ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUTranscript >&
      tentative_words() const;
  // string tentative_transcript = 1;
  void clear_tentative_transcript() ;
  const std::string& tentative_transcript() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tentative_transcript(Arg_&& arg, Args_... args);
  std::string* mutable_tentative_transcript();
  PROTOBUF_NODISCARD std::string* release_tentative_transcript();
  void set_allocated_tentative_transcript(std::string* ptr);

  private:
  const std::string& _internal_tentative_transcript() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tentative_transcript(
      const std::string& value);
  std::string* _internal_mutable_tentative_transcript();

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUTentativeTranscript)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 67, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUTranscript > tentative_words_;
    ::google::protobuf::internal::ArenaStringPtr tentative_transcript_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUTentativeEntities final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUTentativeEntities) */ {
 public:
  inline SLUTentativeEntities() : SLUTentativeEntities(nullptr) {}
  ~SLUTentativeEntities() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUTentativeEntities(::google::protobuf::internal::ConstantInitialized);

  SLUTentativeEntities(const SLUTentativeEntities& from);
  SLUTentativeEntities(SLUTentativeEntities&& from) noexcept
    : SLUTentativeEntities() {
    *this = ::std::move(from);
  }

  inline SLUTentativeEntities& operator=(const SLUTentativeEntities& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUTentativeEntities& operator=(SLUTentativeEntities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUTentativeEntities& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUTentativeEntities* internal_default_instance() {
    return reinterpret_cast<const SLUTentativeEntities*>(
               &_SLUTentativeEntities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SLUTentativeEntities& a, SLUTentativeEntities& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUTentativeEntities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUTentativeEntities* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUTentativeEntities* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUTentativeEntities>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUTentativeEntities& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUTentativeEntities& from) {
    SLUTentativeEntities::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUTentativeEntities* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUTentativeEntities";
  }
  protected:
  explicit SLUTentativeEntities(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTentativeEntitiesFieldNumber = 1,
  };
  // repeated .speechly.slu.v1.SLUEntity tentative_entities = 1;
  int tentative_entities_size() const;
  private:
  int _internal_tentative_entities_size() const;

  public:
  void clear_tentative_entities() ;
  ::speechly::slu::v1::SLUEntity* mutable_tentative_entities(int index);
  ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUEntity >*
      mutable_tentative_entities();
  private:
  const ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUEntity>& _internal_tentative_entities() const;
  ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUEntity>* _internal_mutable_tentative_entities();
  public:
  const ::speechly::slu::v1::SLUEntity& tentative_entities(int index) const;
  ::speechly::slu::v1::SLUEntity* add_tentative_entities();
  const ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUEntity >&
      tentative_entities() const;
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUTentativeEntities)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUEntity > tentative_entities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUStarted final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUStarted) */ {
 public:
  inline SLUStarted() : SLUStarted(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUStarted(::google::protobuf::internal::ConstantInitialized);

  SLUStarted(const SLUStarted& from);
  SLUStarted(SLUStarted&& from) noexcept
    : SLUStarted() {
    *this = ::std::move(from);
  }

  inline SLUStarted& operator=(const SLUStarted& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUStarted& operator=(SLUStarted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUStarted& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUStarted* internal_default_instance() {
    return reinterpret_cast<const SLUStarted*>(
               &_SLUStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SLUStarted& a, SLUStarted& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUStarted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUStarted* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUStarted* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUStarted>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SLUStarted& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SLUStarted& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUStarted";
  }
  protected:
  explicit SLUStarted(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUStarted)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUFinished final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUFinished) */ {
 public:
  inline SLUFinished() : SLUFinished(nullptr) {}
  ~SLUFinished() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUFinished(::google::protobuf::internal::ConstantInitialized);

  SLUFinished(const SLUFinished& from);
  SLUFinished(SLUFinished&& from) noexcept
    : SLUFinished() {
    *this = ::std::move(from);
  }

  inline SLUFinished& operator=(const SLUFinished& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUFinished& operator=(SLUFinished&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUFinished& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUFinished* internal_default_instance() {
    return reinterpret_cast<const SLUFinished*>(
               &_SLUFinished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SLUFinished& a, SLUFinished& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUFinished* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUFinished* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUFinished* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUFinished>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUFinished& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUFinished& from) {
    SLUFinished::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUFinished* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUFinished";
  }
  protected:
  explicit SLUFinished(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
  };
  // .speechly.slu.v1.SLUError error = 2;
  bool has_error() const;
  void clear_error() ;
  const ::speechly::slu::v1::SLUError& error() const;
  PROTOBUF_NODISCARD ::speechly::slu::v1::SLUError* release_error();
  ::speechly::slu::v1::SLUError* mutable_error();
  void set_allocated_error(::speechly::slu::v1::SLUError* value);
  void unsafe_arena_set_allocated_error(::speechly::slu::v1::SLUError* value);
  ::speechly::slu::v1::SLUError* unsafe_arena_release_error();

  private:
  const ::speechly::slu::v1::SLUError& _internal_error() const;
  ::speechly::slu::v1::SLUError* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUFinished)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::speechly::slu::v1::SLUError* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class SLUError final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.SLUError) */ {
 public:
  inline SLUError() : SLUError(nullptr) {}
  ~SLUError() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SLUError(::google::protobuf::internal::ConstantInitialized);

  SLUError(const SLUError& from);
  SLUError(SLUError&& from) noexcept
    : SLUError() {
    *this = ::std::move(from);
  }

  inline SLUError& operator=(const SLUError& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUError& operator=(SLUError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLUError& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLUError* internal_default_instance() {
    return reinterpret_cast<const SLUError*>(
               &_SLUError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SLUError& a, SLUError& b) {
    a.Swap(&b);
  }
  inline void Swap(SLUError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLUError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLUError* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLUError>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLUError& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SLUError& from) {
    SLUError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUError* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.SLUError";
  }
  protected:
  explicit SLUError(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string code = 1;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* ptr);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.SLUError)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class RoundTripMeasurementRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.RoundTripMeasurementRequest) */ {
 public:
  inline RoundTripMeasurementRequest() : RoundTripMeasurementRequest(nullptr) {}
  ~RoundTripMeasurementRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoundTripMeasurementRequest(::google::protobuf::internal::ConstantInitialized);

  RoundTripMeasurementRequest(const RoundTripMeasurementRequest& from);
  RoundTripMeasurementRequest(RoundTripMeasurementRequest&& from) noexcept
    : RoundTripMeasurementRequest() {
    *this = ::std::move(from);
  }

  inline RoundTripMeasurementRequest& operator=(const RoundTripMeasurementRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoundTripMeasurementRequest& operator=(RoundTripMeasurementRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoundTripMeasurementRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoundTripMeasurementRequest* internal_default_instance() {
    return reinterpret_cast<const RoundTripMeasurementRequest*>(
               &_RoundTripMeasurementRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RoundTripMeasurementRequest& a, RoundTripMeasurementRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RoundTripMeasurementRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoundTripMeasurementRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoundTripMeasurementRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoundTripMeasurementRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoundTripMeasurementRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoundTripMeasurementRequest& from) {
    RoundTripMeasurementRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoundTripMeasurementRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.RoundTripMeasurementRequest";
  }
  protected:
  explicit RoundTripMeasurementRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.RoundTripMeasurementRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};// -------------------------------------------------------------------

class RoundTripMeasurementResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechly.slu.v1.RoundTripMeasurementResponse) */ {
 public:
  inline RoundTripMeasurementResponse() : RoundTripMeasurementResponse(nullptr) {}
  ~RoundTripMeasurementResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoundTripMeasurementResponse(::google::protobuf::internal::ConstantInitialized);

  RoundTripMeasurementResponse(const RoundTripMeasurementResponse& from);
  RoundTripMeasurementResponse(RoundTripMeasurementResponse&& from) noexcept
    : RoundTripMeasurementResponse() {
    *this = ::std::move(from);
  }

  inline RoundTripMeasurementResponse& operator=(const RoundTripMeasurementResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoundTripMeasurementResponse& operator=(RoundTripMeasurementResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoundTripMeasurementResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoundTripMeasurementResponse* internal_default_instance() {
    return reinterpret_cast<const RoundTripMeasurementResponse*>(
               &_RoundTripMeasurementResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RoundTripMeasurementResponse& a, RoundTripMeasurementResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RoundTripMeasurementResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoundTripMeasurementResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoundTripMeasurementResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoundTripMeasurementResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoundTripMeasurementResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoundTripMeasurementResponse& from) {
    RoundTripMeasurementResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoundTripMeasurementResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "speechly.slu.v1.RoundTripMeasurementResponse";
  }
  protected:
  explicit RoundTripMeasurementResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:speechly.slu.v1.RoundTripMeasurementResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_speechly_2fslu_2fv1_2fslu_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SLURequest

// .speechly.slu.v1.SLUConfig config = 1;
inline bool SLURequest::has_config() const {
  return streaming_request_case() == kConfig;
}
inline bool SLURequest::_internal_has_config() const {
  return streaming_request_case() == kConfig;
}
inline void SLURequest::set_has_config() {
  _impl_._oneof_case_[0] = kConfig;
}
inline void SLURequest::clear_config() {
  if (streaming_request_case() == kConfig) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_request_.config_;
    }
    clear_has_streaming_request();
  }
}
inline ::speechly::slu::v1::SLUConfig* SLURequest::release_config() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLURequest.config)
  if (streaming_request_case() == kConfig) {
    clear_has_streaming_request();
    ::speechly::slu::v1::SLUConfig* temp = _impl_.streaming_request_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_request_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUConfig& SLURequest::_internal_config() const {
  return streaming_request_case() == kConfig
      ? *_impl_.streaming_request_.config_
      : reinterpret_cast<::speechly::slu::v1::SLUConfig&>(::speechly::slu::v1::_SLUConfig_default_instance_);
}
inline const ::speechly::slu::v1::SLUConfig& SLURequest::config() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLURequest.config)
  return _internal_config();
}
inline ::speechly::slu::v1::SLUConfig* SLURequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLURequest.config)
  if (streaming_request_case() == kConfig) {
    clear_has_streaming_request();
    ::speechly::slu::v1::SLUConfig* temp = _impl_.streaming_request_.config_;
    _impl_.streaming_request_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLURequest::unsafe_arena_set_allocated_config(::speechly::slu::v1::SLUConfig* config) {
  clear_streaming_request();
  if (config) {
    set_has_config();
    _impl_.streaming_request_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLURequest.config)
}
inline ::speechly::slu::v1::SLUConfig* SLURequest::_internal_mutable_config() {
  if (streaming_request_case() != kConfig) {
    clear_streaming_request();
    set_has_config();
    _impl_.streaming_request_.config_ = CreateMaybeMessage< ::speechly::slu::v1::SLUConfig >(GetArenaForAllocation());
  }
  return _impl_.streaming_request_.config_;
}
inline ::speechly::slu::v1::SLUConfig* SLURequest::mutable_config() {
  ::speechly::slu::v1::SLUConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLURequest.config)
  return _msg;
}

// .speechly.slu.v1.SLUEvent event = 2 [deprecated = true];
inline bool SLURequest::has_event() const {
  return streaming_request_case() == kEvent;
}
inline bool SLURequest::_internal_has_event() const {
  return streaming_request_case() == kEvent;
}
inline void SLURequest::set_has_event() {
  _impl_._oneof_case_[0] = kEvent;
}
inline void SLURequest::clear_event() {
  if (streaming_request_case() == kEvent) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_request_.event_;
    }
    clear_has_streaming_request();
  }
}
inline ::speechly::slu::v1::SLUEvent* SLURequest::release_event() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLURequest.event)
  if (streaming_request_case() == kEvent) {
    clear_has_streaming_request();
    ::speechly::slu::v1::SLUEvent* temp = _impl_.streaming_request_.event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_request_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUEvent& SLURequest::_internal_event() const {
  return streaming_request_case() == kEvent
      ? *_impl_.streaming_request_.event_
      : reinterpret_cast<::speechly::slu::v1::SLUEvent&>(::speechly::slu::v1::_SLUEvent_default_instance_);
}
inline const ::speechly::slu::v1::SLUEvent& SLURequest::event() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLURequest.event)
  return _internal_event();
}
inline ::speechly::slu::v1::SLUEvent* SLURequest::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLURequest.event)
  if (streaming_request_case() == kEvent) {
    clear_has_streaming_request();
    ::speechly::slu::v1::SLUEvent* temp = _impl_.streaming_request_.event_;
    _impl_.streaming_request_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLURequest::unsafe_arena_set_allocated_event(::speechly::slu::v1::SLUEvent* event) {
  clear_streaming_request();
  if (event) {
    set_has_event();
    _impl_.streaming_request_.event_ = event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLURequest.event)
}
inline ::speechly::slu::v1::SLUEvent* SLURequest::_internal_mutable_event() {
  if (streaming_request_case() != kEvent) {
    clear_streaming_request();
    set_has_event();
    _impl_.streaming_request_.event_ = CreateMaybeMessage< ::speechly::slu::v1::SLUEvent >(GetArenaForAllocation());
  }
  return _impl_.streaming_request_.event_;
}
inline ::speechly::slu::v1::SLUEvent* SLURequest::mutable_event() {
  ::speechly::slu::v1::SLUEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLURequest.event)
  return _msg;
}

// bytes audio = 3;
inline bool SLURequest::has_audio() const {
  return streaming_request_case() == kAudio;
}
inline void SLURequest::set_has_audio() {
  _impl_._oneof_case_[0] = kAudio;
}
inline void SLURequest::clear_audio() {
  if (streaming_request_case() == kAudio) {
    _impl_.streaming_request_.audio_.Destroy();
    clear_has_streaming_request();
  }
}
inline const std::string& SLURequest::audio() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLURequest.audio)
  return _internal_audio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLURequest::set_audio(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (streaming_request_case() != kAudio) {
    clear_streaming_request();

    set_has_audio();
    _impl_.streaming_request_.audio_.InitDefault();
  }
  _impl_.streaming_request_.audio_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLURequest.audio)
}
inline std::string* SLURequest::mutable_audio() {
  std::string* _s = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLURequest.audio)
  return _s;
}
inline const std::string& SLURequest::_internal_audio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (streaming_request_case() != kAudio) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.streaming_request_.audio_.Get();
}
inline void SLURequest::_internal_set_audio(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (streaming_request_case() != kAudio) {
    clear_streaming_request();

    set_has_audio();
    _impl_.streaming_request_.audio_.InitDefault();
  }
  _impl_.streaming_request_.audio_.Set(value, GetArenaForAllocation());
}
inline std::string* SLURequest::_internal_mutable_audio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (streaming_request_case() != kAudio) {
    clear_streaming_request();

    set_has_audio();
    _impl_.streaming_request_.audio_.InitDefault();
  }
  return _impl_.streaming_request_.audio_.Mutable( GetArenaForAllocation());
}
inline std::string* SLURequest::release_audio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLURequest.audio)
  if (streaming_request_case() != kAudio) {
    return nullptr;
  }
  clear_has_streaming_request();
  return _impl_.streaming_request_.audio_.Release();
}
inline void SLURequest::set_allocated_audio(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_streaming_request()) {
    clear_streaming_request();
  }
  if (value != nullptr) {
    set_has_audio();
    _impl_.streaming_request_.audio_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLURequest.audio)
}

// .speechly.slu.v1.RoundTripMeasurementResponse rtt_response = 4;
inline bool SLURequest::has_rtt_response() const {
  return streaming_request_case() == kRttResponse;
}
inline bool SLURequest::_internal_has_rtt_response() const {
  return streaming_request_case() == kRttResponse;
}
inline void SLURequest::set_has_rtt_response() {
  _impl_._oneof_case_[0] = kRttResponse;
}
inline void SLURequest::clear_rtt_response() {
  if (streaming_request_case() == kRttResponse) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_request_.rtt_response_;
    }
    clear_has_streaming_request();
  }
}
inline ::speechly::slu::v1::RoundTripMeasurementResponse* SLURequest::release_rtt_response() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLURequest.rtt_response)
  if (streaming_request_case() == kRttResponse) {
    clear_has_streaming_request();
    ::speechly::slu::v1::RoundTripMeasurementResponse* temp = _impl_.streaming_request_.rtt_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_request_.rtt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::RoundTripMeasurementResponse& SLURequest::_internal_rtt_response() const {
  return streaming_request_case() == kRttResponse
      ? *_impl_.streaming_request_.rtt_response_
      : reinterpret_cast<::speechly::slu::v1::RoundTripMeasurementResponse&>(::speechly::slu::v1::_RoundTripMeasurementResponse_default_instance_);
}
inline const ::speechly::slu::v1::RoundTripMeasurementResponse& SLURequest::rtt_response() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLURequest.rtt_response)
  return _internal_rtt_response();
}
inline ::speechly::slu::v1::RoundTripMeasurementResponse* SLURequest::unsafe_arena_release_rtt_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLURequest.rtt_response)
  if (streaming_request_case() == kRttResponse) {
    clear_has_streaming_request();
    ::speechly::slu::v1::RoundTripMeasurementResponse* temp = _impl_.streaming_request_.rtt_response_;
    _impl_.streaming_request_.rtt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLURequest::unsafe_arena_set_allocated_rtt_response(::speechly::slu::v1::RoundTripMeasurementResponse* rtt_response) {
  clear_streaming_request();
  if (rtt_response) {
    set_has_rtt_response();
    _impl_.streaming_request_.rtt_response_ = rtt_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLURequest.rtt_response)
}
inline ::speechly::slu::v1::RoundTripMeasurementResponse* SLURequest::_internal_mutable_rtt_response() {
  if (streaming_request_case() != kRttResponse) {
    clear_streaming_request();
    set_has_rtt_response();
    _impl_.streaming_request_.rtt_response_ = CreateMaybeMessage< ::speechly::slu::v1::RoundTripMeasurementResponse >(GetArenaForAllocation());
  }
  return _impl_.streaming_request_.rtt_response_;
}
inline ::speechly::slu::v1::RoundTripMeasurementResponse* SLURequest::mutable_rtt_response() {
  ::speechly::slu::v1::RoundTripMeasurementResponse* _msg = _internal_mutable_rtt_response();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLURequest.rtt_response)
  return _msg;
}

// .speechly.slu.v1.SLUStart start = 5;
inline bool SLURequest::has_start() const {
  return streaming_request_case() == kStart;
}
inline bool SLURequest::_internal_has_start() const {
  return streaming_request_case() == kStart;
}
inline void SLURequest::set_has_start() {
  _impl_._oneof_case_[0] = kStart;
}
inline void SLURequest::clear_start() {
  if (streaming_request_case() == kStart) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_request_.start_;
    }
    clear_has_streaming_request();
  }
}
inline ::speechly::slu::v1::SLUStart* SLURequest::release_start() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLURequest.start)
  if (streaming_request_case() == kStart) {
    clear_has_streaming_request();
    ::speechly::slu::v1::SLUStart* temp = _impl_.streaming_request_.start_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_request_.start_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUStart& SLURequest::_internal_start() const {
  return streaming_request_case() == kStart
      ? *_impl_.streaming_request_.start_
      : reinterpret_cast<::speechly::slu::v1::SLUStart&>(::speechly::slu::v1::_SLUStart_default_instance_);
}
inline const ::speechly::slu::v1::SLUStart& SLURequest::start() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLURequest.start)
  return _internal_start();
}
inline ::speechly::slu::v1::SLUStart* SLURequest::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLURequest.start)
  if (streaming_request_case() == kStart) {
    clear_has_streaming_request();
    ::speechly::slu::v1::SLUStart* temp = _impl_.streaming_request_.start_;
    _impl_.streaming_request_.start_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLURequest::unsafe_arena_set_allocated_start(::speechly::slu::v1::SLUStart* start) {
  clear_streaming_request();
  if (start) {
    set_has_start();
    _impl_.streaming_request_.start_ = start;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLURequest.start)
}
inline ::speechly::slu::v1::SLUStart* SLURequest::_internal_mutable_start() {
  if (streaming_request_case() != kStart) {
    clear_streaming_request();
    set_has_start();
    _impl_.streaming_request_.start_ = CreateMaybeMessage< ::speechly::slu::v1::SLUStart >(GetArenaForAllocation());
  }
  return _impl_.streaming_request_.start_;
}
inline ::speechly::slu::v1::SLUStart* SLURequest::mutable_start() {
  ::speechly::slu::v1::SLUStart* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLURequest.start)
  return _msg;
}

// .speechly.slu.v1.SLUStop stop = 6;
inline bool SLURequest::has_stop() const {
  return streaming_request_case() == kStop;
}
inline bool SLURequest::_internal_has_stop() const {
  return streaming_request_case() == kStop;
}
inline void SLURequest::set_has_stop() {
  _impl_._oneof_case_[0] = kStop;
}
inline void SLURequest::clear_stop() {
  if (streaming_request_case() == kStop) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_request_.stop_;
    }
    clear_has_streaming_request();
  }
}
inline ::speechly::slu::v1::SLUStop* SLURequest::release_stop() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLURequest.stop)
  if (streaming_request_case() == kStop) {
    clear_has_streaming_request();
    ::speechly::slu::v1::SLUStop* temp = _impl_.streaming_request_.stop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_request_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUStop& SLURequest::_internal_stop() const {
  return streaming_request_case() == kStop
      ? *_impl_.streaming_request_.stop_
      : reinterpret_cast<::speechly::slu::v1::SLUStop&>(::speechly::slu::v1::_SLUStop_default_instance_);
}
inline const ::speechly::slu::v1::SLUStop& SLURequest::stop() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLURequest.stop)
  return _internal_stop();
}
inline ::speechly::slu::v1::SLUStop* SLURequest::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLURequest.stop)
  if (streaming_request_case() == kStop) {
    clear_has_streaming_request();
    ::speechly::slu::v1::SLUStop* temp = _impl_.streaming_request_.stop_;
    _impl_.streaming_request_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLURequest::unsafe_arena_set_allocated_stop(::speechly::slu::v1::SLUStop* stop) {
  clear_streaming_request();
  if (stop) {
    set_has_stop();
    _impl_.streaming_request_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLURequest.stop)
}
inline ::speechly::slu::v1::SLUStop* SLURequest::_internal_mutable_stop() {
  if (streaming_request_case() != kStop) {
    clear_streaming_request();
    set_has_stop();
    _impl_.streaming_request_.stop_ = CreateMaybeMessage< ::speechly::slu::v1::SLUStop >(GetArenaForAllocation());
  }
  return _impl_.streaming_request_.stop_;
}
inline ::speechly::slu::v1::SLUStop* SLURequest::mutable_stop() {
  ::speechly::slu::v1::SLUStop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLURequest.stop)
  return _msg;
}

inline bool SLURequest::has_streaming_request() const {
  return streaming_request_case() != STREAMING_REQUEST_NOT_SET;
}
inline void SLURequest::clear_has_streaming_request() {
  _impl_._oneof_case_[0] = STREAMING_REQUEST_NOT_SET;
}
inline SLURequest::StreamingRequestCase SLURequest::streaming_request_case() const {
  return SLURequest::StreamingRequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLUConfig_Option

// string key = 1;
inline void SLUConfig_Option::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SLUConfig_Option::key() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUConfig.Option.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUConfig_Option::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUConfig.Option.key)
}
inline std::string* SLUConfig_Option::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUConfig.Option.key)
  return _s;
}
inline const std::string& SLUConfig_Option::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void SLUConfig_Option::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUConfig_Option::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUConfig_Option::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUConfig.Option.key)
  return _impl_.key_.Release();
}
inline void SLUConfig_Option::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUConfig.Option.key)
}

// repeated string value = 2;
inline int SLUConfig_Option::_internal_value_size() const {
  return _internal_value().size();
}
inline int SLUConfig_Option::value_size() const {
  return _internal_value_size();
}
inline void SLUConfig_Option::clear_value() {
  _internal_mutable_value()->Clear();
}
inline std::string* SLUConfig_Option::add_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_value()->Add();
  // @@protoc_insertion_point(field_add_mutable:speechly.slu.v1.SLUConfig.Option.value)
  return _s;
}
inline const std::string& SLUConfig_Option::value(int index) const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUConfig.Option.value)
  return _internal_value().Get(index);
}
inline std::string* SLUConfig_Option::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUConfig.Option.value)
  return _internal_mutable_value()->Mutable(index);
}
inline void SLUConfig_Option::set_value(int index, const std::string& value) {
  _internal_mutable_value()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUConfig.Option.value)
}
inline void SLUConfig_Option::set_value(int index, std::string&& value) {
  _internal_mutable_value()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUConfig.Option.value)
}
inline void SLUConfig_Option::set_value(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_value()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speechly.slu.v1.SLUConfig.Option.value)
}
inline void SLUConfig_Option::set_value(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_value()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speechly.slu.v1.SLUConfig.Option.value)
}
inline void SLUConfig_Option::set_value(int index, absl::string_view value) {
  _internal_mutable_value()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:speechly.slu.v1.SLUConfig.Option.value)
}
inline void SLUConfig_Option::add_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:speechly.slu.v1.SLUConfig.Option.value)
}
inline void SLUConfig_Option::add_value(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:speechly.slu.v1.SLUConfig.Option.value)
}
inline void SLUConfig_Option::add_value(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speechly.slu.v1.SLUConfig.Option.value)
}
inline void SLUConfig_Option::add_value(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speechly.slu.v1.SLUConfig.Option.value)
}
inline void SLUConfig_Option::add_value(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:speechly.slu.v1.SLUConfig.Option.value)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SLUConfig_Option::value() const {
  // @@protoc_insertion_point(field_list:speechly.slu.v1.SLUConfig.Option.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SLUConfig_Option::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:speechly.slu.v1.SLUConfig.Option.value)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SLUConfig_Option::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SLUConfig_Option::_internal_mutable_value() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// SLUConfig

// .speechly.slu.v1.SLUConfig.Encoding encoding = 1;
inline void SLUConfig::clear_encoding() {
  _impl_.encoding_ = 0;
}
inline ::speechly::slu::v1::SLUConfig_Encoding SLUConfig::encoding() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUConfig.encoding)
  return _internal_encoding();
}
inline void SLUConfig::set_encoding(::speechly::slu::v1::SLUConfig_Encoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUConfig.encoding)
}
inline ::speechly::slu::v1::SLUConfig_Encoding SLUConfig::_internal_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::slu::v1::SLUConfig_Encoding>(_impl_.encoding_);
}
inline void SLUConfig::_internal_set_encoding(::speechly::slu::v1::SLUConfig_Encoding value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoding_ = value;
}

// int32 channels = 2;
inline void SLUConfig::clear_channels() {
  _impl_.channels_ = 0;
}
inline ::int32_t SLUConfig::channels() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUConfig.channels)
  return _internal_channels();
}
inline void SLUConfig::set_channels(::int32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUConfig.channels)
}
inline ::int32_t SLUConfig::_internal_channels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channels_;
}
inline void SLUConfig::_internal_set_channels(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channels_ = value;
}

// int32 sample_rate_hertz = 3;
inline void SLUConfig::clear_sample_rate_hertz() {
  _impl_.sample_rate_hertz_ = 0;
}
inline ::int32_t SLUConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUConfig.sample_rate_hertz)
  return _internal_sample_rate_hertz();
}
inline void SLUConfig::set_sample_rate_hertz(::int32_t value) {
  _internal_set_sample_rate_hertz(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUConfig.sample_rate_hertz)
}
inline ::int32_t SLUConfig::_internal_sample_rate_hertz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_rate_hertz_;
}
inline void SLUConfig::_internal_set_sample_rate_hertz(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sample_rate_hertz_ = value;
}

// string language_code = 4;
inline void SLUConfig::clear_language_code() {
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& SLUConfig::language_code() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUConfig.language_code)
  return _internal_language_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUConfig::set_language_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUConfig.language_code)
}
inline std::string* SLUConfig::mutable_language_code() {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUConfig.language_code)
  return _s;
}
inline const std::string& SLUConfig::_internal_language_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_code_.Get();
}
inline void SLUConfig::_internal_set_language_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUConfig::_internal_mutable_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.language_code_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUConfig::release_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUConfig.language_code)
  return _impl_.language_code_.Release();
}
inline void SLUConfig::set_allocated_language_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_code_.IsDefault()) {
          _impl_.language_code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUConfig.language_code)
}

// repeated .speechly.slu.v1.SLUConfig.Option options = 5;
inline int SLUConfig::_internal_options_size() const {
  return _internal_options().size();
}
inline int SLUConfig::options_size() const {
  return _internal_options_size();
}
inline void SLUConfig::clear_options() {
  _internal_mutable_options()->Clear();
}
inline ::speechly::slu::v1::SLUConfig_Option* SLUConfig::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUConfig.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUConfig_Option >*
SLUConfig::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:speechly.slu.v1.SLUConfig.options)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_options();
}
inline const ::speechly::slu::v1::SLUConfig_Option& SLUConfig::options(int index) const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUConfig.options)
    return _internal_options().Get(index);
}
inline ::speechly::slu::v1::SLUConfig_Option* SLUConfig::add_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::slu::v1::SLUConfig_Option* _add = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add:speechly.slu.v1.SLUConfig.options)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUConfig_Option >&
SLUConfig::options() const {
  // @@protoc_insertion_point(field_list:speechly.slu.v1.SLUConfig.options)
  return _internal_options();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUConfig_Option>&
SLUConfig::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUConfig_Option>*
SLUConfig::_internal_mutable_options() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.options_;
}

// -------------------------------------------------------------------

// SLUEvent

// .speechly.slu.v1.SLUEvent.Event event = 1;
inline void SLUEvent::clear_event() {
  _impl_.event_ = 0;
}
inline ::speechly::slu::v1::SLUEvent_Event SLUEvent::event() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUEvent.event)
  return _internal_event();
}
inline void SLUEvent::set_event(::speechly::slu::v1::SLUEvent_Event value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUEvent.event)
}
inline ::speechly::slu::v1::SLUEvent_Event SLUEvent::_internal_event() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::speechly::slu::v1::SLUEvent_Event>(_impl_.event_);
}
inline void SLUEvent::_internal_set_event(::speechly::slu::v1::SLUEvent_Event value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.event_ = value;
}

// string app_id = 2;
inline void SLUEvent::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& SLUEvent::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUEvent.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUEvent::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUEvent.app_id)
}
inline std::string* SLUEvent::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUEvent.app_id)
  return _s;
}
inline const std::string& SLUEvent::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void SLUEvent::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUEvent::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUEvent::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUEvent.app_id)
  return _impl_.app_id_.Release();
}
inline void SLUEvent::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUEvent.app_id)
}

// -------------------------------------------------------------------

// SLUStart_Option

// string key = 1;
inline void SLUStart_Option::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SLUStart_Option::key() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUStart.Option.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUStart_Option::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUStart.Option.key)
}
inline std::string* SLUStart_Option::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUStart.Option.key)
  return _s;
}
inline const std::string& SLUStart_Option::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void SLUStart_Option::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUStart_Option::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUStart_Option::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUStart.Option.key)
  return _impl_.key_.Release();
}
inline void SLUStart_Option::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUStart.Option.key)
}

// repeated string value = 2;
inline int SLUStart_Option::_internal_value_size() const {
  return _internal_value().size();
}
inline int SLUStart_Option::value_size() const {
  return _internal_value_size();
}
inline void SLUStart_Option::clear_value() {
  _internal_mutable_value()->Clear();
}
inline std::string* SLUStart_Option::add_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_value()->Add();
  // @@protoc_insertion_point(field_add_mutable:speechly.slu.v1.SLUStart.Option.value)
  return _s;
}
inline const std::string& SLUStart_Option::value(int index) const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUStart.Option.value)
  return _internal_value().Get(index);
}
inline std::string* SLUStart_Option::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUStart.Option.value)
  return _internal_mutable_value()->Mutable(index);
}
inline void SLUStart_Option::set_value(int index, const std::string& value) {
  _internal_mutable_value()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUStart.Option.value)
}
inline void SLUStart_Option::set_value(int index, std::string&& value) {
  _internal_mutable_value()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUStart.Option.value)
}
inline void SLUStart_Option::set_value(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_value()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speechly.slu.v1.SLUStart.Option.value)
}
inline void SLUStart_Option::set_value(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_value()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speechly.slu.v1.SLUStart.Option.value)
}
inline void SLUStart_Option::set_value(int index, absl::string_view value) {
  _internal_mutable_value()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:speechly.slu.v1.SLUStart.Option.value)
}
inline void SLUStart_Option::add_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:speechly.slu.v1.SLUStart.Option.value)
}
inline void SLUStart_Option::add_value(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:speechly.slu.v1.SLUStart.Option.value)
}
inline void SLUStart_Option::add_value(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speechly.slu.v1.SLUStart.Option.value)
}
inline void SLUStart_Option::add_value(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speechly.slu.v1.SLUStart.Option.value)
}
inline void SLUStart_Option::add_value(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:speechly.slu.v1.SLUStart.Option.value)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SLUStart_Option::value() const {
  // @@protoc_insertion_point(field_list:speechly.slu.v1.SLUStart.Option.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SLUStart_Option::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:speechly.slu.v1.SLUStart.Option.value)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SLUStart_Option::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SLUStart_Option::_internal_mutable_value() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// SLUStart

// string app_id = 1;
inline void SLUStart::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& SLUStart::app_id() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUStart.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUStart::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUStart.app_id)
}
inline std::string* SLUStart::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUStart.app_id)
  return _s;
}
inline const std::string& SLUStart::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void SLUStart::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUStart::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUStart::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUStart.app_id)
  return _impl_.app_id_.Release();
}
inline void SLUStart::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUStart.app_id)
}

// repeated .speechly.slu.v1.SLUStart.Option options = 2;
inline int SLUStart::_internal_options_size() const {
  return _internal_options().size();
}
inline int SLUStart::options_size() const {
  return _internal_options_size();
}
inline void SLUStart::clear_options() {
  _internal_mutable_options()->Clear();
}
inline ::speechly::slu::v1::SLUStart_Option* SLUStart::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUStart.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUStart_Option >*
SLUStart::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:speechly.slu.v1.SLUStart.options)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_options();
}
inline const ::speechly::slu::v1::SLUStart_Option& SLUStart::options(int index) const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUStart.options)
    return _internal_options().Get(index);
}
inline ::speechly::slu::v1::SLUStart_Option* SLUStart::add_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::slu::v1::SLUStart_Option* _add = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add:speechly.slu.v1.SLUStart.options)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUStart_Option >&
SLUStart::options() const {
  // @@protoc_insertion_point(field_list:speechly.slu.v1.SLUStart.options)
  return _internal_options();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUStart_Option>&
SLUStart::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUStart_Option>*
SLUStart::_internal_mutable_options() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.options_;
}

// -------------------------------------------------------------------

// SLUStop

// -------------------------------------------------------------------

// SLUResponse

// string audio_context = 1;
inline void SLUResponse::clear_audio_context() {
  _impl_.audio_context_.ClearToEmpty();
}
inline const std::string& SLUResponse::audio_context() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.audio_context)
  return _internal_audio_context();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUResponse::set_audio_context(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_context_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUResponse.audio_context)
}
inline std::string* SLUResponse::mutable_audio_context() {
  std::string* _s = _internal_mutable_audio_context();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.audio_context)
  return _s;
}
inline const std::string& SLUResponse::_internal_audio_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_context_.Get();
}
inline void SLUResponse::_internal_set_audio_context(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_context_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUResponse::_internal_mutable_audio_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.audio_context_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUResponse::release_audio_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.audio_context)
  return _impl_.audio_context_.Release();
}
inline void SLUResponse::set_allocated_audio_context(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_context_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.audio_context_.IsDefault()) {
          _impl_.audio_context_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUResponse.audio_context)
}

// int32 segment_id = 2;
inline void SLUResponse::clear_segment_id() {
  _impl_.segment_id_ = 0;
}
inline ::int32_t SLUResponse::segment_id() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.segment_id)
  return _internal_segment_id();
}
inline void SLUResponse::set_segment_id(::int32_t value) {
  _internal_set_segment_id(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUResponse.segment_id)
}
inline ::int32_t SLUResponse::_internal_segment_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segment_id_;
}
inline void SLUResponse::_internal_set_segment_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.segment_id_ = value;
}

// .speechly.slu.v1.SLUTranscript transcript = 3;
inline bool SLUResponse::has_transcript() const {
  return streaming_response_case() == kTranscript;
}
inline bool SLUResponse::_internal_has_transcript() const {
  return streaming_response_case() == kTranscript;
}
inline void SLUResponse::set_has_transcript() {
  _impl_._oneof_case_[0] = kTranscript;
}
inline void SLUResponse::clear_transcript() {
  if (streaming_response_case() == kTranscript) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.transcript_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::SLUTranscript* SLUResponse::release_transcript() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.transcript)
  if (streaming_response_case() == kTranscript) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUTranscript* temp = _impl_.streaming_response_.transcript_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.transcript_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUTranscript& SLUResponse::_internal_transcript() const {
  return streaming_response_case() == kTranscript
      ? *_impl_.streaming_response_.transcript_
      : reinterpret_cast<::speechly::slu::v1::SLUTranscript&>(::speechly::slu::v1::_SLUTranscript_default_instance_);
}
inline const ::speechly::slu::v1::SLUTranscript& SLUResponse::transcript() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.transcript)
  return _internal_transcript();
}
inline ::speechly::slu::v1::SLUTranscript* SLUResponse::unsafe_arena_release_transcript() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.transcript)
  if (streaming_response_case() == kTranscript) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUTranscript* temp = _impl_.streaming_response_.transcript_;
    _impl_.streaming_response_.transcript_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_transcript(::speechly::slu::v1::SLUTranscript* transcript) {
  clear_streaming_response();
  if (transcript) {
    set_has_transcript();
    _impl_.streaming_response_.transcript_ = transcript;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.transcript)
}
inline ::speechly::slu::v1::SLUTranscript* SLUResponse::_internal_mutable_transcript() {
  if (streaming_response_case() != kTranscript) {
    clear_streaming_response();
    set_has_transcript();
    _impl_.streaming_response_.transcript_ = CreateMaybeMessage< ::speechly::slu::v1::SLUTranscript >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.transcript_;
}
inline ::speechly::slu::v1::SLUTranscript* SLUResponse::mutable_transcript() {
  ::speechly::slu::v1::SLUTranscript* _msg = _internal_mutable_transcript();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.transcript)
  return _msg;
}

// .speechly.slu.v1.SLUEntity entity = 4;
inline bool SLUResponse::has_entity() const {
  return streaming_response_case() == kEntity;
}
inline bool SLUResponse::_internal_has_entity() const {
  return streaming_response_case() == kEntity;
}
inline void SLUResponse::set_has_entity() {
  _impl_._oneof_case_[0] = kEntity;
}
inline void SLUResponse::clear_entity() {
  if (streaming_response_case() == kEntity) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.entity_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::SLUEntity* SLUResponse::release_entity() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.entity)
  if (streaming_response_case() == kEntity) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUEntity* temp = _impl_.streaming_response_.entity_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUEntity& SLUResponse::_internal_entity() const {
  return streaming_response_case() == kEntity
      ? *_impl_.streaming_response_.entity_
      : reinterpret_cast<::speechly::slu::v1::SLUEntity&>(::speechly::slu::v1::_SLUEntity_default_instance_);
}
inline const ::speechly::slu::v1::SLUEntity& SLUResponse::entity() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.entity)
  return _internal_entity();
}
inline ::speechly::slu::v1::SLUEntity* SLUResponse::unsafe_arena_release_entity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.entity)
  if (streaming_response_case() == kEntity) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUEntity* temp = _impl_.streaming_response_.entity_;
    _impl_.streaming_response_.entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_entity(::speechly::slu::v1::SLUEntity* entity) {
  clear_streaming_response();
  if (entity) {
    set_has_entity();
    _impl_.streaming_response_.entity_ = entity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.entity)
}
inline ::speechly::slu::v1::SLUEntity* SLUResponse::_internal_mutable_entity() {
  if (streaming_response_case() != kEntity) {
    clear_streaming_response();
    set_has_entity();
    _impl_.streaming_response_.entity_ = CreateMaybeMessage< ::speechly::slu::v1::SLUEntity >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.entity_;
}
inline ::speechly::slu::v1::SLUEntity* SLUResponse::mutable_entity() {
  ::speechly::slu::v1::SLUEntity* _msg = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.entity)
  return _msg;
}

// .speechly.slu.v1.SLUIntent intent = 5;
inline bool SLUResponse::has_intent() const {
  return streaming_response_case() == kIntent;
}
inline bool SLUResponse::_internal_has_intent() const {
  return streaming_response_case() == kIntent;
}
inline void SLUResponse::set_has_intent() {
  _impl_._oneof_case_[0] = kIntent;
}
inline void SLUResponse::clear_intent() {
  if (streaming_response_case() == kIntent) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.intent_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::SLUIntent* SLUResponse::release_intent() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.intent)
  if (streaming_response_case() == kIntent) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUIntent* temp = _impl_.streaming_response_.intent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.intent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUIntent& SLUResponse::_internal_intent() const {
  return streaming_response_case() == kIntent
      ? *_impl_.streaming_response_.intent_
      : reinterpret_cast<::speechly::slu::v1::SLUIntent&>(::speechly::slu::v1::_SLUIntent_default_instance_);
}
inline const ::speechly::slu::v1::SLUIntent& SLUResponse::intent() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.intent)
  return _internal_intent();
}
inline ::speechly::slu::v1::SLUIntent* SLUResponse::unsafe_arena_release_intent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.intent)
  if (streaming_response_case() == kIntent) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUIntent* temp = _impl_.streaming_response_.intent_;
    _impl_.streaming_response_.intent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_intent(::speechly::slu::v1::SLUIntent* intent) {
  clear_streaming_response();
  if (intent) {
    set_has_intent();
    _impl_.streaming_response_.intent_ = intent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.intent)
}
inline ::speechly::slu::v1::SLUIntent* SLUResponse::_internal_mutable_intent() {
  if (streaming_response_case() != kIntent) {
    clear_streaming_response();
    set_has_intent();
    _impl_.streaming_response_.intent_ = CreateMaybeMessage< ::speechly::slu::v1::SLUIntent >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.intent_;
}
inline ::speechly::slu::v1::SLUIntent* SLUResponse::mutable_intent() {
  ::speechly::slu::v1::SLUIntent* _msg = _internal_mutable_intent();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.intent)
  return _msg;
}

// .speechly.slu.v1.SLUSegmentEnd segment_end = 6;
inline bool SLUResponse::has_segment_end() const {
  return streaming_response_case() == kSegmentEnd;
}
inline bool SLUResponse::_internal_has_segment_end() const {
  return streaming_response_case() == kSegmentEnd;
}
inline void SLUResponse::set_has_segment_end() {
  _impl_._oneof_case_[0] = kSegmentEnd;
}
inline void SLUResponse::clear_segment_end() {
  if (streaming_response_case() == kSegmentEnd) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.segment_end_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::SLUSegmentEnd* SLUResponse::release_segment_end() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.segment_end)
  if (streaming_response_case() == kSegmentEnd) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUSegmentEnd* temp = _impl_.streaming_response_.segment_end_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.segment_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUSegmentEnd& SLUResponse::_internal_segment_end() const {
  return streaming_response_case() == kSegmentEnd
      ? *_impl_.streaming_response_.segment_end_
      : reinterpret_cast<::speechly::slu::v1::SLUSegmentEnd&>(::speechly::slu::v1::_SLUSegmentEnd_default_instance_);
}
inline const ::speechly::slu::v1::SLUSegmentEnd& SLUResponse::segment_end() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.segment_end)
  return _internal_segment_end();
}
inline ::speechly::slu::v1::SLUSegmentEnd* SLUResponse::unsafe_arena_release_segment_end() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.segment_end)
  if (streaming_response_case() == kSegmentEnd) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUSegmentEnd* temp = _impl_.streaming_response_.segment_end_;
    _impl_.streaming_response_.segment_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_segment_end(::speechly::slu::v1::SLUSegmentEnd* segment_end) {
  clear_streaming_response();
  if (segment_end) {
    set_has_segment_end();
    _impl_.streaming_response_.segment_end_ = segment_end;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.segment_end)
}
inline ::speechly::slu::v1::SLUSegmentEnd* SLUResponse::_internal_mutable_segment_end() {
  if (streaming_response_case() != kSegmentEnd) {
    clear_streaming_response();
    set_has_segment_end();
    _impl_.streaming_response_.segment_end_ = CreateMaybeMessage< ::speechly::slu::v1::SLUSegmentEnd >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.segment_end_;
}
inline ::speechly::slu::v1::SLUSegmentEnd* SLUResponse::mutable_segment_end() {
  ::speechly::slu::v1::SLUSegmentEnd* _msg = _internal_mutable_segment_end();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.segment_end)
  return _msg;
}

// .speechly.slu.v1.SLUTentativeTranscript tentative_transcript = 7;
inline bool SLUResponse::has_tentative_transcript() const {
  return streaming_response_case() == kTentativeTranscript;
}
inline bool SLUResponse::_internal_has_tentative_transcript() const {
  return streaming_response_case() == kTentativeTranscript;
}
inline void SLUResponse::set_has_tentative_transcript() {
  _impl_._oneof_case_[0] = kTentativeTranscript;
}
inline void SLUResponse::clear_tentative_transcript() {
  if (streaming_response_case() == kTentativeTranscript) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.tentative_transcript_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::SLUTentativeTranscript* SLUResponse::release_tentative_transcript() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.tentative_transcript)
  if (streaming_response_case() == kTentativeTranscript) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUTentativeTranscript* temp = _impl_.streaming_response_.tentative_transcript_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.tentative_transcript_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUTentativeTranscript& SLUResponse::_internal_tentative_transcript() const {
  return streaming_response_case() == kTentativeTranscript
      ? *_impl_.streaming_response_.tentative_transcript_
      : reinterpret_cast<::speechly::slu::v1::SLUTentativeTranscript&>(::speechly::slu::v1::_SLUTentativeTranscript_default_instance_);
}
inline const ::speechly::slu::v1::SLUTentativeTranscript& SLUResponse::tentative_transcript() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.tentative_transcript)
  return _internal_tentative_transcript();
}
inline ::speechly::slu::v1::SLUTentativeTranscript* SLUResponse::unsafe_arena_release_tentative_transcript() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.tentative_transcript)
  if (streaming_response_case() == kTentativeTranscript) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUTentativeTranscript* temp = _impl_.streaming_response_.tentative_transcript_;
    _impl_.streaming_response_.tentative_transcript_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_tentative_transcript(::speechly::slu::v1::SLUTentativeTranscript* tentative_transcript) {
  clear_streaming_response();
  if (tentative_transcript) {
    set_has_tentative_transcript();
    _impl_.streaming_response_.tentative_transcript_ = tentative_transcript;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.tentative_transcript)
}
inline ::speechly::slu::v1::SLUTentativeTranscript* SLUResponse::_internal_mutable_tentative_transcript() {
  if (streaming_response_case() != kTentativeTranscript) {
    clear_streaming_response();
    set_has_tentative_transcript();
    _impl_.streaming_response_.tentative_transcript_ = CreateMaybeMessage< ::speechly::slu::v1::SLUTentativeTranscript >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.tentative_transcript_;
}
inline ::speechly::slu::v1::SLUTentativeTranscript* SLUResponse::mutable_tentative_transcript() {
  ::speechly::slu::v1::SLUTentativeTranscript* _msg = _internal_mutable_tentative_transcript();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.tentative_transcript)
  return _msg;
}

// .speechly.slu.v1.SLUTentativeEntities tentative_entities = 8;
inline bool SLUResponse::has_tentative_entities() const {
  return streaming_response_case() == kTentativeEntities;
}
inline bool SLUResponse::_internal_has_tentative_entities() const {
  return streaming_response_case() == kTentativeEntities;
}
inline void SLUResponse::set_has_tentative_entities() {
  _impl_._oneof_case_[0] = kTentativeEntities;
}
inline void SLUResponse::clear_tentative_entities() {
  if (streaming_response_case() == kTentativeEntities) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.tentative_entities_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::SLUTentativeEntities* SLUResponse::release_tentative_entities() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.tentative_entities)
  if (streaming_response_case() == kTentativeEntities) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUTentativeEntities* temp = _impl_.streaming_response_.tentative_entities_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.tentative_entities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUTentativeEntities& SLUResponse::_internal_tentative_entities() const {
  return streaming_response_case() == kTentativeEntities
      ? *_impl_.streaming_response_.tentative_entities_
      : reinterpret_cast<::speechly::slu::v1::SLUTentativeEntities&>(::speechly::slu::v1::_SLUTentativeEntities_default_instance_);
}
inline const ::speechly::slu::v1::SLUTentativeEntities& SLUResponse::tentative_entities() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.tentative_entities)
  return _internal_tentative_entities();
}
inline ::speechly::slu::v1::SLUTentativeEntities* SLUResponse::unsafe_arena_release_tentative_entities() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.tentative_entities)
  if (streaming_response_case() == kTentativeEntities) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUTentativeEntities* temp = _impl_.streaming_response_.tentative_entities_;
    _impl_.streaming_response_.tentative_entities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_tentative_entities(::speechly::slu::v1::SLUTentativeEntities* tentative_entities) {
  clear_streaming_response();
  if (tentative_entities) {
    set_has_tentative_entities();
    _impl_.streaming_response_.tentative_entities_ = tentative_entities;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.tentative_entities)
}
inline ::speechly::slu::v1::SLUTentativeEntities* SLUResponse::_internal_mutable_tentative_entities() {
  if (streaming_response_case() != kTentativeEntities) {
    clear_streaming_response();
    set_has_tentative_entities();
    _impl_.streaming_response_.tentative_entities_ = CreateMaybeMessage< ::speechly::slu::v1::SLUTentativeEntities >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.tentative_entities_;
}
inline ::speechly::slu::v1::SLUTentativeEntities* SLUResponse::mutable_tentative_entities() {
  ::speechly::slu::v1::SLUTentativeEntities* _msg = _internal_mutable_tentative_entities();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.tentative_entities)
  return _msg;
}

// .speechly.slu.v1.SLUIntent tentative_intent = 9;
inline bool SLUResponse::has_tentative_intent() const {
  return streaming_response_case() == kTentativeIntent;
}
inline bool SLUResponse::_internal_has_tentative_intent() const {
  return streaming_response_case() == kTentativeIntent;
}
inline void SLUResponse::set_has_tentative_intent() {
  _impl_._oneof_case_[0] = kTentativeIntent;
}
inline void SLUResponse::clear_tentative_intent() {
  if (streaming_response_case() == kTentativeIntent) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.tentative_intent_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::SLUIntent* SLUResponse::release_tentative_intent() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.tentative_intent)
  if (streaming_response_case() == kTentativeIntent) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUIntent* temp = _impl_.streaming_response_.tentative_intent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.tentative_intent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUIntent& SLUResponse::_internal_tentative_intent() const {
  return streaming_response_case() == kTentativeIntent
      ? *_impl_.streaming_response_.tentative_intent_
      : reinterpret_cast<::speechly::slu::v1::SLUIntent&>(::speechly::slu::v1::_SLUIntent_default_instance_);
}
inline const ::speechly::slu::v1::SLUIntent& SLUResponse::tentative_intent() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.tentative_intent)
  return _internal_tentative_intent();
}
inline ::speechly::slu::v1::SLUIntent* SLUResponse::unsafe_arena_release_tentative_intent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.tentative_intent)
  if (streaming_response_case() == kTentativeIntent) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUIntent* temp = _impl_.streaming_response_.tentative_intent_;
    _impl_.streaming_response_.tentative_intent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_tentative_intent(::speechly::slu::v1::SLUIntent* tentative_intent) {
  clear_streaming_response();
  if (tentative_intent) {
    set_has_tentative_intent();
    _impl_.streaming_response_.tentative_intent_ = tentative_intent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.tentative_intent)
}
inline ::speechly::slu::v1::SLUIntent* SLUResponse::_internal_mutable_tentative_intent() {
  if (streaming_response_case() != kTentativeIntent) {
    clear_streaming_response();
    set_has_tentative_intent();
    _impl_.streaming_response_.tentative_intent_ = CreateMaybeMessage< ::speechly::slu::v1::SLUIntent >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.tentative_intent_;
}
inline ::speechly::slu::v1::SLUIntent* SLUResponse::mutable_tentative_intent() {
  ::speechly::slu::v1::SLUIntent* _msg = _internal_mutable_tentative_intent();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.tentative_intent)
  return _msg;
}

// .speechly.slu.v1.SLUStarted started = 10;
inline bool SLUResponse::has_started() const {
  return streaming_response_case() == kStarted;
}
inline bool SLUResponse::_internal_has_started() const {
  return streaming_response_case() == kStarted;
}
inline void SLUResponse::set_has_started() {
  _impl_._oneof_case_[0] = kStarted;
}
inline void SLUResponse::clear_started() {
  if (streaming_response_case() == kStarted) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.started_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::SLUStarted* SLUResponse::release_started() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.started)
  if (streaming_response_case() == kStarted) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUStarted* temp = _impl_.streaming_response_.started_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUStarted& SLUResponse::_internal_started() const {
  return streaming_response_case() == kStarted
      ? *_impl_.streaming_response_.started_
      : reinterpret_cast<::speechly::slu::v1::SLUStarted&>(::speechly::slu::v1::_SLUStarted_default_instance_);
}
inline const ::speechly::slu::v1::SLUStarted& SLUResponse::started() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.started)
  return _internal_started();
}
inline ::speechly::slu::v1::SLUStarted* SLUResponse::unsafe_arena_release_started() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.started)
  if (streaming_response_case() == kStarted) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUStarted* temp = _impl_.streaming_response_.started_;
    _impl_.streaming_response_.started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_started(::speechly::slu::v1::SLUStarted* started) {
  clear_streaming_response();
  if (started) {
    set_has_started();
    _impl_.streaming_response_.started_ = started;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.started)
}
inline ::speechly::slu::v1::SLUStarted* SLUResponse::_internal_mutable_started() {
  if (streaming_response_case() != kStarted) {
    clear_streaming_response();
    set_has_started();
    _impl_.streaming_response_.started_ = CreateMaybeMessage< ::speechly::slu::v1::SLUStarted >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.started_;
}
inline ::speechly::slu::v1::SLUStarted* SLUResponse::mutable_started() {
  ::speechly::slu::v1::SLUStarted* _msg = _internal_mutable_started();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.started)
  return _msg;
}

// .speechly.slu.v1.SLUFinished finished = 11;
inline bool SLUResponse::has_finished() const {
  return streaming_response_case() == kFinished;
}
inline bool SLUResponse::_internal_has_finished() const {
  return streaming_response_case() == kFinished;
}
inline void SLUResponse::set_has_finished() {
  _impl_._oneof_case_[0] = kFinished;
}
inline void SLUResponse::clear_finished() {
  if (streaming_response_case() == kFinished) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.finished_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::SLUFinished* SLUResponse::release_finished() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.finished)
  if (streaming_response_case() == kFinished) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUFinished* temp = _impl_.streaming_response_.finished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.finished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::SLUFinished& SLUResponse::_internal_finished() const {
  return streaming_response_case() == kFinished
      ? *_impl_.streaming_response_.finished_
      : reinterpret_cast<::speechly::slu::v1::SLUFinished&>(::speechly::slu::v1::_SLUFinished_default_instance_);
}
inline const ::speechly::slu::v1::SLUFinished& SLUResponse::finished() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.finished)
  return _internal_finished();
}
inline ::speechly::slu::v1::SLUFinished* SLUResponse::unsafe_arena_release_finished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.finished)
  if (streaming_response_case() == kFinished) {
    clear_has_streaming_response();
    ::speechly::slu::v1::SLUFinished* temp = _impl_.streaming_response_.finished_;
    _impl_.streaming_response_.finished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_finished(::speechly::slu::v1::SLUFinished* finished) {
  clear_streaming_response();
  if (finished) {
    set_has_finished();
    _impl_.streaming_response_.finished_ = finished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.finished)
}
inline ::speechly::slu::v1::SLUFinished* SLUResponse::_internal_mutable_finished() {
  if (streaming_response_case() != kFinished) {
    clear_streaming_response();
    set_has_finished();
    _impl_.streaming_response_.finished_ = CreateMaybeMessage< ::speechly::slu::v1::SLUFinished >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.finished_;
}
inline ::speechly::slu::v1::SLUFinished* SLUResponse::mutable_finished() {
  ::speechly::slu::v1::SLUFinished* _msg = _internal_mutable_finished();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.finished)
  return _msg;
}

// .speechly.slu.v1.RoundTripMeasurementRequest rtt_request = 12;
inline bool SLUResponse::has_rtt_request() const {
  return streaming_response_case() == kRttRequest;
}
inline bool SLUResponse::_internal_has_rtt_request() const {
  return streaming_response_case() == kRttRequest;
}
inline void SLUResponse::set_has_rtt_request() {
  _impl_._oneof_case_[0] = kRttRequest;
}
inline void SLUResponse::clear_rtt_request() {
  if (streaming_response_case() == kRttRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_response_.rtt_request_;
    }
    clear_has_streaming_response();
  }
}
inline ::speechly::slu::v1::RoundTripMeasurementRequest* SLUResponse::release_rtt_request() {
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUResponse.rtt_request)
  if (streaming_response_case() == kRttRequest) {
    clear_has_streaming_response();
    ::speechly::slu::v1::RoundTripMeasurementRequest* temp = _impl_.streaming_response_.rtt_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_response_.rtt_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechly::slu::v1::RoundTripMeasurementRequest& SLUResponse::_internal_rtt_request() const {
  return streaming_response_case() == kRttRequest
      ? *_impl_.streaming_response_.rtt_request_
      : reinterpret_cast<::speechly::slu::v1::RoundTripMeasurementRequest&>(::speechly::slu::v1::_RoundTripMeasurementRequest_default_instance_);
}
inline const ::speechly::slu::v1::RoundTripMeasurementRequest& SLUResponse::rtt_request() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUResponse.rtt_request)
  return _internal_rtt_request();
}
inline ::speechly::slu::v1::RoundTripMeasurementRequest* SLUResponse::unsafe_arena_release_rtt_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:speechly.slu.v1.SLUResponse.rtt_request)
  if (streaming_response_case() == kRttRequest) {
    clear_has_streaming_response();
    ::speechly::slu::v1::RoundTripMeasurementRequest* temp = _impl_.streaming_response_.rtt_request_;
    _impl_.streaming_response_.rtt_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLUResponse::unsafe_arena_set_allocated_rtt_request(::speechly::slu::v1::RoundTripMeasurementRequest* rtt_request) {
  clear_streaming_response();
  if (rtt_request) {
    set_has_rtt_request();
    _impl_.streaming_response_.rtt_request_ = rtt_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUResponse.rtt_request)
}
inline ::speechly::slu::v1::RoundTripMeasurementRequest* SLUResponse::_internal_mutable_rtt_request() {
  if (streaming_response_case() != kRttRequest) {
    clear_streaming_response();
    set_has_rtt_request();
    _impl_.streaming_response_.rtt_request_ = CreateMaybeMessage< ::speechly::slu::v1::RoundTripMeasurementRequest >(GetArenaForAllocation());
  }
  return _impl_.streaming_response_.rtt_request_;
}
inline ::speechly::slu::v1::RoundTripMeasurementRequest* SLUResponse::mutable_rtt_request() {
  ::speechly::slu::v1::RoundTripMeasurementRequest* _msg = _internal_mutable_rtt_request();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUResponse.rtt_request)
  return _msg;
}

inline bool SLUResponse::has_streaming_response() const {
  return streaming_response_case() != STREAMING_RESPONSE_NOT_SET;
}
inline void SLUResponse::clear_has_streaming_response() {
  _impl_._oneof_case_[0] = STREAMING_RESPONSE_NOT_SET;
}
inline SLUResponse::StreamingResponseCase SLUResponse::streaming_response_case() const {
  return SLUResponse::StreamingResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLUTranscript

// string word = 1;
inline void SLUTranscript::clear_word() {
  _impl_.word_.ClearToEmpty();
}
inline const std::string& SLUTranscript::word() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUTranscript.word)
  return _internal_word();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUTranscript::set_word(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.word_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUTranscript.word)
}
inline std::string* SLUTranscript::mutable_word() {
  std::string* _s = _internal_mutable_word();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUTranscript.word)
  return _s;
}
inline const std::string& SLUTranscript::_internal_word() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.word_.Get();
}
inline void SLUTranscript::_internal_set_word(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.word_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUTranscript::_internal_mutable_word() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.word_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUTranscript::release_word() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUTranscript.word)
  return _impl_.word_.Release();
}
inline void SLUTranscript::set_allocated_word(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.word_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.word_.IsDefault()) {
          _impl_.word_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUTranscript.word)
}

// int32 index = 2;
inline void SLUTranscript::clear_index() {
  _impl_.index_ = 0;
}
inline ::int32_t SLUTranscript::index() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUTranscript.index)
  return _internal_index();
}
inline void SLUTranscript::set_index(::int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUTranscript.index)
}
inline ::int32_t SLUTranscript::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void SLUTranscript::_internal_set_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.index_ = value;
}

// int32 start_time = 3;
inline void SLUTranscript::clear_start_time() {
  _impl_.start_time_ = 0;
}
inline ::int32_t SLUTranscript::start_time() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUTranscript.start_time)
  return _internal_start_time();
}
inline void SLUTranscript::set_start_time(::int32_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUTranscript.start_time)
}
inline ::int32_t SLUTranscript::_internal_start_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_time_;
}
inline void SLUTranscript::_internal_set_start_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_time_ = value;
}

// int32 end_time = 4;
inline void SLUTranscript::clear_end_time() {
  _impl_.end_time_ = 0;
}
inline ::int32_t SLUTranscript::end_time() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUTranscript.end_time)
  return _internal_end_time();
}
inline void SLUTranscript::set_end_time(::int32_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUTranscript.end_time)
}
inline ::int32_t SLUTranscript::_internal_end_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_time_;
}
inline void SLUTranscript::_internal_set_end_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_time_ = value;
}

// -------------------------------------------------------------------

// SLUEntity

// string entity = 1;
inline void SLUEntity::clear_entity() {
  _impl_.entity_.ClearToEmpty();
}
inline const std::string& SLUEntity::entity() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUEntity.entity)
  return _internal_entity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUEntity::set_entity(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUEntity.entity)
}
inline std::string* SLUEntity::mutable_entity() {
  std::string* _s = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUEntity.entity)
  return _s;
}
inline const std::string& SLUEntity::_internal_entity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_.Get();
}
inline void SLUEntity::_internal_set_entity(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUEntity::_internal_mutable_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.entity_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUEntity::release_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUEntity.entity)
  return _impl_.entity_.Release();
}
inline void SLUEntity::set_allocated_entity(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_.IsDefault()) {
          _impl_.entity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUEntity.entity)
}

// string value = 2;
inline void SLUEntity::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SLUEntity::value() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUEntity.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUEntity::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUEntity.value)
}
inline std::string* SLUEntity::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUEntity.value)
  return _s;
}
inline const std::string& SLUEntity::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void SLUEntity::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUEntity::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUEntity::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUEntity.value)
  return _impl_.value_.Release();
}
inline void SLUEntity::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUEntity.value)
}

// int32 start_position = 3;
inline void SLUEntity::clear_start_position() {
  _impl_.start_position_ = 0;
}
inline ::int32_t SLUEntity::start_position() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUEntity.start_position)
  return _internal_start_position();
}
inline void SLUEntity::set_start_position(::int32_t value) {
  _internal_set_start_position(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUEntity.start_position)
}
inline ::int32_t SLUEntity::_internal_start_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_position_;
}
inline void SLUEntity::_internal_set_start_position(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_position_ = value;
}

// int32 end_position = 4;
inline void SLUEntity::clear_end_position() {
  _impl_.end_position_ = 0;
}
inline ::int32_t SLUEntity::end_position() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUEntity.end_position)
  return _internal_end_position();
}
inline void SLUEntity::set_end_position(::int32_t value) {
  _internal_set_end_position(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUEntity.end_position)
}
inline ::int32_t SLUEntity::_internal_end_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_position_;
}
inline void SLUEntity::_internal_set_end_position(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_position_ = value;
}

// -------------------------------------------------------------------

// SLUIntent

// string intent = 1;
inline void SLUIntent::clear_intent() {
  _impl_.intent_.ClearToEmpty();
}
inline const std::string& SLUIntent::intent() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUIntent.intent)
  return _internal_intent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUIntent::set_intent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.intent_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUIntent.intent)
}
inline std::string* SLUIntent::mutable_intent() {
  std::string* _s = _internal_mutable_intent();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUIntent.intent)
  return _s;
}
inline const std::string& SLUIntent::_internal_intent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.intent_.Get();
}
inline void SLUIntent::_internal_set_intent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.intent_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUIntent::_internal_mutable_intent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.intent_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUIntent::release_intent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUIntent.intent)
  return _impl_.intent_.Release();
}
inline void SLUIntent::set_allocated_intent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.intent_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.intent_.IsDefault()) {
          _impl_.intent_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUIntent.intent)
}

// -------------------------------------------------------------------

// SLUSegmentEnd

// -------------------------------------------------------------------

// SLUTentativeTranscript

// string tentative_transcript = 1;
inline void SLUTentativeTranscript::clear_tentative_transcript() {
  _impl_.tentative_transcript_.ClearToEmpty();
}
inline const std::string& SLUTentativeTranscript::tentative_transcript() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUTentativeTranscript.tentative_transcript)
  return _internal_tentative_transcript();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUTentativeTranscript::set_tentative_transcript(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tentative_transcript_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUTentativeTranscript.tentative_transcript)
}
inline std::string* SLUTentativeTranscript::mutable_tentative_transcript() {
  std::string* _s = _internal_mutable_tentative_transcript();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUTentativeTranscript.tentative_transcript)
  return _s;
}
inline const std::string& SLUTentativeTranscript::_internal_tentative_transcript() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tentative_transcript_.Get();
}
inline void SLUTentativeTranscript::_internal_set_tentative_transcript(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tentative_transcript_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUTentativeTranscript::_internal_mutable_tentative_transcript() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tentative_transcript_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUTentativeTranscript::release_tentative_transcript() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUTentativeTranscript.tentative_transcript)
  return _impl_.tentative_transcript_.Release();
}
inline void SLUTentativeTranscript::set_allocated_tentative_transcript(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tentative_transcript_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tentative_transcript_.IsDefault()) {
          _impl_.tentative_transcript_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUTentativeTranscript.tentative_transcript)
}

// repeated .speechly.slu.v1.SLUTranscript tentative_words = 2;
inline int SLUTentativeTranscript::_internal_tentative_words_size() const {
  return _internal_tentative_words().size();
}
inline int SLUTentativeTranscript::tentative_words_size() const {
  return _internal_tentative_words_size();
}
inline void SLUTentativeTranscript::clear_tentative_words() {
  _internal_mutable_tentative_words()->Clear();
}
inline ::speechly::slu::v1::SLUTranscript* SLUTentativeTranscript::mutable_tentative_words(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUTentativeTranscript.tentative_words)
  return _internal_mutable_tentative_words()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUTranscript >*
SLUTentativeTranscript::mutable_tentative_words() {
  // @@protoc_insertion_point(field_mutable_list:speechly.slu.v1.SLUTentativeTranscript.tentative_words)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tentative_words();
}
inline const ::speechly::slu::v1::SLUTranscript& SLUTentativeTranscript::tentative_words(int index) const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUTentativeTranscript.tentative_words)
    return _internal_tentative_words().Get(index);
}
inline ::speechly::slu::v1::SLUTranscript* SLUTentativeTranscript::add_tentative_words() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::slu::v1::SLUTranscript* _add = _internal_mutable_tentative_words()->Add();
  // @@protoc_insertion_point(field_add:speechly.slu.v1.SLUTentativeTranscript.tentative_words)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUTranscript >&
SLUTentativeTranscript::tentative_words() const {
  // @@protoc_insertion_point(field_list:speechly.slu.v1.SLUTentativeTranscript.tentative_words)
  return _internal_tentative_words();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUTranscript>&
SLUTentativeTranscript::_internal_tentative_words() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tentative_words_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUTranscript>*
SLUTentativeTranscript::_internal_mutable_tentative_words() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tentative_words_;
}

// -------------------------------------------------------------------

// SLUTentativeEntities

// repeated .speechly.slu.v1.SLUEntity tentative_entities = 1;
inline int SLUTentativeEntities::_internal_tentative_entities_size() const {
  return _internal_tentative_entities().size();
}
inline int SLUTentativeEntities::tentative_entities_size() const {
  return _internal_tentative_entities_size();
}
inline void SLUTentativeEntities::clear_tentative_entities() {
  _internal_mutable_tentative_entities()->Clear();
}
inline ::speechly::slu::v1::SLUEntity* SLUTentativeEntities::mutable_tentative_entities(int index) {
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUTentativeEntities.tentative_entities)
  return _internal_mutable_tentative_entities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUEntity >*
SLUTentativeEntities::mutable_tentative_entities() {
  // @@protoc_insertion_point(field_mutable_list:speechly.slu.v1.SLUTentativeEntities.tentative_entities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tentative_entities();
}
inline const ::speechly::slu::v1::SLUEntity& SLUTentativeEntities::tentative_entities(int index) const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUTentativeEntities.tentative_entities)
    return _internal_tentative_entities().Get(index);
}
inline ::speechly::slu::v1::SLUEntity* SLUTentativeEntities::add_tentative_entities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::speechly::slu::v1::SLUEntity* _add = _internal_mutable_tentative_entities()->Add();
  // @@protoc_insertion_point(field_add:speechly.slu.v1.SLUTentativeEntities.tentative_entities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::speechly::slu::v1::SLUEntity >&
SLUTentativeEntities::tentative_entities() const {
  // @@protoc_insertion_point(field_list:speechly.slu.v1.SLUTentativeEntities.tentative_entities)
  return _internal_tentative_entities();
}
inline const ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUEntity>&
SLUTentativeEntities::_internal_tentative_entities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tentative_entities_;
}
inline ::google::protobuf::RepeatedPtrField<::speechly::slu::v1::SLUEntity>*
SLUTentativeEntities::_internal_mutable_tentative_entities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tentative_entities_;
}

// -------------------------------------------------------------------

// SLUStarted

// -------------------------------------------------------------------

// SLUFinished

// .speechly.slu.v1.SLUError error = 2;
inline bool SLUFinished::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline void SLUFinished::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::speechly::slu::v1::SLUError& SLUFinished::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::speechly::slu::v1::SLUError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::speechly::slu::v1::SLUError&>(::speechly::slu::v1::_SLUError_default_instance_);
}
inline const ::speechly::slu::v1::SLUError& SLUFinished::error() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUFinished.error)
  return _internal_error();
}
inline void SLUFinished::unsafe_arena_set_allocated_error(::speechly::slu::v1::SLUError* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::speechly::slu::v1::SLUError*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speechly.slu.v1.SLUFinished.error)
}
inline ::speechly::slu::v1::SLUError* SLUFinished::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::slu::v1::SLUError* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::speechly::slu::v1::SLUError* SLUFinished::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUFinished.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speechly::slu::v1::SLUError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::speechly::slu::v1::SLUError* SLUFinished::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechly::slu::v1::SLUError>(GetArenaForAllocation());
    _impl_.error_ = reinterpret_cast<::speechly::slu::v1::SLUError*>(p);
  }
  return _impl_.error_;
}
inline ::speechly::slu::v1::SLUError* SLUFinished::mutable_error() {
  ::speechly::slu::v1::SLUError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUFinished.error)
  return _msg;
}
inline void SLUFinished::set_allocated_error(::speechly::slu::v1::SLUError* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::speechly::slu::v1::SLUError*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::speechly::slu::v1::SLUError*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::speechly::slu::v1::SLUError*>(value);
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUFinished.error)
}

// -------------------------------------------------------------------

// SLUError

// string code = 1;
inline void SLUError::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& SLUError::code() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUError.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUError::set_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUError.code)
}
inline std::string* SLUError::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUError.code)
  return _s;
}
inline const std::string& SLUError::_internal_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.code_.Get();
}
inline void SLUError::_internal_set_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUError::_internal_mutable_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.code_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUError::release_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUError.code)
  return _impl_.code_.Release();
}
inline void SLUError::set_allocated_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_.IsDefault()) {
          _impl_.code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUError.code)
}

// string message = 2;
inline void SLUError::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SLUError::message() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.SLUError.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLUError::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speechly.slu.v1.SLUError.message)
}
inline std::string* SLUError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:speechly.slu.v1.SLUError.message)
  return _s;
}
inline const std::string& SLUError::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void SLUError::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SLUError::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* SLUError::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:speechly.slu.v1.SLUError.message)
  return _impl_.message_.Release();
}
inline void SLUError::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speechly.slu.v1.SLUError.message)
}

// -------------------------------------------------------------------

// RoundTripMeasurementRequest

// int32 id = 1;
inline void RoundTripMeasurementRequest::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t RoundTripMeasurementRequest::id() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.RoundTripMeasurementRequest.id)
  return _internal_id();
}
inline void RoundTripMeasurementRequest::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.RoundTripMeasurementRequest.id)
}
inline ::int32_t RoundTripMeasurementRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RoundTripMeasurementRequest::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// RoundTripMeasurementResponse

// int32 id = 1;
inline void RoundTripMeasurementResponse::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t RoundTripMeasurementResponse::id() const {
  // @@protoc_insertion_point(field_get:speechly.slu.v1.RoundTripMeasurementResponse.id)
  return _internal_id();
}
inline void RoundTripMeasurementResponse::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:speechly.slu.v1.RoundTripMeasurementResponse.id)
}
inline ::int32_t RoundTripMeasurementResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RoundTripMeasurementResponse::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace slu
}  // namespace speechly


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::speechly::slu::v1::SLUConfig_Encoding> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::speechly::slu::v1::SLUConfig_Encoding>() {
  return ::speechly::slu::v1::SLUConfig_Encoding_descriptor();
}
template <>
struct is_proto_enum<::speechly::slu::v1::SLUEvent_Event> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::speechly::slu::v1::SLUEvent_Event>() {
  return ::speechly::slu::v1::SLUEvent_Event_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_speechly_2fslu_2fv1_2fslu_2eproto_2epb_2eh
