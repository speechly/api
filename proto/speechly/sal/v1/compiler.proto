syntax = "proto3";

package speechly.sal.v1;

option csharp_namespace = "Speechly.Sal.V1";
option go_package = "speechly/sal/v1;salv1";
option java_multiple_files = true;
option java_outer_classname = "CompilerProto";
option java_package = "com.speechly.sal.v1";
option objc_class_prefix = "SSX";
option php_namespace = "Speechly\\Sal\\V1";

// The Speechly Compiler API is used for validating and compiling Speechly Annotation Language source files.
//
// The service requires a Speechly API token, which is obtained from Speechly Dashboard (https://speechly.com/dashboard).
//
// The token acts as a proxy for the user who has generated it,
// i.e. all operations are performed with that user as a subject.
service Compiler {
  // Compiles the SAL source and returns compiled templates and / or any compilation errors and warnings.
  rpc Compile(stream CompileRequest) returns (CompileResult);
  // Validates the SAL source and returns compilation notices / warnings and errors, if any.
  rpc Validate(stream AppSource) returns (ValidateResult);
  // Extracts raw, not compiled SAL templates from the SAL source.
  rpc ExtractSALSources(stream AppSource) returns (stream ExtractSALSourcesResult);
  // Evaluates a batch of texts and ground truth texts.
  rpc EvalTexts(EvalTextsRequest) returns (EvalTextsResponse);
}

// Top-level message sent by the client for the `EvalTexts` method.
message EvalTextsRequest {
  // The ID of the app that is used for evaluating.
  string app_id = 1;
  // The language of the text sent in the request as a BCP-47 language tag (e.g. "en-US").
  // Required.
  string language_code = 2;
  // Describes a single text and ground truth pair.
  message EvaluationPair {
    // The text to recognise.
    // Required.
    string text = 1;
    // The ground truth text to compare against.
    // Required.
    GroundTruth ground_truth = 2;
  }
  // Required.
  repeated EvaluationPair pairs = 3;
}

// Contains a chunk of SAL source.
// This message is consumed by `Validate` and `ExtractSALSources` RPCs and as a part of `CompileRequest`.
message AppSource {
  // The ID of Speechly app to compile for.
  string app_id = 1;
  // The language of SAL as a BCP-47 language tag (e.g. "en-US").
  string language = 2;
  // Chunk of SAL source code.
  bytes data_chunk = 3;
  // Content type options.
  enum ContentType {
    CONTENT_TYPE_UNSPECIFIED = 0;
    CONTENT_TYPE_YAML = 1;
    CONTENT_TYPE_TAR = 2;
  }
  // Optional content type of the SAL source.
  ContentType content_type = 4;
}

// This message is consumed by `Compile` RPC
message CompileRequest {
  // A chunk of SAL source.
  AppSource app_source = 1;
  // Number of examples to return:
  int32 batch_size = 2;
  // Random seed for example sampling. Changing seed can give different output.
  int32 random_seed = 3;
}

// Top-level message sent by the server for the `Compile` method.
message CompileResult {
  // Describes the status of result.
  enum Result {
    // Result has been successfully compiled.
    COMPILE_SUCCESS = 0;
    // Result has failed to compile.
    COMPILE_FAILURE = 1;
    // Result has been compiled, but with warnings.
    COMPILE_WARNING = 2;
  }
  // The status of compilation.
  Result result = 1;
  // (If the result was compiled) A list of compiled templates.
  repeated string templates = 2;
  // (If the result failed or had warnings) A list of error / warning messages.
  repeated LineReference messages = 3;
}

// Top-level message sent by the server for the `Validate` method.
message ValidateResult {
  // A list of error / warning messages, may be empty if validation didn't find any issues.
  repeated LineReference messages = 1;
}

// Describes a message related to a line in SAL source code.
message LineReference {
  // The level of the message.
  enum Level {
    // A notice - for information only.
    LEVEL_NOTE = 0;
    // A warning, does not fail compilation or validation, but should be addressed.
    LEVEL_WARNING = 1;
    // An error, fails compilation and validation.
    LEVEL_ERROR = 2;
  }
  // The line in SAL source that this message refers to.
  uint64 line = 1;
  // The column in SAL source that this message refers to.
  uint32 column = 2;
  // The file in SAL sources that this message refers to.
  string file = 3;
  // The level of the message.
  Level level = 4;
  // The contents of the message.
  string message = 5;
}

// Top-level message sent by the server for the `ExtractSALSources` method.
message ExtractSALSourcesResult {
  // Chunk of extracted SAL source code.
  bytes data_chunk = 1;
}

// Describes a manually verified reference for evaluation.
message GroundTruth {
  // A list of WLU segments.
  repeated WLUSegment segments = 1;
}

// Describes a WLU segment.
// A segment is a logical portion of text denoted by its intent,
// e.g. in a phrase "book me a flight and rent a car"
// there would be a segment for "book me a flight" and another for "rent a car".
message WLUSegment {
  // The portion of text that contains this segment.
  string text = 1;
  // The list of word tokens which are contained in this segment.
  repeated WLUToken tokens = 2;
  // The list of entities which are contained in this segment.
  repeated WLUEntity entities = 3;
  // The intent that defines this segment.
  WLUIntent intent = 4;
}

// Describes a single word token in a segment.
message WLUToken {
  // The value of the word.
  string word = 1;
  // Position of the token in the text.
  int32 index = 2;
}

// Describes a single entity in a segment.
//
// An entity is a specific object in the phrase that falls into some kind of category,
// e.g. in a SAL example "*book book a [burger restaurant](restaurant_type) for [tomorrow](date)"
// "burger restaurant" would be an entity of type `restaurant_type`,
// and "tomorrow" would be an entity of type `date`.
//
// An entity has a start and end indices which map to the indices of words in WLUToken messages,
// e.g. in the example "book a [burger restaurant](restaurant_type) for [tomorrow](date)" it would be:
//
// - Entity "burger restaurant" - `start_position = 2, end_position = 3`
// - Entity "tomorrow" - `start_position = 5, end_position = 5`
//
// The start index is inclusive, but the end index is exclusive, i.e. the interval is `[start_position, end_position)`.
message WLUEntity {
  // The type of the entity, e.g. `restaurant_type` or `date`.
  string entity = 1;
  // The value of the entity, e.g. `burger restaurant` or `tomorrow`.
  string value = 2;
  // The starting index of the entity in the phrase, maps to the `index` field in `SLUTranscript`.
  // Inclusive.
  int32 start_position = 3;
  // The finishing index of the entity in the phrase, maps to the `index` field in `SLUTranscript`.
  // Exclusive.
  int32 end_position = 4;
}

// Describes the intent of a segment.
// There can only be one intent per segment.
message WLUIntent {
  // The value of the intent, as defined in SAL.
  string intent = 1;
}

// Top-level message sent by the server for the `EvalTexts` method.
message EvalTextsResponse {
  // An evaluation report.
  string report = 1;
}
