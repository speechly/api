// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.23.0
// 	protoc        v3.13.0
// source: speechly/slu/v1/slu.proto

package sluv1

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// The encoding of the audio data sent in the stream.
type SLUConfig_Encoding int32

const (
	// Uncompressed 16-bit signed little-endian samples (Linear PCM).
	SLUConfig_LINEAR16 SLUConfig_Encoding = 0
)

// Enum value maps for SLUConfig_Encoding.
var (
	SLUConfig_Encoding_name = map[int32]string{
		0: "LINEAR16",
	}
	SLUConfig_Encoding_value = map[string]int32{
		"LINEAR16": 0,
	}
)

func (x SLUConfig_Encoding) Enum() *SLUConfig_Encoding {
	p := new(SLUConfig_Encoding)
	*p = x
	return p
}

func (x SLUConfig_Encoding) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SLUConfig_Encoding) Descriptor() protoreflect.EnumDescriptor {
	return file_speechly_slu_v1_slu_proto_enumTypes[0].Descriptor()
}

func (SLUConfig_Encoding) Type() protoreflect.EnumType {
	return &file_speechly_slu_v1_slu_proto_enumTypes[0]
}

func (x SLUConfig_Encoding) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SLUConfig_Encoding.Descriptor instead.
func (SLUConfig_Encoding) EnumDescriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{1, 0}
}

// The event type value.
type SLUEvent_Event int32

const (
	// START indicates the beginning of the audio context. Must be sent before sending audio data.
	SLUEvent_START SLUEvent_Event = 0
	// STOP indicates the end of the audio context. Must be sent after sending last chunk of audio in that segment.
	SLUEvent_STOP SLUEvent_Event = 1
)

// Enum value maps for SLUEvent_Event.
var (
	SLUEvent_Event_name = map[int32]string{
		0: "START",
		1: "STOP",
	}
	SLUEvent_Event_value = map[string]int32{
		"START": 0,
		"STOP":  1,
	}
)

func (x SLUEvent_Event) Enum() *SLUEvent_Event {
	p := new(SLUEvent_Event)
	*p = x
	return p
}

func (x SLUEvent_Event) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SLUEvent_Event) Descriptor() protoreflect.EnumDescriptor {
	return file_speechly_slu_v1_slu_proto_enumTypes[1].Descriptor()
}

func (SLUEvent_Event) Type() protoreflect.EnumType {
	return &file_speechly_slu_v1_slu_proto_enumTypes[1]
}

func (x SLUEvent_Event) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SLUEvent_Event.Descriptor instead.
func (SLUEvent_Event) EnumDescriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{2, 0}
}

// Top-level message sent by the client for the `Stream` method.
type SLURequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to StreamingRequest:
	//	*SLURequest_Config
	//	*SLURequest_Event
	//	*SLURequest_Audio
	StreamingRequest isSLURequest_StreamingRequest `protobuf_oneof:"streaming_request"`
}

func (x *SLURequest) Reset() {
	*x = SLURequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLURequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLURequest) ProtoMessage() {}

func (x *SLURequest) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLURequest.ProtoReflect.Descriptor instead.
func (*SLURequest) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{0}
}

func (m *SLURequest) GetStreamingRequest() isSLURequest_StreamingRequest {
	if m != nil {
		return m.StreamingRequest
	}
	return nil
}

func (x *SLURequest) GetConfig() *SLUConfig {
	if x, ok := x.GetStreamingRequest().(*SLURequest_Config); ok {
		return x.Config
	}
	return nil
}

func (x *SLURequest) GetEvent() *SLUEvent {
	if x, ok := x.GetStreamingRequest().(*SLURequest_Event); ok {
		return x.Event
	}
	return nil
}

func (x *SLURequest) GetAudio() []byte {
	if x, ok := x.GetStreamingRequest().(*SLURequest_Audio); ok {
		return x.Audio
	}
	return nil
}

type isSLURequest_StreamingRequest interface {
	isSLURequest_StreamingRequest()
}

type SLURequest_Config struct {
	// Describes the configuration of the audio sent by the client.
	// MUST be the first message sent to the stream.
	Config *SLUConfig `protobuf:"bytes,1,opt,name=config,proto3,oneof"`
}

type SLURequest_Event struct {
	// Indicates the beginning and the end of a logical audio segment (audio context in Speechly terms).
	// A context MUST be preceded by a start event and concluded with a stop event,
	// otherwise the server WILL terminate the stream with an error.
	Event *SLUEvent `protobuf:"bytes,2,opt,name=event,proto3,oneof"`
}

type SLURequest_Audio struct {
	// Contains a chunk of the audio being streamed.
	Audio []byte `protobuf:"bytes,3,opt,name=audio,proto3,oneof"`
}

func (*SLURequest_Config) isSLURequest_StreamingRequest() {}

func (*SLURequest_Event) isSLURequest_StreamingRequest() {}

func (*SLURequest_Audio) isSLURequest_StreamingRequest() {}

// Describes the configuration of the audio sent by the client.
// Currently the API only supports single-channel Linear PCM with sample rate of 16 kHz.
type SLUConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The encoding of the audio data sent in the stream.
	// Required.
	Encoding SLUConfig_Encoding `protobuf:"varint,1,opt,name=encoding,proto3,enum=speechly.slu.v1.SLUConfig_Encoding" json:"encoding,omitempty"`
	// The number of channels in the input audio data.
	// Required.
	Channels int32 `protobuf:"varint,2,opt,name=channels,proto3" json:"channels,omitempty"`
	// Sample rate in Hertz of the audio data sent in the stream.
	// Required.
	SampleRateHertz int32 `protobuf:"varint,3,opt,name=sample_rate_hertz,json=sampleRateHertz,proto3" json:"sample_rate_hertz,omitempty"`
	// The language of the audio sent in the stream as a BCP-47 language tag (e.g. "en-US").
	// Required.
	LanguageCode string `protobuf:"bytes,4,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
}

func (x *SLUConfig) Reset() {
	*x = SLUConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUConfig) ProtoMessage() {}

func (x *SLUConfig) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUConfig.ProtoReflect.Descriptor instead.
func (*SLUConfig) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{1}
}

func (x *SLUConfig) GetEncoding() SLUConfig_Encoding {
	if x != nil {
		return x.Encoding
	}
	return SLUConfig_LINEAR16
}

func (x *SLUConfig) GetChannels() int32 {
	if x != nil {
		return x.Channels
	}
	return 0
}

func (x *SLUConfig) GetSampleRateHertz() int32 {
	if x != nil {
		return x.SampleRateHertz
	}
	return 0
}

func (x *SLUConfig) GetLanguageCode() string {
	if x != nil {
		return x.LanguageCode
	}
	return ""
}

// Indicates the beginning and the end of a logical audio segment (audio context in Speechly terms).
type SLUEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The event type being sent. Required.
	Event SLUEvent_Event `protobuf:"varint,1,opt,name=event,proto3,enum=speechly.slu.v1.SLUEvent_Event" json:"event,omitempty"`
}

func (x *SLUEvent) Reset() {
	*x = SLUEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUEvent) ProtoMessage() {}

func (x *SLUEvent) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUEvent.ProtoReflect.Descriptor instead.
func (*SLUEvent) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{2}
}

func (x *SLUEvent) GetEvent() SLUEvent_Event {
	if x != nil {
		return x.Event
	}
	return SLUEvent_START
}

// Top-level message sent by the server for the `Stream` method.
type SLUResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ID of the audio context that this response belongs to.
	AudioContext string `protobuf:"bytes,1,opt,name=audio_context,json=audioContext,proto3" json:"audio_context,omitempty"`
	// The ID of the SLU segment that this response belongs to.
	// This will be 0 for SLUStarted and SLUFinished responses.
	SegmentId int32 `protobuf:"varint,2,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty"`
	// Response payload.
	//
	// Types that are assignable to StreamingResponse:
	//	*SLUResponse_Transcript
	//	*SLUResponse_Entity
	//	*SLUResponse_Intent
	//	*SLUResponse_SegmentEnd
	//	*SLUResponse_TentativeTranscript
	//	*SLUResponse_TentativeEntities
	//	*SLUResponse_TentativeIntent
	//	*SLUResponse_Started
	//	*SLUResponse_Finished
	StreamingResponse isSLUResponse_StreamingResponse `protobuf_oneof:"streaming_response"`
}

func (x *SLUResponse) Reset() {
	*x = SLUResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUResponse) ProtoMessage() {}

func (x *SLUResponse) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUResponse.ProtoReflect.Descriptor instead.
func (*SLUResponse) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{3}
}

func (x *SLUResponse) GetAudioContext() string {
	if x != nil {
		return x.AudioContext
	}
	return ""
}

func (x *SLUResponse) GetSegmentId() int32 {
	if x != nil {
		return x.SegmentId
	}
	return 0
}

func (m *SLUResponse) GetStreamingResponse() isSLUResponse_StreamingResponse {
	if m != nil {
		return m.StreamingResponse
	}
	return nil
}

func (x *SLUResponse) GetTranscript() *SLUTranscript {
	if x, ok := x.GetStreamingResponse().(*SLUResponse_Transcript); ok {
		return x.Transcript
	}
	return nil
}

func (x *SLUResponse) GetEntity() *SLUEntity {
	if x, ok := x.GetStreamingResponse().(*SLUResponse_Entity); ok {
		return x.Entity
	}
	return nil
}

func (x *SLUResponse) GetIntent() *SLUIntent {
	if x, ok := x.GetStreamingResponse().(*SLUResponse_Intent); ok {
		return x.Intent
	}
	return nil
}

func (x *SLUResponse) GetSegmentEnd() *SLUSegmentEnd {
	if x, ok := x.GetStreamingResponse().(*SLUResponse_SegmentEnd); ok {
		return x.SegmentEnd
	}
	return nil
}

func (x *SLUResponse) GetTentativeTranscript() *SLUTentativeTranscript {
	if x, ok := x.GetStreamingResponse().(*SLUResponse_TentativeTranscript); ok {
		return x.TentativeTranscript
	}
	return nil
}

func (x *SLUResponse) GetTentativeEntities() *SLUTentativeEntities {
	if x, ok := x.GetStreamingResponse().(*SLUResponse_TentativeEntities); ok {
		return x.TentativeEntities
	}
	return nil
}

func (x *SLUResponse) GetTentativeIntent() *SLUIntent {
	if x, ok := x.GetStreamingResponse().(*SLUResponse_TentativeIntent); ok {
		return x.TentativeIntent
	}
	return nil
}

func (x *SLUResponse) GetStarted() *SLUStarted {
	if x, ok := x.GetStreamingResponse().(*SLUResponse_Started); ok {
		return x.Started
	}
	return nil
}

func (x *SLUResponse) GetFinished() *SLUFinished {
	if x, ok := x.GetStreamingResponse().(*SLUResponse_Finished); ok {
		return x.Finished
	}
	return nil
}

type isSLUResponse_StreamingResponse interface {
	isSLUResponse_StreamingResponse()
}

type SLUResponse_Transcript struct {
	// Final SLU transcript.
	Transcript *SLUTranscript `protobuf:"bytes,3,opt,name=transcript,proto3,oneof"`
}

type SLUResponse_Entity struct {
	// Final SLU entity.
	Entity *SLUEntity `protobuf:"bytes,4,opt,name=entity,proto3,oneof"`
}

type SLUResponse_Intent struct {
	// Final SLU intent.
	Intent *SLUIntent `protobuf:"bytes,5,opt,name=intent,proto3,oneof"`
}

type SLUResponse_SegmentEnd struct {
	// A special marker message that indicates that the segment with specified `segment_id`
	// has been finalised and no new responses belonging to that segment will be sent.
	// The client is expected to discard any tentative responses in this segment.
	SegmentEnd *SLUSegmentEnd `protobuf:"bytes,6,opt,name=segment_end,json=segmentEnd,proto3,oneof"`
}

type SLUResponse_TentativeTranscript struct {
	// Tentative SLU transcript.
	TentativeTranscript *SLUTentativeTranscript `protobuf:"bytes,7,opt,name=tentative_transcript,json=tentativeTranscript,proto3,oneof"`
}

type SLUResponse_TentativeEntities struct {
	// Tentative SLU entities.
	TentativeEntities *SLUTentativeEntities `protobuf:"bytes,8,opt,name=tentative_entities,json=tentativeEntities,proto3,oneof"`
}

type SLUResponse_TentativeIntent struct {
	// Tentative SLU intent.
	TentativeIntent *SLUIntent `protobuf:"bytes,9,opt,name=tentative_intent,json=tentativeIntent,proto3,oneof"`
}

type SLUResponse_Started struct {
	// A special marker message that indicates that the audio context with specified `audio_context` id
	// has been started by the API and all audio data sent by the client will be processed in that context.
	// This message is an asynchronous acknowledgement for client-side SLUEvent_START message.
	Started *SLUStarted `protobuf:"bytes,10,opt,name=started,proto3,oneof"`
}

type SLUResponse_Finished struct {
	// A special marker message that indicates that the audio context with specified `audio_context` id
	// has been stopped by the API and no new responses for that context will be sent.
	// The client is expected to discard any non-finalised segments.
	// This message is an asynchronous acknowledgement for client-side SLUEvent_STOP message.
	Finished *SLUFinished `protobuf:"bytes,11,opt,name=finished,proto3,oneof"`
}

func (*SLUResponse_Transcript) isSLUResponse_StreamingResponse() {}

func (*SLUResponse_Entity) isSLUResponse_StreamingResponse() {}

func (*SLUResponse_Intent) isSLUResponse_StreamingResponse() {}

func (*SLUResponse_SegmentEnd) isSLUResponse_StreamingResponse() {}

func (*SLUResponse_TentativeTranscript) isSLUResponse_StreamingResponse() {}

func (*SLUResponse_TentativeEntities) isSLUResponse_StreamingResponse() {}

func (*SLUResponse_TentativeIntent) isSLUResponse_StreamingResponse() {}

func (*SLUResponse_Started) isSLUResponse_StreamingResponse() {}

func (*SLUResponse_Finished) isSLUResponse_StreamingResponse() {}

// Describes an SLU transcript.
// A transcript is a speech-to-text element of the phrase, i.e. a word recognised from the audio.
type SLUTranscript struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The word recongised from the audio.
	Word string `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
	// The position of the word in the whole phrase, zero-based.
	Index int32 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	// The end time of the word in the audio, in milliseconds from the beginning of the audio.
	StartTime int32 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// The end time of the word in the audio, in milliseconds from the beginning of the audio.
	EndTime int32 `protobuf:"varint,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (x *SLUTranscript) Reset() {
	*x = SLUTranscript{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUTranscript) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUTranscript) ProtoMessage() {}

func (x *SLUTranscript) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUTranscript.ProtoReflect.Descriptor instead.
func (*SLUTranscript) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{4}
}

func (x *SLUTranscript) GetWord() string {
	if x != nil {
		return x.Word
	}
	return ""
}

func (x *SLUTranscript) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *SLUTranscript) GetStartTime() int32 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *SLUTranscript) GetEndTime() int32 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

// Describes an SLU entity.
//
// An entity is a specific object in the phrase that falls into some kind of category,
// e.g. in a SAL example "*book book a [burger restaurant](restaurant_type) for [tomorrow](date)"
// "burger restaurant" would be an entity of type `restaurant_type`,
// and "tomorrow" would be an entity of type `date`.
//
// An entity has a start and end indices which map to the indices of words in SLUTranscript messages,
// e.g. in the example "book a [burger restaurant](restaurant_type) for [tomorrow](date)" it would be:
//
// * Entity "burger restaurant" - `start_position = 2, end_position = 3`
// * Entity "tomorrow" - `start_position = 5, end_position = 5`
//
// The start index is inclusive, but the end index is exclusive, i.e. the interval is `[start_position, end_position)`.
type SLUEntity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The type of the entity, e.g. `restaurant_type` or `date`.
	Entity string `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`
	// The value of the entity, e.g. `burger restaurant` or `tomorrow`.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// The starting index of the entity in the phrase, maps to the `index` field in `SLUTranscript`.
	// Inclusive.
	StartPosition int32 `protobuf:"varint,3,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
	// The finishing index of the entity in the phrase, maps to the `index` field in `SLUTranscript`.
	// Exclusive.
	EndPosition int32 `protobuf:"varint,4,opt,name=end_position,json=endPosition,proto3" json:"end_position,omitempty"`
}

func (x *SLUEntity) Reset() {
	*x = SLUEntity{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUEntity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUEntity) ProtoMessage() {}

func (x *SLUEntity) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUEntity.ProtoReflect.Descriptor instead.
func (*SLUEntity) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{5}
}

func (x *SLUEntity) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *SLUEntity) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *SLUEntity) GetStartPosition() int32 {
	if x != nil {
		return x.StartPosition
	}
	return 0
}

func (x *SLUEntity) GetEndPosition() int32 {
	if x != nil {
		return x.EndPosition
	}
	return 0
}

// Describes an SLU intent.
// There can be only one intent per SLU segment.
type SLUIntent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The value of the intent, as defined in SAL.
	Intent string `protobuf:"bytes,1,opt,name=intent,proto3" json:"intent,omitempty"`
}

func (x *SLUIntent) Reset() {
	*x = SLUIntent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUIntent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUIntent) ProtoMessage() {}

func (x *SLUIntent) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUIntent.ProtoReflect.Descriptor instead.
func (*SLUIntent) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{6}
}

func (x *SLUIntent) GetIntent() string {
	if x != nil {
		return x.Intent
	}
	return ""
}

// Indicates the end of the segment.
// Upon receiving this, the segment should be finalised and all future messages for that segment (if any) discarded.
type SLUSegmentEnd struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLUSegmentEnd) Reset() {
	*x = SLUSegmentEnd{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUSegmentEnd) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUSegmentEnd) ProtoMessage() {}

func (x *SLUSegmentEnd) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUSegmentEnd.ProtoReflect.Descriptor instead.
func (*SLUSegmentEnd) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{7}
}

// Describes a tentative transcript.
//
// Tentative transcript is an interim recognition result, which may change over time,
// e.g. a phrase "find me a red t-shirt" can be tentatively recognised as "find me a tea",
// until the API processes the audio completely.
type SLUTentativeTranscript struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Aggregated tentative transcript from the beginning of the audio until current moment in time.
	// Consecutive transcripts will have this value appended to,
	// e.g. if in the first message it's "find me", in the next it may be "find me a t-shirt".
	TentativeTranscript string `protobuf:"bytes,1,opt,name=tentative_transcript,json=tentativeTranscript,proto3" json:"tentative_transcript,omitempty"`
	// A list of individual words which compose `tentative_transcript`.
	// All words must be considered tentative.
	TentativeWords []*SLUTranscript `protobuf:"bytes,2,rep,name=tentative_words,json=tentativeWords,proto3" json:"tentative_words,omitempty"`
}

func (x *SLUTentativeTranscript) Reset() {
	*x = SLUTentativeTranscript{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUTentativeTranscript) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUTentativeTranscript) ProtoMessage() {}

func (x *SLUTentativeTranscript) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUTentativeTranscript.ProtoReflect.Descriptor instead.
func (*SLUTentativeTranscript) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{8}
}

func (x *SLUTentativeTranscript) GetTentativeTranscript() string {
	if x != nil {
		return x.TentativeTranscript
	}
	return ""
}

func (x *SLUTentativeTranscript) GetTentativeWords() []*SLUTranscript {
	if x != nil {
		return x.TentativeWords
	}
	return nil
}

// Describes tentative entities.
type SLUTentativeEntities struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A list of entities, which must be treated as tentative.
	//
	// This is not an aggregate of all entities in the audio,
	// but rather it ONLY contains entities that have not been finalised yet.
	//
	// e.g. if at the start there are two tentatively recognised entities - ["burger restaurant", "tomorrow"]
	// but then the API marks "burger restaurant" as final and recognises a new tentative entity "for two",
	// this will contain ["tomorrow", "for two"].
	TentativeEntities []*SLUEntity `protobuf:"bytes,1,rep,name=tentative_entities,json=tentativeEntities,proto3" json:"tentative_entities,omitempty"`
}

func (x *SLUTentativeEntities) Reset() {
	*x = SLUTentativeEntities{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUTentativeEntities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUTentativeEntities) ProtoMessage() {}

func (x *SLUTentativeEntities) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUTentativeEntities.ProtoReflect.Descriptor instead.
func (*SLUTentativeEntities) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{9}
}

func (x *SLUTentativeEntities) GetTentativeEntities() []*SLUEntity {
	if x != nil {
		return x.TentativeEntities
	}
	return nil
}

// Indicates that the API has started processing the portion of audio as new audio context.
// This does not guarantee that the server will not send any more messages for the previous audio context.
type SLUStarted struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLUStarted) Reset() {
	*x = SLUStarted{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUStarted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUStarted) ProtoMessage() {}

func (x *SLUStarted) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUStarted.ProtoReflect.Descriptor instead.
func (*SLUStarted) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{10}
}

// Indicates that the API has stopped processing current audio context.
// It guarantees that no new messages for that context will be sent by the server.
type SLUFinished struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// DEPRECATED
	// An error which has happened when processing the context, if any.
	Error *SLUError `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *SLUFinished) Reset() {
	*x = SLUFinished{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUFinished) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUFinished) ProtoMessage() {}

func (x *SLUFinished) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUFinished.ProtoReflect.Descriptor instead.
func (*SLUFinished) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{11}
}

func (x *SLUFinished) GetError() *SLUError {
	if x != nil {
		return x.Error
	}
	return nil
}

// Describes the error that happened when processing an audio context.
type SLUError struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Error code (refer to documentation for specific codes).
	Code string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	// Error message.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *SLUError) Reset() {
	*x = SLUError{}
	if protoimpl.UnsafeEnabled {
		mi := &file_speechly_slu_v1_slu_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLUError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLUError) ProtoMessage() {}

func (x *SLUError) ProtoReflect() protoreflect.Message {
	mi := &file_speechly_slu_v1_slu_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLUError.ProtoReflect.Descriptor instead.
func (*SLUError) Descriptor() ([]byte, []int) {
	return file_speechly_slu_v1_slu_proto_rawDescGZIP(), []int{12}
}

func (x *SLUError) GetCode() string {
	if x != nil {
		return x.Code
	}
	return ""
}

func (x *SLUError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

var File_speechly_slu_v1_slu_proto protoreflect.FileDescriptor

var file_speechly_slu_v1_slu_proto_rawDesc = []byte{
	0x0a, 0x19, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2f, 0x73, 0x6c, 0x75, 0x2f, 0x76,
	0x31, 0x2f, 0x73, 0x6c, 0x75, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0f, 0x73, 0x70, 0x65,
	0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x22, 0xa2, 0x01, 0x0a,
	0x0a, 0x53, 0x4c, 0x55, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x34, 0x0a, 0x06, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x70,
	0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c,
	0x55, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x48, 0x00, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x12, 0x31, 0x0a, 0x05, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e,
	0x76, 0x31, 0x2e, 0x53, 0x4c, 0x55, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x05, 0x65,
	0x76, 0x65, 0x6e, 0x74, 0x12, 0x16, 0x0a, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x42, 0x13, 0x0a, 0x11,
	0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x22, 0xd3, 0x01, 0x0a, 0x09, 0x53, 0x4c, 0x55, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,
	0x3f, 0x0a, 0x08, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x23, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75,
	0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c, 0x55, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x45, 0x6e,
	0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x08, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67,
	0x12, 0x1a, 0x0a, 0x08, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x08, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x12, 0x2a, 0x0a, 0x11,
	0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x68, 0x65, 0x72, 0x74,
	0x7a, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x52,
	0x61, 0x74, 0x65, 0x48, 0x65, 0x72, 0x74, 0x7a, 0x12, 0x23, 0x0a, 0x0d, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0c, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x18, 0x0a,
	0x08, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x0c, 0x0a, 0x08, 0x4c, 0x49, 0x4e,
	0x45, 0x41, 0x52, 0x31, 0x36, 0x10, 0x00, 0x22, 0x5f, 0x0a, 0x08, 0x53, 0x4c, 0x55, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x12, 0x35, 0x0a, 0x05, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c,
	0x75, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c, 0x55, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x52, 0x05, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x22, 0x1c, 0x0a, 0x05, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x12, 0x09, 0x0a, 0x05, 0x53, 0x54, 0x41, 0x52, 0x54, 0x10, 0x00, 0x12, 0x08,
	0x0a, 0x04, 0x53, 0x54, 0x4f, 0x50, 0x10, 0x01, 0x22, 0xcc, 0x05, 0x0a, 0x0b, 0x53, 0x4c, 0x55,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x75, 0x64, 0x69,
	0x6f, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0c, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x12, 0x1d, 0x0a,
	0x0a, 0x73, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x09, 0x73, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x40, 0x0a, 0x0a,
	0x74, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1e, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e,
	0x76, 0x31, 0x2e, 0x53, 0x4c, 0x55, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x48, 0x00, 0x52, 0x0a, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x34,
	0x0a, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
	0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31,
	0x2e, 0x53, 0x4c, 0x55, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x48, 0x00, 0x52, 0x06, 0x65, 0x6e,
	0x74, 0x69, 0x74, 0x79, 0x12, 0x34, 0x0a, 0x06, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e,
	0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c, 0x55, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x74,
	0x48, 0x00, 0x52, 0x06, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x41, 0x0a, 0x0b, 0x73, 0x65,
	0x67, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1e, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76,
	0x31, 0x2e, 0x53, 0x4c, 0x55, 0x53, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x64, 0x48,
	0x00, 0x52, 0x0a, 0x73, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x64, 0x12, 0x5c, 0x0a,
	0x14, 0x74, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73,
	0x63, 0x72, 0x69, 0x70, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x73, 0x70,
	0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c,
	0x55, 0x54, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63,
	0x72, 0x69, 0x70, 0x74, 0x48, 0x00, 0x52, 0x13, 0x74, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76,
	0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x56, 0x0a, 0x12, 0x74,
	0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65,
	0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68,
	0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c, 0x55, 0x54, 0x65, 0x6e,
	0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x48, 0x00,
	0x52, 0x11, 0x74, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x45, 0x6e, 0x74, 0x69, 0x74,
	0x69, 0x65, 0x73, 0x12, 0x47, 0x0a, 0x10, 0x74, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65,
	0x5f, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
	0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e,
	0x53, 0x4c, 0x55, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x0f, 0x74, 0x65, 0x6e,
	0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x37, 0x0a, 0x07,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e,
	0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e,
	0x53, 0x4c, 0x55, 0x53, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x48, 0x00, 0x52, 0x07, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x65, 0x64, 0x12, 0x3a, 0x0a, 0x08, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65,
	0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68,
	0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c, 0x55, 0x46, 0x69, 0x6e,
	0x69, 0x73, 0x68, 0x65, 0x64, 0x48, 0x00, 0x52, 0x08, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65,
	0x64, 0x42, 0x14, 0x0a, 0x12, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x72,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x73, 0x0a, 0x0d, 0x53, 0x4c, 0x55, 0x54, 0x72,
	0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x77, 0x6f, 0x72, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x14, 0x0a, 0x05,
	0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x69, 0x6e, 0x64,
	0x65, 0x78, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d,
	0x65, 0x12, 0x19, 0x0a, 0x08, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x22, 0x83, 0x01, 0x0a,
	0x09, 0x53, 0x4c, 0x55, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x6e,
	0x74, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x6e, 0x74, 0x69,
	0x74, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x74, 0x61, 0x72,
	0x74, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x0d, 0x73, 0x74, 0x61, 0x72, 0x74, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12,
	0x21, 0x0a, 0x0c, 0x65, 0x6e, 0x64, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x65, 0x6e, 0x64, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x22, 0x23, 0x0a, 0x09, 0x53, 0x4c, 0x55, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12,
	0x16, 0x0a, 0x06, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x06, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x22, 0x0f, 0x0a, 0x0d, 0x53, 0x4c, 0x55, 0x53, 0x65,
	0x67, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x64, 0x22, 0x94, 0x01, 0x0a, 0x16, 0x53, 0x4c, 0x55,
	0x54, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72,
	0x69, 0x70, 0x74, 0x12, 0x31, 0x0a, 0x14, 0x74, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65,
	0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x13, 0x74, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x54, 0x72, 0x61, 0x6e,
	0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x47, 0x0a, 0x0f, 0x74, 0x65, 0x6e, 0x74, 0x61, 0x74,
	0x69, 0x76, 0x65, 0x5f, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1e, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76,
	0x31, 0x2e, 0x53, 0x4c, 0x55, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x52,
	0x0e, 0x74, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x57, 0x6f, 0x72, 0x64, 0x73, 0x22,
	0x61, 0x0a, 0x14, 0x53, 0x4c, 0x55, 0x54, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x45,
	0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x49, 0x0a, 0x12, 0x74, 0x65, 0x6e, 0x74, 0x61,
	0x74, 0x69, 0x76, 0x65, 0x5f, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73,
	0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c, 0x55, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52,
	0x11, 0x74, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69,
	0x65, 0x73, 0x22, 0x0c, 0x0a, 0x0a, 0x53, 0x4c, 0x55, 0x53, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64,
	0x22, 0x3e, 0x0a, 0x0b, 0x53, 0x4c, 0x55, 0x46, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65, 0x64, 0x12,
	0x2f, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19,
	0x2e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31,
	0x2e, 0x53, 0x4c, 0x55, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x22, 0x38, 0x0a, 0x08, 0x53, 0x4c, 0x55, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x04,
	0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x64, 0x65,
	0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x32, 0x4e, 0x0a, 0x03, 0x53, 0x4c,
	0x55, 0x12, 0x47, 0x0a, 0x06, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x12, 0x1b, 0x2e, 0x73, 0x70,
	0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c,
	0x55, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x6c, 0x79, 0x2e, 0x73, 0x6c, 0x75, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x4c, 0x55, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x28, 0x01, 0x30, 0x01, 0x42, 0x17, 0x5a, 0x15, 0x73, 0x70,
	0x65, 0x65, 0x63, 0x68, 0x6c, 0x79, 0x2f, 0x73, 0x6c, 0x75, 0x2f, 0x76, 0x31, 0x3b, 0x73, 0x6c,
	0x75, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_speechly_slu_v1_slu_proto_rawDescOnce sync.Once
	file_speechly_slu_v1_slu_proto_rawDescData = file_speechly_slu_v1_slu_proto_rawDesc
)

func file_speechly_slu_v1_slu_proto_rawDescGZIP() []byte {
	file_speechly_slu_v1_slu_proto_rawDescOnce.Do(func() {
		file_speechly_slu_v1_slu_proto_rawDescData = protoimpl.X.CompressGZIP(file_speechly_slu_v1_slu_proto_rawDescData)
	})
	return file_speechly_slu_v1_slu_proto_rawDescData
}

var file_speechly_slu_v1_slu_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_speechly_slu_v1_slu_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_speechly_slu_v1_slu_proto_goTypes = []interface{}{
	(SLUConfig_Encoding)(0),        // 0: speechly.slu.v1.SLUConfig.Encoding
	(SLUEvent_Event)(0),            // 1: speechly.slu.v1.SLUEvent.Event
	(*SLURequest)(nil),             // 2: speechly.slu.v1.SLURequest
	(*SLUConfig)(nil),              // 3: speechly.slu.v1.SLUConfig
	(*SLUEvent)(nil),               // 4: speechly.slu.v1.SLUEvent
	(*SLUResponse)(nil),            // 5: speechly.slu.v1.SLUResponse
	(*SLUTranscript)(nil),          // 6: speechly.slu.v1.SLUTranscript
	(*SLUEntity)(nil),              // 7: speechly.slu.v1.SLUEntity
	(*SLUIntent)(nil),              // 8: speechly.slu.v1.SLUIntent
	(*SLUSegmentEnd)(nil),          // 9: speechly.slu.v1.SLUSegmentEnd
	(*SLUTentativeTranscript)(nil), // 10: speechly.slu.v1.SLUTentativeTranscript
	(*SLUTentativeEntities)(nil),   // 11: speechly.slu.v1.SLUTentativeEntities
	(*SLUStarted)(nil),             // 12: speechly.slu.v1.SLUStarted
	(*SLUFinished)(nil),            // 13: speechly.slu.v1.SLUFinished
	(*SLUError)(nil),               // 14: speechly.slu.v1.SLUError
}
var file_speechly_slu_v1_slu_proto_depIdxs = []int32{
	3,  // 0: speechly.slu.v1.SLURequest.config:type_name -> speechly.slu.v1.SLUConfig
	4,  // 1: speechly.slu.v1.SLURequest.event:type_name -> speechly.slu.v1.SLUEvent
	0,  // 2: speechly.slu.v1.SLUConfig.encoding:type_name -> speechly.slu.v1.SLUConfig.Encoding
	1,  // 3: speechly.slu.v1.SLUEvent.event:type_name -> speechly.slu.v1.SLUEvent.Event
	6,  // 4: speechly.slu.v1.SLUResponse.transcript:type_name -> speechly.slu.v1.SLUTranscript
	7,  // 5: speechly.slu.v1.SLUResponse.entity:type_name -> speechly.slu.v1.SLUEntity
	8,  // 6: speechly.slu.v1.SLUResponse.intent:type_name -> speechly.slu.v1.SLUIntent
	9,  // 7: speechly.slu.v1.SLUResponse.segment_end:type_name -> speechly.slu.v1.SLUSegmentEnd
	10, // 8: speechly.slu.v1.SLUResponse.tentative_transcript:type_name -> speechly.slu.v1.SLUTentativeTranscript
	11, // 9: speechly.slu.v1.SLUResponse.tentative_entities:type_name -> speechly.slu.v1.SLUTentativeEntities
	8,  // 10: speechly.slu.v1.SLUResponse.tentative_intent:type_name -> speechly.slu.v1.SLUIntent
	12, // 11: speechly.slu.v1.SLUResponse.started:type_name -> speechly.slu.v1.SLUStarted
	13, // 12: speechly.slu.v1.SLUResponse.finished:type_name -> speechly.slu.v1.SLUFinished
	6,  // 13: speechly.slu.v1.SLUTentativeTranscript.tentative_words:type_name -> speechly.slu.v1.SLUTranscript
	7,  // 14: speechly.slu.v1.SLUTentativeEntities.tentative_entities:type_name -> speechly.slu.v1.SLUEntity
	14, // 15: speechly.slu.v1.SLUFinished.error:type_name -> speechly.slu.v1.SLUError
	2,  // 16: speechly.slu.v1.SLU.Stream:input_type -> speechly.slu.v1.SLURequest
	5,  // 17: speechly.slu.v1.SLU.Stream:output_type -> speechly.slu.v1.SLUResponse
	17, // [17:18] is the sub-list for method output_type
	16, // [16:17] is the sub-list for method input_type
	16, // [16:16] is the sub-list for extension type_name
	16, // [16:16] is the sub-list for extension extendee
	0,  // [0:16] is the sub-list for field type_name
}

func init() { file_speechly_slu_v1_slu_proto_init() }
func file_speechly_slu_v1_slu_proto_init() {
	if File_speechly_slu_v1_slu_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_speechly_slu_v1_slu_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLURequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUTranscript); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUEntity); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUIntent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUSegmentEnd); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUTentativeTranscript); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUTentativeEntities); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUStarted); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUFinished); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_speechly_slu_v1_slu_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLUError); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_speechly_slu_v1_slu_proto_msgTypes[0].OneofWrappers = []interface{}{
		(*SLURequest_Config)(nil),
		(*SLURequest_Event)(nil),
		(*SLURequest_Audio)(nil),
	}
	file_speechly_slu_v1_slu_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*SLUResponse_Transcript)(nil),
		(*SLUResponse_Entity)(nil),
		(*SLUResponse_Intent)(nil),
		(*SLUResponse_SegmentEnd)(nil),
		(*SLUResponse_TentativeTranscript)(nil),
		(*SLUResponse_TentativeEntities)(nil),
		(*SLUResponse_TentativeIntent)(nil),
		(*SLUResponse_Started)(nil),
		(*SLUResponse_Finished)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_speechly_slu_v1_slu_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_speechly_slu_v1_slu_proto_goTypes,
		DependencyIndexes: file_speechly_slu_v1_slu_proto_depIdxs,
		EnumInfos:         file_speechly_slu_v1_slu_proto_enumTypes,
		MessageInfos:      file_speechly_slu_v1_slu_proto_msgTypes,
	}.Build()
	File_speechly_slu_v1_slu_proto = out.File
	file_speechly_slu_v1_slu_proto_rawDesc = nil
	file_speechly_slu_v1_slu_proto_goTypes = nil
	file_speechly_slu_v1_slu_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// SLUClient is the client API for SLU service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SLUClient interface {
	// Performs bidirectional streaming speech recognition: receive results while sending audio.
	//
	// First request MUST be an SLUConfig message with the configuration that describes the audio format being sent.
	//
	// This RPC can handle multiple logical audio segments with the use of SLUEvent_START and SLUEvent_STOP messages,
	// which are used to indicate the beginning and the end of a segment.
	//
	// A typical call timeline will look like this:
	//
	// 1. Client starts the RPC.
	// 2. Client sends SLUConfig message with audio configuration.
	// 3. Client sends SLUEvent_START.
	// 4. Client sends audio and receives responses from the server.
	// 5. Client sends SLUEvent_STOP.
	// 6. Client sends SLUEvent_START.
	// 7. Client sends audio and receives responses from the server.
	// 8. Client sends SLUEvent_STOP.
	// 9. Client closes the stream and receives responses from the server until EOF is received.
	//
	// NB: the client does not have to wait until the server acknowledges the start / stop events,
	// this is done asynchronously. The client can deduplicate responses based on the audio context ID,
	// which will be present in every response message.
	Stream(ctx context.Context, opts ...grpc.CallOption) (SLU_StreamClient, error)
}

type sLUClient struct {
	cc grpc.ClientConnInterface
}

func NewSLUClient(cc grpc.ClientConnInterface) SLUClient {
	return &sLUClient{cc}
}

func (c *sLUClient) Stream(ctx context.Context, opts ...grpc.CallOption) (SLU_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLU_serviceDesc.Streams[0], "/speechly.slu.v1.SLU/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLUStreamClient{stream}
	return x, nil
}

type SLU_StreamClient interface {
	Send(*SLURequest) error
	Recv() (*SLUResponse, error)
	grpc.ClientStream
}

type sLUStreamClient struct {
	grpc.ClientStream
}

func (x *sLUStreamClient) Send(m *SLURequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLUStreamClient) Recv() (*SLUResponse, error) {
	m := new(SLUResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SLUServer is the server API for SLU service.
type SLUServer interface {
	// Performs bidirectional streaming speech recognition: receive results while sending audio.
	//
	// First request MUST be an SLUConfig message with the configuration that describes the audio format being sent.
	//
	// This RPC can handle multiple logical audio segments with the use of SLUEvent_START and SLUEvent_STOP messages,
	// which are used to indicate the beginning and the end of a segment.
	//
	// A typical call timeline will look like this:
	//
	// 1. Client starts the RPC.
	// 2. Client sends SLUConfig message with audio configuration.
	// 3. Client sends SLUEvent_START.
	// 4. Client sends audio and receives responses from the server.
	// 5. Client sends SLUEvent_STOP.
	// 6. Client sends SLUEvent_START.
	// 7. Client sends audio and receives responses from the server.
	// 8. Client sends SLUEvent_STOP.
	// 9. Client closes the stream and receives responses from the server until EOF is received.
	//
	// NB: the client does not have to wait until the server acknowledges the start / stop events,
	// this is done asynchronously. The client can deduplicate responses based on the audio context ID,
	// which will be present in every response message.
	Stream(SLU_StreamServer) error
}

// UnimplementedSLUServer can be embedded to have forward compatible implementations.
type UnimplementedSLUServer struct {
}

func (*UnimplementedSLUServer) Stream(SLU_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}

func RegisterSLUServer(s *grpc.Server, srv SLUServer) {
	s.RegisterService(&_SLU_serviceDesc, srv)
}

func _SLU_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLUServer).Stream(&sLUStreamServer{stream})
}

type SLU_StreamServer interface {
	Send(*SLUResponse) error
	Recv() (*SLURequest, error)
	grpc.ServerStream
}

type sLUStreamServer struct {
	grpc.ServerStream
}

func (x *sLUStreamServer) Send(m *SLUResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLUStreamServer) Recv() (*SLURequest, error) {
	m := new(SLURequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SLU_serviceDesc = grpc.ServiceDesc{
	ServiceName: "speechly.slu.v1.SLU",
	HandlerType: (*SLUServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _SLU_Stream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "speechly/slu/v1/slu.proto",
}
