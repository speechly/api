// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: speechly/slu/v2/batch.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes the processing options for the audio. Note that not all options are
/// available for all languages or on all Payment Plans.
/// If all options are left to default values, `transcribe` is set as default.
public struct Speechly_Slu_V2_BatchTasks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Results will include a transcription of the audio.
  /// Optional, defaults to true.
  public var transcribe: Bool = false

  /// The processing should include translating the audio to English.
  /// Optional, defaults to false.
  public var translate: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Define the output formats for results. If all options are set as false,
/// `display` is returned.
public struct Speechly_Slu_V2_BatchOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// return text formatted for display, ie. capitalized and punctuated.
  /// Optional, defaults to false.
  public var display: Bool = false

  /// return lexical version of the transcript, ie. lower case and no
  /// punctuation.
  /// Optional, defaults to false.
  public var lexical: Bool = false

  /// return the token level transcription and time stamps for tokens.
  /// Optional, defaults to false.
  public var tokenized: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes the configuration options common for the input batch.
public struct Speechly_Slu_V2_BatchConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the language model to use when processing the audio.
  /// Optional. If not provided, the model to use will be determined
  /// from the login information or from language detection.
  public var modelID: String = String()

  /// The language(s) of the audio sent in the request as a BCP-47 language tag
  /// (e.g. "en-US"). Defaults to the target application language(s).
  /// Optional.
  public var languageCodes: [String] = []

  /// Reference id for a set of related operations. For example an identifier of
  /// the source system.
  /// Optional.
  public var batchReference: String = String()

  /// Additional batch specific options.
  /// Optional.
  public var options: [Speechly_Slu_V2_Option] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes the configuration options unique to a single audio source.
public struct Speechly_Slu_V2_ProcessAudioSourceRequestItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The locator to the source audio.
  /// Required.
  public var sourceURL: String = String()

  /// The locator to the result target. The payload will be `Operation` as JSON.
  /// Optional.
  public var destinationURL: String = String()

  /// HTTP endpoint to be notified on completion of the processing. The payload
  /// will be `Operation` as JSON.
  /// Optional.
  public var completionWebhook: Speechly_Slu_V2_HttpResource {
    get {return _completionWebhook ?? Speechly_Slu_V2_HttpResource()}
    set {_completionWebhook = newValue}
  }
  /// Returns true if `completionWebhook` has been explicitly set.
  public var hasCompletionWebhook: Bool {return self._completionWebhook != nil}
  /// Clears the value of `completionWebhook`. Subsequent reads from it will return its default value.
  public mutating func clearCompletionWebhook() {self._completionWebhook = nil}

  /// Reference id for the operation. For example an identifier of the source
  /// system.
  /// Optional.
  public var reference: String = String()

  /// The device ID of the audio source, for example a microphone identifier as
  /// UUID.
  /// Optional.
  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _completionWebhook: Speechly_Slu_V2_HttpResource? = nil
}

/// Describes a single batch operation.
public struct Speechly_Slu_V2_Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the operation.
  public var id: String = String()

  /// The reference id of the operation, if given.
  public var reference: String = String()

  /// The id of the batch the operation belongs to.
  public var batchID: String = String()

  /// The reference id of the operation, if given.
  public var batchReference: String = String()

  /// The current status of the operation.
  public var status: Speechly_Slu_V2_Operation.Status = .unspecified

  /// The language code of the detected language.
  public var languageCode: String = String()

  /// The application context for the operation.
  public var appID: String = String()

  /// If the operation status is STATUS_DONE and the destination is not set,
  /// the results of the processing.
  public var result: [Speechly_Slu_V2_OperationResult] = []

  /// The duration of the audio.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// Machine-readable status for the operation.
  /// Only set if operation status is STATUS_ERROR.
  public var errorCode: Speechly_Slu_V2_Operation.ErrorCode = .errorUnspecified

  /// Contains a human readable description of the error.
  /// Only set if operation status is STATUS_ERROR.
  public var errorDescription: String = String()

  /// The locator to the source audio.
  public var sourceURL: String = String()

  /// The locator to the result target.
  public var destinationURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The status of the operation.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default status is empty.
    case unspecified // = 0

    /// The operation is queued for processing.
    case pending // = 1

    /// The operation is complete and transcript is available.
    case done // = 2

    /// The processing failed. Error reason is available.
    case error // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pending
      case 2: self = .done
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pending: return 1
      case .done: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Contains a machine readable error type if the operation status is
  /// STATUS_ERROR.
  public enum ErrorCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No error is set.
    case errorUnspecified // = 0

    /// The input was in a language that was not supported in this context.
    case errorUnsupportedLanguage // = 1

    /// An internal error occurred.
    case errorInternal // = 2

    /// Given parameters cannot be used to process the given input.
    case errorInvalidParameters // = 3

    /// The source could not be read or understood.
    case errorInvalidSource // = 4

    /// The results could not be written to the destination.
    case errorInvalidDestination // = 5

    /// The provided audio was not in a supported format.
    case errorInvalidAudio // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .errorUnspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .errorUnspecified
      case 1: self = .errorUnsupportedLanguage
      case 2: self = .errorInternal
      case 3: self = .errorInvalidParameters
      case 4: self = .errorInvalidSource
      case 5: self = .errorInvalidDestination
      case 6: self = .errorInvalidAudio
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .errorUnspecified: return 0
      case .errorUnsupportedLanguage: return 1
      case .errorInternal: return 2
      case .errorInvalidParameters: return 3
      case .errorInvalidSource: return 4
      case .errorInvalidDestination: return 5
      case .errorInvalidAudio: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Speechly_Slu_V2_Operation.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Speechly_Slu_V2_Operation.Status] = [
    .unspecified,
    .pending,
    .done,
    .error,
  ]
}

extension Speechly_Slu_V2_Operation.ErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Speechly_Slu_V2_Operation.ErrorCode] = [
    .errorUnspecified,
    .errorUnsupportedLanguage,
    .errorInternal,
    .errorInvalidParameters,
    .errorInvalidSource,
    .errorInvalidDestination,
    .errorInvalidAudio,
  ]
}

#endif  // swift(>=4.2)

/// Describes the results of the processing that took place.
public struct Speechly_Slu_V2_OperationResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of this result.
  public var type: Speechly_Slu_V2_OperationResult.ResultType = .unspecified

  /// The textual representation of the results.
  public var text: String = String()

  /// The tokenized representation of the result. Only available if requested in
  /// the `ProcessingConfiguration`.
  public var tokens: [Speechly_Slu_V2_Token] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The possible types for the operation result.
  public enum ResultType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Result type is not set.
    case unspecified // = 0

    /// The actual words of the audio with no additional processing applied.
    case transcriptLexical // = 1

    /// The content of the audio formatted to be displayed on screen, with eg.
    /// punctuation and capitalization included.
    case transcriptDisplay // = 2

    /// The content of the audio translated to English.
    case translation // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .transcriptLexical
      case 2: self = .transcriptDisplay
      case 3: self = .translation
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .transcriptLexical: return 1
      case .transcriptDisplay: return 2
      case .translation: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Speechly_Slu_V2_OperationResult.ResultType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Speechly_Slu_V2_OperationResult.ResultType] = [
    .unspecified,
    .transcriptLexical,
    .transcriptDisplay,
    .translation,
  ]
}

#endif  // swift(>=4.2)

/// Describes a single meaningful unit of speech. In languages that use spaces to
/// separate words, closely maps to those words.
public struct Speechly_Slu_V2_Token {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The token described.
  public var token: String = String()

  /// The position of the token in the whole phrase, zero-based.
  public var index: Int32 = 0

  /// The end time of the token in the audio, in milliseconds from the beginning
  /// of the audio.
  public var startTime: Int32 = 0

  /// The end time of the token in the audio, in milliseconds from the beginning
  /// of the audio.
  public var endTime: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Generic option to change the default behaviour of the SLU. Available options
/// are different per project context.
public struct Speechly_Slu_V2_Option {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The key of the option to be set.
  public var key: String = String()

  /// The values to set the option to.
  public var value: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes full properties of an HTTP endpoint.
public struct Speechly_Slu_V2_HttpResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URL of the endpoint (protocol://server/path)
  /// Required.
  public var url: String = String()

  /// method to use in connection.
  /// Optional.
  public var method: Speechly_Slu_V2_HttpResource.Method = .unspecified

  /// Possible additional headers to include in the connection.
  /// Optional.
  public var headers: [Speechly_Slu_V2_HttpResource.Header] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The HTTP method to use when accessing an HTTP resource.
  public enum Method: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Method is not given, and default method is used for requests.
    /// Data fetches use GET, and result sending POST.
    case unspecified // = 0

    /// Use HTTP GET.
    case get // = 1

    /// Use HTTP POST.
    case post // = 2

    /// Use HTTP PUT.
    case put // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .get
      case 2: self = .post
      case 3: self = .put
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .get: return 1
      case .post: return 2
      case .put: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A single header value in an HTTP request.
  public struct Header {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the header to set in request.
    public var name: String = String()

    /// Value of the given header in request.
    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Speechly_Slu_V2_HttpResource.Method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Speechly_Slu_V2_HttpResource.Method] = [
    .unspecified,
    .get,
    .post,
    .put,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Speechly_Slu_V2_BatchTasks: @unchecked Sendable {}
extension Speechly_Slu_V2_BatchOutput: @unchecked Sendable {}
extension Speechly_Slu_V2_BatchConfig: @unchecked Sendable {}
extension Speechly_Slu_V2_ProcessAudioSourceRequestItem: @unchecked Sendable {}
extension Speechly_Slu_V2_Operation: @unchecked Sendable {}
extension Speechly_Slu_V2_Operation.Status: @unchecked Sendable {}
extension Speechly_Slu_V2_Operation.ErrorCode: @unchecked Sendable {}
extension Speechly_Slu_V2_OperationResult: @unchecked Sendable {}
extension Speechly_Slu_V2_OperationResult.ResultType: @unchecked Sendable {}
extension Speechly_Slu_V2_Token: @unchecked Sendable {}
extension Speechly_Slu_V2_Option: @unchecked Sendable {}
extension Speechly_Slu_V2_HttpResource: @unchecked Sendable {}
extension Speechly_Slu_V2_HttpResource.Method: @unchecked Sendable {}
extension Speechly_Slu_V2_HttpResource.Header: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "speechly.slu.v2"

extension Speechly_Slu_V2_BatchTasks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchTasks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transcribe"),
    2: .same(proto: "translate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.transcribe) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.translate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transcribe != false {
      try visitor.visitSingularBoolField(value: self.transcribe, fieldNumber: 1)
    }
    if self.translate != false {
      try visitor.visitSingularBoolField(value: self.translate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_BatchTasks, rhs: Speechly_Slu_V2_BatchTasks) -> Bool {
    if lhs.transcribe != rhs.transcribe {return false}
    if lhs.translate != rhs.translate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V2_BatchOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "display"),
    2: .same(proto: "lexical"),
    3: .same(proto: "tokenized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.display) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.lexical) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.tokenized) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.display != false {
      try visitor.visitSingularBoolField(value: self.display, fieldNumber: 1)
    }
    if self.lexical != false {
      try visitor.visitSingularBoolField(value: self.lexical, fieldNumber: 2)
    }
    if self.tokenized != false {
      try visitor.visitSingularBoolField(value: self.tokenized, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_BatchOutput, rhs: Speechly_Slu_V2_BatchOutput) -> Bool {
    if lhs.display != rhs.display {return false}
    if lhs.lexical != rhs.lexical {return false}
    if lhs.tokenized != rhs.tokenized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V2_BatchConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_id"),
    2: .standard(proto: "language_codes"),
    4: .standard(proto: "batch_reference"),
    5: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.languageCodes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.batchReference) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 1)
    }
    if !self.languageCodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.languageCodes, fieldNumber: 2)
    }
    if !self.batchReference.isEmpty {
      try visitor.visitSingularStringField(value: self.batchReference, fieldNumber: 4)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_BatchConfig, rhs: Speechly_Slu_V2_BatchConfig) -> Bool {
    if lhs.modelID != rhs.modelID {return false}
    if lhs.languageCodes != rhs.languageCodes {return false}
    if lhs.batchReference != rhs.batchReference {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V2_ProcessAudioSourceRequestItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProcessAudioSourceRequestItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_url"),
    2: .standard(proto: "destination_url"),
    3: .standard(proto: "completion_webhook"),
    4: .same(proto: "reference"),
    5: .standard(proto: "device_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destinationURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._completionWebhook) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reference) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceURL, fieldNumber: 1)
    }
    if !self.destinationURL.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationURL, fieldNumber: 2)
    }
    try { if let v = self._completionWebhook {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.reference.isEmpty {
      try visitor.visitSingularStringField(value: self.reference, fieldNumber: 4)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_ProcessAudioSourceRequestItem, rhs: Speechly_Slu_V2_ProcessAudioSourceRequestItem) -> Bool {
    if lhs.sourceURL != rhs.sourceURL {return false}
    if lhs.destinationURL != rhs.destinationURL {return false}
    if lhs._completionWebhook != rhs._completionWebhook {return false}
    if lhs.reference != rhs.reference {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V2_Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "reference"),
    16: .standard(proto: "batch_id"),
    17: .standard(proto: "batch_reference"),
    3: .same(proto: "status"),
    4: .standard(proto: "language_code"),
    5: .standard(proto: "app_id"),
    6: .same(proto: "result"),
    7: .same(proto: "duration"),
    18: .standard(proto: "error_code"),
    19: .standard(proto: "error_description"),
    20: .standard(proto: "source_url"),
    21: .standard(proto: "destination_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reference) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.batchID) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.batchReference) }()
      case 18: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 19: try { try decoder.decodeSingularStringField(value: &self.errorDescription) }()
      case 20: try { try decoder.decodeSingularStringField(value: &self.sourceURL) }()
      case 21: try { try decoder.decodeSingularStringField(value: &self.destinationURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.reference.isEmpty {
      try visitor.visitSingularStringField(value: self.reference, fieldNumber: 2)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 4)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 5)
    }
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 6)
    }
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 16)
    }
    if !self.batchReference.isEmpty {
      try visitor.visitSingularStringField(value: self.batchReference, fieldNumber: 17)
    }
    if self.errorCode != .errorUnspecified {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 18)
    }
    if !self.errorDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.errorDescription, fieldNumber: 19)
    }
    if !self.sourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceURL, fieldNumber: 20)
    }
    if !self.destinationURL.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationURL, fieldNumber: 21)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_Operation, rhs: Speechly_Slu_V2_Operation) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.reference != rhs.reference {return false}
    if lhs.batchID != rhs.batchID {return false}
    if lhs.batchReference != rhs.batchReference {return false}
    if lhs.status != rhs.status {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.result != rhs.result {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorDescription != rhs.errorDescription {return false}
    if lhs.sourceURL != rhs.sourceURL {return false}
    if lhs.destinationURL != rhs.destinationURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V2_Operation.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "STATUS_PENDING"),
    2: .same(proto: "STATUS_DONE"),
    3: .same(proto: "STATUS_ERROR"),
  ]
}

extension Speechly_Slu_V2_Operation.ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_UNSPECIFIED"),
    1: .same(proto: "ERROR_UNSUPPORTED_LANGUAGE"),
    2: .same(proto: "ERROR_INTERNAL"),
    3: .same(proto: "ERROR_INVALID_PARAMETERS"),
    4: .same(proto: "ERROR_INVALID_SOURCE"),
    5: .same(proto: "ERROR_INVALID_DESTINATION"),
    6: .same(proto: "ERROR_INVALID_AUDIO"),
  ]
}

extension Speechly_Slu_V2_OperationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "text"),
    3: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_OperationResult, rhs: Speechly_Slu_V2_OperationResult) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.text != rhs.text {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V2_OperationResult.ResultType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_TYPE_UNSPECIFIED"),
    1: .same(proto: "RESULT_TYPE_TRANSCRIPT_LEXICAL"),
    2: .same(proto: "RESULT_TYPE_TRANSCRIPT_DISPLAY"),
    3: .same(proto: "RESULT_TYPE_TRANSLATION"),
  ]
}

extension Speechly_Slu_V2_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Token"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "index"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.startTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 2)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt32Field(value: self.startTime, fieldNumber: 3)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt32Field(value: self.endTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_Token, rhs: Speechly_Slu_V2_Token) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.index != rhs.index {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V2_Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_Option, rhs: Speechly_Slu_V2_Option) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V2_HttpResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpResource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "method"),
    3: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if self.method != .unspecified {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_HttpResource, rhs: Speechly_Slu_V2_HttpResource) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.method != rhs.method {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V2_HttpResource.Method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METHOD_UNSPECIFIED"),
    1: .same(proto: "METHOD_GET"),
    2: .same(proto: "METHOD_POST"),
    3: .same(proto: "METHOD_PUT"),
  ]
}

extension Speechly_Slu_V2_HttpResource.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Speechly_Slu_V2_HttpResource.protoMessageName + ".Header"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V2_HttpResource.Header, rhs: Speechly_Slu_V2_HttpResource.Header) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
