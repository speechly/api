// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: speechly/slu/v1/slu.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Top-level message sent by the client for the `Stream` method.
public struct Speechly_Slu_V1_SLURequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamingRequest: Speechly_Slu_V1_SLURequest.OneOf_StreamingRequest? = nil

  /// Describes the configuration of the audio sent by the client.
  /// MUST be the first message sent to the stream.
  public var config: Speechly_Slu_V1_SLUConfig {
    get {
      if case .config(let v)? = streamingRequest {return v}
      return Speechly_Slu_V1_SLUConfig()
    }
    set {streamingRequest = .config(newValue)}
  }

  /// Indicates the beginning and the end of a logical audio segment (audio context in Speechly terms).
  /// A context MUST be preceded by a start event and concluded with a stop event,
  /// otherwise the server WILL terminate the stream with an error.
  public var event: Speechly_Slu_V1_SLUEvent {
    get {
      if case .event(let v)? = streamingRequest {return v}
      return Speechly_Slu_V1_SLUEvent()
    }
    set {streamingRequest = .event(newValue)}
  }

  /// Contains a chunk of the audio being streamed.
  public var audio: Data {
    get {
      if case .audio(let v)? = streamingRequest {return v}
      return Data()
    }
    set {streamingRequest = .audio(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StreamingRequest: Equatable {
    /// Describes the configuration of the audio sent by the client.
    /// MUST be the first message sent to the stream.
    case config(Speechly_Slu_V1_SLUConfig)
    /// Indicates the beginning and the end of a logical audio segment (audio context in Speechly terms).
    /// A context MUST be preceded by a start event and concluded with a stop event,
    /// otherwise the server WILL terminate the stream with an error.
    case event(Speechly_Slu_V1_SLUEvent)
    /// Contains a chunk of the audio being streamed.
    case audio(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Speechly_Slu_V1_SLURequest.OneOf_StreamingRequest, rhs: Speechly_Slu_V1_SLURequest.OneOf_StreamingRequest) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.config, .config): return {
        guard case .config(let l) = lhs, case .config(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.event, .event): return {
        guard case .event(let l) = lhs, case .event(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Describes the configuration of the audio sent by the client.
/// Currently the API only supports single-channel Linear PCM with sample rate of 16 kHz.
public struct Speechly_Slu_V1_SLUConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The encoding of the audio data sent in the stream.
  /// Required.
  public var encoding: Speechly_Slu_V1_SLUConfig.Encoding = .linear16

  /// The number of channels in the input audio data.
  /// Required.
  public var channels: Int32 = 0

  /// Sample rate in Hertz of the audio data sent in the stream.
  /// Required.
  public var sampleRateHertz: Int32 = 0

  /// The language of the audio sent in the stream as a BCP-47 language tag (e.g. "en-US").
  /// Required.
  public var languageCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The encoding of the audio data sent in the stream.
  public enum Encoding: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Uncompressed 16-bit signed little-endian samples (Linear PCM).
    case linear16 // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .linear16
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .linear16
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .linear16: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Speechly_Slu_V1_SLUConfig.Encoding: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Speechly_Slu_V1_SLUConfig.Encoding] = [
    .linear16,
  ]
}

#endif  // swift(>=4.2)

/// Indicates the beginning and the end of a logical audio segment (audio context in Speechly terms).
public struct Speechly_Slu_V1_SLUEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event type being sent. Required.
  public var event: Speechly_Slu_V1_SLUEvent.Event = .start

  /// The `appId` for the utterance.
  /// - Required in the `START` event if the authorization token is *project based*. The
  ///   given application must be part of the project set in the token.
  /// - Not required if the authorization token is *application based*.
  public var appID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The event type value.
  public enum Event: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// START indicates the beginning of the audio context. Must be sent before sending audio data.
    case start // = 0

    /// STOP indicates the end of the audio context. Must be sent after sending last chunk of audio in that segment.
    case stop // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .start
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .start
      case 1: self = .stop
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .start: return 0
      case .stop: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Speechly_Slu_V1_SLUEvent.Event: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Speechly_Slu_V1_SLUEvent.Event] = [
    .start,
    .stop,
  ]
}

#endif  // swift(>=4.2)

/// Top-level message sent by the server for the `Stream` method.
public struct Speechly_Slu_V1_SLUResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the audio context that this response belongs to.
  public var audioContext: String = String()

  /// The ID of the SLU segment that this response belongs to.
  /// This will be 0 for SLUStarted and SLUFinished responses.
  public var segmentID: Int32 = 0

  /// Response payload.
  public var streamingResponse: Speechly_Slu_V1_SLUResponse.OneOf_StreamingResponse? = nil

  /// Final SLU transcript.
  public var transcript: Speechly_Slu_V1_SLUTranscript {
    get {
      if case .transcript(let v)? = streamingResponse {return v}
      return Speechly_Slu_V1_SLUTranscript()
    }
    set {streamingResponse = .transcript(newValue)}
  }

  /// Final SLU entity.
  public var entity: Speechly_Slu_V1_SLUEntity {
    get {
      if case .entity(let v)? = streamingResponse {return v}
      return Speechly_Slu_V1_SLUEntity()
    }
    set {streamingResponse = .entity(newValue)}
  }

  /// Final SLU intent.
  public var intent: Speechly_Slu_V1_SLUIntent {
    get {
      if case .intent(let v)? = streamingResponse {return v}
      return Speechly_Slu_V1_SLUIntent()
    }
    set {streamingResponse = .intent(newValue)}
  }

  /// A special marker message that indicates that the segment with specified `segment_id`
  /// has been finalised and no new responses belonging to that segment will be sent.
  /// The client is expected to discard any tentative responses in this segment.
  public var segmentEnd: Speechly_Slu_V1_SLUSegmentEnd {
    get {
      if case .segmentEnd(let v)? = streamingResponse {return v}
      return Speechly_Slu_V1_SLUSegmentEnd()
    }
    set {streamingResponse = .segmentEnd(newValue)}
  }

  /// Tentative SLU transcript.
  public var tentativeTranscript: Speechly_Slu_V1_SLUTentativeTranscript {
    get {
      if case .tentativeTranscript(let v)? = streamingResponse {return v}
      return Speechly_Slu_V1_SLUTentativeTranscript()
    }
    set {streamingResponse = .tentativeTranscript(newValue)}
  }

  /// Tentative SLU entities.
  public var tentativeEntities: Speechly_Slu_V1_SLUTentativeEntities {
    get {
      if case .tentativeEntities(let v)? = streamingResponse {return v}
      return Speechly_Slu_V1_SLUTentativeEntities()
    }
    set {streamingResponse = .tentativeEntities(newValue)}
  }

  /// Tentative SLU intent.
  public var tentativeIntent: Speechly_Slu_V1_SLUIntent {
    get {
      if case .tentativeIntent(let v)? = streamingResponse {return v}
      return Speechly_Slu_V1_SLUIntent()
    }
    set {streamingResponse = .tentativeIntent(newValue)}
  }

  /// A special marker message that indicates that the audio context with specified `audio_context` id
  /// has been started by the API and all audio data sent by the client will be processed in that context.
  /// This message is an asynchronous acknowledgement for client-side SLUEvent_START message.
  public var started: Speechly_Slu_V1_SLUStarted {
    get {
      if case .started(let v)? = streamingResponse {return v}
      return Speechly_Slu_V1_SLUStarted()
    }
    set {streamingResponse = .started(newValue)}
  }

  /// A special marker message that indicates that the audio context with specified `audio_context` id
  /// has been stopped by the API and no new responses for that context will be sent.
  /// The client is expected to discard any non-finalised segments.
  /// This message is an asynchronous acknowledgement for client-side SLUEvent_STOP message.
  public var finished: Speechly_Slu_V1_SLUFinished {
    get {
      if case .finished(let v)? = streamingResponse {return v}
      return Speechly_Slu_V1_SLUFinished()
    }
    set {streamingResponse = .finished(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Response payload.
  public enum OneOf_StreamingResponse: Equatable {
    /// Final SLU transcript.
    case transcript(Speechly_Slu_V1_SLUTranscript)
    /// Final SLU entity.
    case entity(Speechly_Slu_V1_SLUEntity)
    /// Final SLU intent.
    case intent(Speechly_Slu_V1_SLUIntent)
    /// A special marker message that indicates that the segment with specified `segment_id`
    /// has been finalised and no new responses belonging to that segment will be sent.
    /// The client is expected to discard any tentative responses in this segment.
    case segmentEnd(Speechly_Slu_V1_SLUSegmentEnd)
    /// Tentative SLU transcript.
    case tentativeTranscript(Speechly_Slu_V1_SLUTentativeTranscript)
    /// Tentative SLU entities.
    case tentativeEntities(Speechly_Slu_V1_SLUTentativeEntities)
    /// Tentative SLU intent.
    case tentativeIntent(Speechly_Slu_V1_SLUIntent)
    /// A special marker message that indicates that the audio context with specified `audio_context` id
    /// has been started by the API and all audio data sent by the client will be processed in that context.
    /// This message is an asynchronous acknowledgement for client-side SLUEvent_START message.
    case started(Speechly_Slu_V1_SLUStarted)
    /// A special marker message that indicates that the audio context with specified `audio_context` id
    /// has been stopped by the API and no new responses for that context will be sent.
    /// The client is expected to discard any non-finalised segments.
    /// This message is an asynchronous acknowledgement for client-side SLUEvent_STOP message.
    case finished(Speechly_Slu_V1_SLUFinished)

  #if !swift(>=4.1)
    public static func ==(lhs: Speechly_Slu_V1_SLUResponse.OneOf_StreamingResponse, rhs: Speechly_Slu_V1_SLUResponse.OneOf_StreamingResponse) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transcript, .transcript): return {
        guard case .transcript(let l) = lhs, case .transcript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.entity, .entity): return {
        guard case .entity(let l) = lhs, case .entity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intent, .intent): return {
        guard case .intent(let l) = lhs, case .intent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.segmentEnd, .segmentEnd): return {
        guard case .segmentEnd(let l) = lhs, case .segmentEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tentativeTranscript, .tentativeTranscript): return {
        guard case .tentativeTranscript(let l) = lhs, case .tentativeTranscript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tentativeEntities, .tentativeEntities): return {
        guard case .tentativeEntities(let l) = lhs, case .tentativeEntities(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tentativeIntent, .tentativeIntent): return {
        guard case .tentativeIntent(let l) = lhs, case .tentativeIntent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.started, .started): return {
        guard case .started(let l) = lhs, case .started(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finished, .finished): return {
        guard case .finished(let l) = lhs, case .finished(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Describes an SLU transcript.
/// A transcript is a speech-to-text element of the phrase, i.e. a word recognised from the audio.
public struct Speechly_Slu_V1_SLUTranscript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The word recongised from the audio.
  public var word: String = String()

  /// The position of the word in the whole phrase, zero-based.
  public var index: Int32 = 0

  /// The end time of the word in the audio, in milliseconds from the beginning of the audio.
  public var startTime: Int32 = 0

  /// The end time of the word in the audio, in milliseconds from the beginning of the audio.
  public var endTime: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes an SLU entity.
///
/// An entity is a specific object in the phrase that falls into some kind of category,
/// e.g. in a SAL example "*book book a [burger restaurant](restaurant_type) for [tomorrow](date)"
/// "burger restaurant" would be an entity of type `restaurant_type`,
/// and "tomorrow" would be an entity of type `date`.
///
/// An entity has a start and end indices which map to the indices of words in SLUTranscript messages,
/// e.g. in the example "book a [burger restaurant](restaurant_type) for [tomorrow](date)" it would be:
///
/// * Entity "burger restaurant" - `start_position = 2, end_position = 3`
/// * Entity "tomorrow" - `start_position = 5, end_position = 5`
///
/// The start index is inclusive, but the end index is exclusive, i.e. the interval is `[start_position, end_position)`.
public struct Speechly_Slu_V1_SLUEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of the entity, e.g. `restaurant_type` or `date`.
  public var entity: String = String()

  /// The value of the entity, e.g. `burger restaurant` or `tomorrow`.
  public var value: String = String()

  /// The starting index of the entity in the phrase, maps to the `index` field in `SLUTranscript`.
  /// Inclusive.
  public var startPosition: Int32 = 0

  /// The finishing index of the entity in the phrase, maps to the `index` field in `SLUTranscript`.
  /// Exclusive.
  public var endPosition: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes an SLU intent.
/// There can be only one intent per SLU segment.
public struct Speechly_Slu_V1_SLUIntent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value of the intent, as defined in SAL.
  public var intent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates the end of the segment.
/// Upon receiving this, the segment should be finalised and all future messages for that segment (if any) discarded.
public struct Speechly_Slu_V1_SLUSegmentEnd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a tentative transcript.
///
/// Tentative transcript is an interim recognition result, which may change over time,
/// e.g. a phrase "find me a red t-shirt" can be tentatively recognised as "find me a tea",
/// until the API processes the audio completely.
public struct Speechly_Slu_V1_SLUTentativeTranscript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Aggregated tentative transcript from the beginning of the audio until current moment in time.
  /// Consecutive transcripts will have this value appended to,
  /// e.g. if in the first message it's "find me", in the next it may be "find me a t-shirt".
  public var tentativeTranscript: String = String()

  /// A list of individual words which compose `tentative_transcript`.
  /// All words must be considered tentative.
  public var tentativeWords: [Speechly_Slu_V1_SLUTranscript] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes tentative entities.
public struct Speechly_Slu_V1_SLUTentativeEntities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of entities, which must be treated as tentative.
  ///
  /// This is not an aggregate of all entities in the audio,
  /// but rather it ONLY contains entities that have not been finalised yet.
  ///
  /// e.g. if at the start there are two tentatively recognised entities - ["burger restaurant", "tomorrow"]
  /// but then the API marks "burger restaurant" as final and recognises a new tentative entity "for two",
  /// this will contain ["tomorrow", "for two"].
  public var tentativeEntities: [Speechly_Slu_V1_SLUEntity] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates that the API has started processing the portion of audio as new audio context.
/// This does not guarantee that the server will not send any more messages for the previous audio context.
public struct Speechly_Slu_V1_SLUStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates that the API has stopped processing current audio context.
/// It guarantees that no new messages for that context will be sent by the server.
public struct Speechly_Slu_V1_SLUFinished {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DEPRECATED
  /// An error which has happened when processing the context, if any.
  public var error: Speechly_Slu_V1_SLUError {
    get {return _error ?? Speechly_Slu_V1_SLUError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Speechly_Slu_V1_SLUError? = nil
}

/// Describes the error that happened when processing an audio context.
public struct Speechly_Slu_V1_SLUError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error code (refer to documentation for specific codes).
  public var code: String = String()

  /// Error message.
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "speechly.slu.v1"

extension Speechly_Slu_V1_SLURequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLURequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "event"),
    3: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Speechly_Slu_V1_SLUConfig?
        if let current = self.streamingRequest {
          try decoder.handleConflictingOneOf()
          if case .config(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingRequest = .config(v)}
      }()
      case 2: try {
        var v: Speechly_Slu_V1_SLUEvent?
        if let current = self.streamingRequest {
          try decoder.handleConflictingOneOf()
          if case .event(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingRequest = .event(v)}
      }()
      case 3: try {
        if self.streamingRequest != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.streamingRequest = .audio(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.streamingRequest {
    case .config?: try {
      guard case .config(let v)? = self.streamingRequest else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .event?: try {
      guard case .event(let v)? = self.streamingRequest else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.streamingRequest else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLURequest, rhs: Speechly_Slu_V1_SLURequest) -> Bool {
    if lhs.streamingRequest != rhs.streamingRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encoding"),
    2: .same(proto: "channels"),
    3: .standard(proto: "sample_rate_hertz"),
    4: .standard(proto: "language_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.encoding) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.channels) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sampleRateHertz) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.encoding != .linear16 {
      try visitor.visitSingularEnumField(value: self.encoding, fieldNumber: 1)
    }
    if self.channels != 0 {
      try visitor.visitSingularInt32Field(value: self.channels, fieldNumber: 2)
    }
    if self.sampleRateHertz != 0 {
      try visitor.visitSingularInt32Field(value: self.sampleRateHertz, fieldNumber: 3)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUConfig, rhs: Speechly_Slu_V1_SLUConfig) -> Bool {
    if lhs.encoding != rhs.encoding {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.sampleRateHertz != rhs.sampleRateHertz {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUConfig.Encoding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINEAR16"),
  ]
}

extension Speechly_Slu_V1_SLUEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .standard(proto: "app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.event) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.event != .start {
      try visitor.visitSingularEnumField(value: self.event, fieldNumber: 1)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUEvent, rhs: Speechly_Slu_V1_SLUEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUEvent.Event: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "START"),
    1: .same(proto: "STOP"),
  ]
}

extension Speechly_Slu_V1_SLUResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_context"),
    2: .standard(proto: "segment_id"),
    3: .same(proto: "transcript"),
    4: .same(proto: "entity"),
    5: .same(proto: "intent"),
    6: .standard(proto: "segment_end"),
    7: .standard(proto: "tentative_transcript"),
    8: .standard(proto: "tentative_entities"),
    9: .standard(proto: "tentative_intent"),
    10: .same(proto: "started"),
    11: .same(proto: "finished"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.audioContext) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.segmentID) }()
      case 3: try {
        var v: Speechly_Slu_V1_SLUTranscript?
        if let current = self.streamingResponse {
          try decoder.handleConflictingOneOf()
          if case .transcript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingResponse = .transcript(v)}
      }()
      case 4: try {
        var v: Speechly_Slu_V1_SLUEntity?
        if let current = self.streamingResponse {
          try decoder.handleConflictingOneOf()
          if case .entity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingResponse = .entity(v)}
      }()
      case 5: try {
        var v: Speechly_Slu_V1_SLUIntent?
        if let current = self.streamingResponse {
          try decoder.handleConflictingOneOf()
          if case .intent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingResponse = .intent(v)}
      }()
      case 6: try {
        var v: Speechly_Slu_V1_SLUSegmentEnd?
        if let current = self.streamingResponse {
          try decoder.handleConflictingOneOf()
          if case .segmentEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingResponse = .segmentEnd(v)}
      }()
      case 7: try {
        var v: Speechly_Slu_V1_SLUTentativeTranscript?
        if let current = self.streamingResponse {
          try decoder.handleConflictingOneOf()
          if case .tentativeTranscript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingResponse = .tentativeTranscript(v)}
      }()
      case 8: try {
        var v: Speechly_Slu_V1_SLUTentativeEntities?
        if let current = self.streamingResponse {
          try decoder.handleConflictingOneOf()
          if case .tentativeEntities(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingResponse = .tentativeEntities(v)}
      }()
      case 9: try {
        var v: Speechly_Slu_V1_SLUIntent?
        if let current = self.streamingResponse {
          try decoder.handleConflictingOneOf()
          if case .tentativeIntent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingResponse = .tentativeIntent(v)}
      }()
      case 10: try {
        var v: Speechly_Slu_V1_SLUStarted?
        if let current = self.streamingResponse {
          try decoder.handleConflictingOneOf()
          if case .started(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingResponse = .started(v)}
      }()
      case 11: try {
        var v: Speechly_Slu_V1_SLUFinished?
        if let current = self.streamingResponse {
          try decoder.handleConflictingOneOf()
          if case .finished(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.streamingResponse = .finished(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audioContext.isEmpty {
      try visitor.visitSingularStringField(value: self.audioContext, fieldNumber: 1)
    }
    if self.segmentID != 0 {
      try visitor.visitSingularInt32Field(value: self.segmentID, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.streamingResponse {
    case .transcript?: try {
      guard case .transcript(let v)? = self.streamingResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .entity?: try {
      guard case .entity(let v)? = self.streamingResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .intent?: try {
      guard case .intent(let v)? = self.streamingResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .segmentEnd?: try {
      guard case .segmentEnd(let v)? = self.streamingResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .tentativeTranscript?: try {
      guard case .tentativeTranscript(let v)? = self.streamingResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .tentativeEntities?: try {
      guard case .tentativeEntities(let v)? = self.streamingResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .tentativeIntent?: try {
      guard case .tentativeIntent(let v)? = self.streamingResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .started?: try {
      guard case .started(let v)? = self.streamingResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .finished?: try {
      guard case .finished(let v)? = self.streamingResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUResponse, rhs: Speechly_Slu_V1_SLUResponse) -> Bool {
    if lhs.audioContext != rhs.audioContext {return false}
    if lhs.segmentID != rhs.segmentID {return false}
    if lhs.streamingResponse != rhs.streamingResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUTranscript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUTranscript"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "index"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.word) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.startTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 2)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt32Field(value: self.startTime, fieldNumber: 3)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt32Field(value: self.endTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUTranscript, rhs: Speechly_Slu_V1_SLUTranscript) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs.index != rhs.index {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUEntity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entity"),
    2: .same(proto: "value"),
    3: .standard(proto: "start_position"),
    4: .standard(proto: "end_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.startPosition) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.endPosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entity.isEmpty {
      try visitor.visitSingularStringField(value: self.entity, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.startPosition != 0 {
      try visitor.visitSingularInt32Field(value: self.startPosition, fieldNumber: 3)
    }
    if self.endPosition != 0 {
      try visitor.visitSingularInt32Field(value: self.endPosition, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUEntity, rhs: Speechly_Slu_V1_SLUEntity) -> Bool {
    if lhs.entity != rhs.entity {return false}
    if lhs.value != rhs.value {return false}
    if lhs.startPosition != rhs.startPosition {return false}
    if lhs.endPosition != rhs.endPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUIntent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUIntent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "intent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.intent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.intent.isEmpty {
      try visitor.visitSingularStringField(value: self.intent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUIntent, rhs: Speechly_Slu_V1_SLUIntent) -> Bool {
    if lhs.intent != rhs.intent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUSegmentEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUSegmentEnd"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUSegmentEnd, rhs: Speechly_Slu_V1_SLUSegmentEnd) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUTentativeTranscript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUTentativeTranscript"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tentative_transcript"),
    2: .standard(proto: "tentative_words"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tentativeTranscript) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tentativeWords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tentativeTranscript.isEmpty {
      try visitor.visitSingularStringField(value: self.tentativeTranscript, fieldNumber: 1)
    }
    if !self.tentativeWords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tentativeWords, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUTentativeTranscript, rhs: Speechly_Slu_V1_SLUTentativeTranscript) -> Bool {
    if lhs.tentativeTranscript != rhs.tentativeTranscript {return false}
    if lhs.tentativeWords != rhs.tentativeWords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUTentativeEntities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUTentativeEntities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tentative_entities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tentativeEntities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tentativeEntities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tentativeEntities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUTentativeEntities, rhs: Speechly_Slu_V1_SLUTentativeEntities) -> Bool {
    if lhs.tentativeEntities != rhs.tentativeEntities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUStarted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUStarted, rhs: Speechly_Slu_V1_SLUStarted) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUFinished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUFinished"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUFinished, rhs: Speechly_Slu_V1_SLUFinished) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechly_Slu_V1_SLUError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SLUError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechly_Slu_V1_SLUError, rhs: Speechly_Slu_V1_SLUError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
